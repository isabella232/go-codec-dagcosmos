package dagcosmos

// Code generated by go-ipld-prime gengo.  DO NOT EDIT.

import (
	ipld "github.com/ipld/go-ipld-prime"
	"github.com/ipld/go-ipld-prime/node/mixins"
	"github.com/ipld/go-ipld-prime/schema"
)

func (n Address) Bytes() []byte {
	return n.x
}
func (_Address__Prototype) FromBytes(v []byte) (Address, error) {
	n := _Address{v}
	return &n, nil
}

type _Address__Maybe struct {
	m schema.Maybe
	v Address
}
type MaybeAddress = *_Address__Maybe

func (m MaybeAddress) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAddress) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAddress) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAddress) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeAddress) Must() Address {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Address)(&_Address{})
var _ schema.TypedNode = (Address)(&_Address{})

func (Address) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Address) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Address"}.LookupByString("")
}
func (Address) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Address"}.LookupByNode(nil)
}
func (Address) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Address"}.LookupByIndex(0)
}
func (Address) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Address"}.LookupBySegment(seg)
}
func (Address) MapIterator() ipld.MapIterator {
	return nil
}
func (Address) ListIterator() ipld.ListIterator {
	return nil
}
func (Address) Length() int64 {
	return -1
}
func (Address) IsAbsent() bool {
	return false
}
func (Address) IsNull() bool {
	return false
}
func (Address) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Address"}.AsBool()
}
func (Address) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Address"}.AsInt()
}
func (Address) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Address"}.AsFloat()
}
func (Address) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Address"}.AsString()
}
func (n Address) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Address) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Address"}.AsLink()
}
func (Address) Prototype() ipld.NodePrototype {
	return _Address__Prototype{}
}

type _Address__Prototype struct{}

func (_Address__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Address__Builder
	nb.Reset()
	return &nb
}

type _Address__Builder struct {
	_Address__Assembler
}

func (nb *_Address__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Address__Builder) Reset() {
	var w _Address
	var m schema.Maybe
	*nb = _Address__Builder{_Address__Assembler{w: &w, m: &m}}
}

type _Address__Assembler struct {
	w *_Address
	m *schema.Maybe
}

func (na *_Address__Assembler) reset() {}
func (_Address__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Address"}.BeginMap(0)
}
func (_Address__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Address"}.BeginList(0)
}
func (na *_Address__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Address"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Address__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Address"}.AssignBool(false)
}
func (_Address__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Address"}.AssignInt(0)
}
func (_Address__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Address"}.AssignFloat(0)
}
func (_Address__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Address"}.AssignString("")
}
func (na *_Address__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Address{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Address__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Address"}.AssignLink(nil)
}
func (na *_Address__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Address); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Address__Assembler) Prototype() ipld.NodePrototype {
	return _Address__Prototype{}
}
func (Address) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Address) Representation() ipld.Node {
	return (*_Address__Repr)(n)
}

type _Address__Repr = _Address

var _ ipld.Node = &_Address__Repr{}

type _Address__ReprPrototype = _Address__Prototype
type _Address__ReprAssembler = _Address__Assembler

func (n *_Aunts) Lookup(idx int64) Hash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Aunts) LookupMaybe(idx int64) MaybeHash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Hash__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Aunts__valueAbsent = _Hash__Maybe{m: schema.Maybe_Absent}

func (n Aunts) Iterator() *Aunts__Itr {
	return &Aunts__Itr{n, 0}
}

type Aunts__Itr struct {
	n   Aunts
	idx int
}

func (itr *Aunts__Itr) Next() (idx int64, v Hash) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Aunts__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Aunts__Maybe struct {
	m schema.Maybe
	v Aunts
}
type MaybeAunts = *_Aunts__Maybe

func (m MaybeAunts) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAunts) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAunts) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAunts) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeAunts) Must() Aunts {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Aunts)(&_Aunts{})
var _ schema.TypedNode = (Aunts)(&_Aunts{})

func (Aunts) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Aunts) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Aunts"}.LookupByString("")
}
func (n Aunts) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Aunts) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Aunts) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Aunts", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Aunts) MapIterator() ipld.MapIterator {
	return nil
}
func (n Aunts) ListIterator() ipld.ListIterator {
	return &_Aunts__ListItr{n, 0}
}

type _Aunts__ListItr struct {
	n   Aunts
	idx int
}

func (itr *_Aunts__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Aunts__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Aunts) Length() int64 {
	return int64(len(n.x))
}
func (Aunts) IsAbsent() bool {
	return false
}
func (Aunts) IsNull() bool {
	return false
}
func (Aunts) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsBool()
}
func (Aunts) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsInt()
}
func (Aunts) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsFloat()
}
func (Aunts) AsString() (string, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsString()
}
func (Aunts) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsBytes()
}
func (Aunts) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsLink()
}
func (Aunts) Prototype() ipld.NodePrototype {
	return _Aunts__Prototype{}
}

type _Aunts__Prototype struct{}

func (_Aunts__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Aunts__Builder
	nb.Reset()
	return &nb
}

type _Aunts__Builder struct {
	_Aunts__Assembler
}

func (nb *_Aunts__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Aunts__Builder) Reset() {
	var w _Aunts
	var m schema.Maybe
	*nb = _Aunts__Builder{_Aunts__Assembler{w: &w, m: &m}}
}

type _Aunts__Assembler struct {
	w     *_Aunts
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__Assembler
}

func (na *_Aunts__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Aunts__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.BeginMap(0)
}
func (na *_Aunts__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Aunts{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_Aunts__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Aunts__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignBool(false)
}
func (_Aunts__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignInt(0)
}
func (_Aunts__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignFloat(0)
}
func (_Aunts__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignString("")
}
func (_Aunts__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignBytes(nil)
}
func (_Aunts__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignLink(nil)
}
func (na *_Aunts__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Aunts); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Aunts", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Aunts__Assembler) Prototype() ipld.NodePrototype {
	return _Aunts__Prototype{}
}
func (la *_Aunts__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Aunts__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Aunts__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Aunts__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__Prototype{}
}
func (Aunts) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Aunts) Representation() ipld.Node {
	return (*_Aunts__Repr)(n)
}

type _Aunts__Repr _Aunts

var _ ipld.Node = &_Aunts__Repr{}

func (_Aunts__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Aunts__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.LookupByString("")
}
func (nr *_Aunts__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Aunts)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (nr *_Aunts__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Aunts)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (n _Aunts__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Aunts.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Aunts__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Aunts__Repr) ListIterator() ipld.ListIterator {
	return &_Aunts__ReprListItr{(Aunts)(nr), 0}
}

type _Aunts__ReprListItr _Aunts__ListItr

func (itr *_Aunts__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Aunts__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Hash).Representation(), nil
}
func (itr *_Aunts__ReprListItr) Done() bool {
	return (*_Aunts__ListItr)(itr).Done()
}

func (rn *_Aunts__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Aunts__Repr) IsAbsent() bool {
	return false
}
func (_Aunts__Repr) IsNull() bool {
	return false
}
func (_Aunts__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsBool()
}
func (_Aunts__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsInt()
}
func (_Aunts__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsFloat()
}
func (_Aunts__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsString()
}
func (_Aunts__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsBytes()
}
func (_Aunts__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsLink()
}
func (_Aunts__Repr) Prototype() ipld.NodePrototype {
	return _Aunts__ReprPrototype{}
}

type _Aunts__ReprPrototype struct{}

func (_Aunts__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Aunts__ReprBuilder
	nb.Reset()
	return &nb
}

type _Aunts__ReprBuilder struct {
	_Aunts__ReprAssembler
}

func (nb *_Aunts__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Aunts__ReprBuilder) Reset() {
	var w _Aunts
	var m schema.Maybe
	*nb = _Aunts__ReprBuilder{_Aunts__ReprAssembler{w: &w, m: &m}}
}

type _Aunts__ReprAssembler struct {
	w     *_Aunts
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__ReprAssembler
}

func (na *_Aunts__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Aunts__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.BeginMap(0)
}
func (na *_Aunts__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Aunts{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_Aunts__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Aunts.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Aunts__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignBool(false)
}
func (_Aunts__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignInt(0)
}
func (_Aunts__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignFloat(0)
}
func (_Aunts__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignString("")
}
func (_Aunts__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignBytes(nil)
}
func (_Aunts__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignLink(nil)
}
func (na *_Aunts__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Aunts); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Aunts.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Aunts__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Aunts__ReprPrototype{}
}
func (la *_Aunts__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Aunts__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Aunts__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Aunts__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__ReprPrototype{}
}

func (n _Block) FieldHeader() Header {
	return &n.Header
}
func (n _Block) FieldData() Data {
	return &n.Data
}
func (n _Block) FieldEvidence() EvidenceData {
	return &n.Evidence
}
func (n _Block) FieldLastCommit() Commit {
	return &n.LastCommit
}

type _Block__Maybe struct {
	m schema.Maybe
	v Block
}
type MaybeBlock = *_Block__Maybe

func (m MaybeBlock) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBlock) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBlock) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBlock) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBlock) Must() Block {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Block_Header     = _String{"Header"}
	fieldName__Block_Data       = _String{"Data"}
	fieldName__Block_Evidence   = _String{"Evidence"}
	fieldName__Block_LastCommit = _String{"LastCommit"}
)
var _ ipld.Node = (Block)(&_Block{})
var _ schema.TypedNode = (Block)(&_Block{})

func (Block) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Block) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Header":
		return &n.Header, nil
	case "Data":
		return &n.Data, nil
	case "Evidence":
		return &n.Evidence, nil
	case "LastCommit":
		return &n.LastCommit, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Block) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Block) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Block"}.LookupByIndex(0)
}
func (n Block) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Block) MapIterator() ipld.MapIterator {
	return &_Block__MapItr{n, 0}
}

type _Block__MapItr struct {
	n   Block
	idx int
}

func (itr *_Block__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Block_Header
		v = &itr.n.Header
	case 1:
		k = &fieldName__Block_Data
		v = &itr.n.Data
	case 2:
		k = &fieldName__Block_Evidence
		v = &itr.n.Evidence
	case 3:
		k = &fieldName__Block_LastCommit
		v = &itr.n.LastCommit
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Block__MapItr) Done() bool {
	return itr.idx >= 4
}

func (Block) ListIterator() ipld.ListIterator {
	return nil
}
func (Block) Length() int64 {
	return 4
}
func (Block) IsAbsent() bool {
	return false
}
func (Block) IsNull() bool {
	return false
}
func (Block) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Block"}.AsBool()
}
func (Block) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Block"}.AsInt()
}
func (Block) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Block"}.AsFloat()
}
func (Block) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Block"}.AsString()
}
func (Block) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Block"}.AsBytes()
}
func (Block) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Block"}.AsLink()
}
func (Block) Prototype() ipld.NodePrototype {
	return _Block__Prototype{}
}

type _Block__Prototype struct{}

func (_Block__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Block__Builder
	nb.Reset()
	return &nb
}

type _Block__Builder struct {
	_Block__Assembler
}

func (nb *_Block__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Block__Builder) Reset() {
	var w _Block
	var m schema.Maybe
	*nb = _Block__Builder{_Block__Assembler{w: &w, m: &m}}
}

type _Block__Assembler struct {
	w     *_Block
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Header     _Header__Assembler
	ca_Data       _Data__Assembler
	ca_Evidence   _EvidenceData__Assembler
	ca_LastCommit _Commit__Assembler
}

func (na *_Block__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Header.reset()
	na.ca_Data.reset()
	na.ca_Evidence.reset()
	na.ca_LastCommit.reset()
}

var (
	fieldBit__Block_Header      = 1 << 0
	fieldBit__Block_Data        = 1 << 1
	fieldBit__Block_Evidence    = 1 << 2
	fieldBit__Block_LastCommit  = 1 << 3
	fieldBits__Block_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_Block__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Block{}
	}
	return na, nil
}
func (_Block__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Block"}.BeginList(0)
}
func (na *_Block__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Block"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Block__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignBool(false)
}
func (_Block__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignInt(0)
}
func (_Block__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignFloat(0)
}
func (_Block__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignString("")
}
func (_Block__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignBytes(nil)
}
func (_Block__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignLink(nil)
}
func (na *_Block__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Block); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Block", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Block__Assembler) Prototype() ipld.NodePrototype {
	return _Block__Prototype{}
}
func (ma *_Block__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Header.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Data.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Evidence.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_LastCommit.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Block__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Header":
		if ma.s&fieldBit__Block_Header != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header}
		}
		ma.s += fieldBit__Block_Header
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header, nil
	case "Data":
		if ma.s&fieldBit__Block_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Data}
		}
		ma.s += fieldBit__Block_Data
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	case "Evidence":
		if ma.s&fieldBit__Block_Evidence != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Evidence}
		}
		ma.s += fieldBit__Block_Evidence
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence, nil
	case "LastCommit":
		if ma.s&fieldBit__Block_LastCommit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_LastCommit}
		}
		ma.s += fieldBit__Block_LastCommit
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_LastCommit.w = &ma.w.LastCommit
		ma.ca_LastCommit.m = &ma.cm
		return &ma.ca_LastCommit, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Block", Key: &_String{k}}
}
func (ma *_Block__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Block__KeyAssembler)(ma)
}
func (ma *_Block__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header
	case 1:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	case 2:
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence
	case 3:
		ma.ca_LastCommit.w = &ma.w.LastCommit
		ma.ca_LastCommit.m = &ma.cm
		return &ma.ca_LastCommit
	default:
		panic("unreachable")
	}
}
func (ma *_Block__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Block_sufficient != fieldBits__Block_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Block_Header == 0 {
			err.Missing = append(err.Missing, "Header")
		}
		if ma.s&fieldBit__Block_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		if ma.s&fieldBit__Block_Evidence == 0 {
			err.Missing = append(err.Missing, "Evidence")
		}
		if ma.s&fieldBit__Block_LastCommit == 0 {
			err.Missing = append(err.Missing, "LastCommit")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Block__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Block__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Block__KeyAssembler _Block__Assembler

func (_Block__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.BeginMap(0)
}
func (_Block__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.BeginList(0)
}
func (na *_Block__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignNull()
}
func (_Block__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignBool(false)
}
func (_Block__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignInt(0)
}
func (_Block__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Block__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Header":
		if ka.s&fieldBit__Block_Header != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header}
		}
		ka.s += fieldBit__Block_Header
		ka.state = maState_expectValue
		ka.f = 0
	case "Data":
		if ka.s&fieldBit__Block_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Data}
		}
		ka.s += fieldBit__Block_Data
		ka.state = maState_expectValue
		ka.f = 1
	case "Evidence":
		if ka.s&fieldBit__Block_Evidence != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Evidence}
		}
		ka.s += fieldBit__Block_Evidence
		ka.state = maState_expectValue
		ka.f = 2
	case "LastCommit":
		if ka.s&fieldBit__Block_LastCommit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_LastCommit}
		}
		ka.s += fieldBit__Block_LastCommit
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Block", Key: &_String{k}}
	}
	return nil
}
func (_Block__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignBytes(nil)
}
func (_Block__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Block__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Block__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Block) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Block) Representation() ipld.Node {
	return (*_Block__Repr)(n)
}

type _Block__Repr _Block

var (
	fieldName__Block_Header_serial     = _String{"Header"}
	fieldName__Block_Data_serial       = _String{"Data"}
	fieldName__Block_Evidence_serial   = _String{"Evidence"}
	fieldName__Block_LastCommit_serial = _String{"LastCommit"}
)
var _ ipld.Node = &_Block__Repr{}

func (_Block__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Block__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Header":
		return n.Header.Representation(), nil
	case "Data":
		return n.Data.Representation(), nil
	case "Evidence":
		return n.Evidence.Representation(), nil
	case "LastCommit":
		return n.LastCommit.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Block__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Block__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.LookupByIndex(0)
}
func (n _Block__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Block__Repr) MapIterator() ipld.MapIterator {
	return &_Block__ReprMapItr{n, 0}
}

type _Block__ReprMapItr struct {
	n   *_Block__Repr
	idx int
}

func (itr *_Block__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Block_Header_serial
		v = itr.n.Header.Representation()
	case 1:
		k = &fieldName__Block_Data_serial
		v = itr.n.Data.Representation()
	case 2:
		k = &fieldName__Block_Evidence_serial
		v = itr.n.Evidence.Representation()
	case 3:
		k = &fieldName__Block_LastCommit_serial
		v = itr.n.LastCommit.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Block__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_Block__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Block__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_Block__Repr) IsAbsent() bool {
	return false
}
func (_Block__Repr) IsNull() bool {
	return false
}
func (_Block__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsBool()
}
func (_Block__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsInt()
}
func (_Block__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsFloat()
}
func (_Block__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsString()
}
func (_Block__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsBytes()
}
func (_Block__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsLink()
}
func (_Block__Repr) Prototype() ipld.NodePrototype {
	return _Block__ReprPrototype{}
}

type _Block__ReprPrototype struct{}

func (_Block__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Block__ReprBuilder
	nb.Reset()
	return &nb
}

type _Block__ReprBuilder struct {
	_Block__ReprAssembler
}

func (nb *_Block__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Block__ReprBuilder) Reset() {
	var w _Block
	var m schema.Maybe
	*nb = _Block__ReprBuilder{_Block__ReprAssembler{w: &w, m: &m}}
}

type _Block__ReprAssembler struct {
	w     *_Block
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Header     _Header__ReprAssembler
	ca_Data       _Data__ReprAssembler
	ca_Evidence   _EvidenceData__ReprAssembler
	ca_LastCommit _Commit__ReprAssembler
}

func (na *_Block__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Header.reset()
	na.ca_Data.reset()
	na.ca_Evidence.reset()
	na.ca_LastCommit.reset()
}
func (na *_Block__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Block{}
	}
	return na, nil
}
func (_Block__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.BeginList(0)
}
func (na *_Block__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Block.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Block__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignBool(false)
}
func (_Block__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignInt(0)
}
func (_Block__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignFloat(0)
}
func (_Block__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignString("")
}
func (_Block__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignBytes(nil)
}
func (_Block__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignLink(nil)
}
func (na *_Block__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Block); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Block.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Block__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Block__ReprPrototype{}
}
func (ma *_Block__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Block__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Header":
		if ma.s&fieldBit__Block_Header != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header_serial}
		}
		ma.s += fieldBit__Block_Header
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header, nil
	case "Data":
		if ma.s&fieldBit__Block_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Data_serial}
		}
		ma.s += fieldBit__Block_Data
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	case "Evidence":
		if ma.s&fieldBit__Block_Evidence != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Evidence_serial}
		}
		ma.s += fieldBit__Block_Evidence
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence, nil
	case "LastCommit":
		if ma.s&fieldBit__Block_LastCommit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_LastCommit_serial}
		}
		ma.s += fieldBit__Block_LastCommit
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_LastCommit.w = &ma.w.LastCommit
		ma.ca_LastCommit.m = &ma.cm
		return &ma.ca_LastCommit, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Block.Repr", Key: &_String{k}}
}
func (ma *_Block__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Block__ReprKeyAssembler)(ma)
}
func (ma *_Block__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header
	case 1:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	case 2:
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence
	case 3:
		ma.ca_LastCommit.w = &ma.w.LastCommit
		ma.ca_LastCommit.m = &ma.cm
		return &ma.ca_LastCommit
	default:
		panic("unreachable")
	}
}
func (ma *_Block__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Block_sufficient != fieldBits__Block_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Block_Header == 0 {
			err.Missing = append(err.Missing, "Header")
		}
		if ma.s&fieldBit__Block_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		if ma.s&fieldBit__Block_Evidence == 0 {
			err.Missing = append(err.Missing, "Evidence")
		}
		if ma.s&fieldBit__Block_LastCommit == 0 {
			err.Missing = append(err.Missing, "LastCommit")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Block__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Block__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Block__ReprKeyAssembler _Block__ReprAssembler

func (_Block__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Block__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Block__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignNull()
}
func (_Block__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Block__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Block__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Block__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Header":
		if ka.s&fieldBit__Block_Header != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header_serial}
		}
		ka.s += fieldBit__Block_Header
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Data":
		if ka.s&fieldBit__Block_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Data_serial}
		}
		ka.s += fieldBit__Block_Data
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Evidence":
		if ka.s&fieldBit__Block_Evidence != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Evidence_serial}
		}
		ka.s += fieldBit__Block_Evidence
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "LastCommit":
		if ka.s&fieldBit__Block_LastCommit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_LastCommit_serial}
		}
		ka.s += fieldBit__Block_LastCommit
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Block.Repr", Key: &_String{k}}
}
func (_Block__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Block__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Block__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Block__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _BlockID) FieldHash() Link {
	return &n.Hash
}
func (n _BlockID) FieldPartSetHeader() PartSetHeader {
	return &n.PartSetHeader
}

type _BlockID__Maybe struct {
	m schema.Maybe
	v BlockID
}
type MaybeBlockID = *_BlockID__Maybe

func (m MaybeBlockID) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBlockID) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBlockID) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBlockID) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBlockID) Must() BlockID {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__BlockID_Hash          = _String{"Hash"}
	fieldName__BlockID_PartSetHeader = _String{"PartSetHeader"}
)
var _ ipld.Node = (BlockID)(&_BlockID{})
var _ schema.TypedNode = (BlockID)(&_BlockID{})

func (BlockID) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n BlockID) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Hash":
		return &n.Hash, nil
	case "PartSetHeader":
		return &n.PartSetHeader, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n BlockID) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (BlockID) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.BlockID"}.LookupByIndex(0)
}
func (n BlockID) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n BlockID) MapIterator() ipld.MapIterator {
	return &_BlockID__MapItr{n, 0}
}

type _BlockID__MapItr struct {
	n   BlockID
	idx int
}

func (itr *_BlockID__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__BlockID_Hash
		v = &itr.n.Hash
	case 1:
		k = &fieldName__BlockID_PartSetHeader
		v = &itr.n.PartSetHeader
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_BlockID__MapItr) Done() bool {
	return itr.idx >= 2
}

func (BlockID) ListIterator() ipld.ListIterator {
	return nil
}
func (BlockID) Length() int64 {
	return 2
}
func (BlockID) IsAbsent() bool {
	return false
}
func (BlockID) IsNull() bool {
	return false
}
func (BlockID) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsBool()
}
func (BlockID) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsInt()
}
func (BlockID) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsFloat()
}
func (BlockID) AsString() (string, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsString()
}
func (BlockID) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsBytes()
}
func (BlockID) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsLink()
}
func (BlockID) Prototype() ipld.NodePrototype {
	return _BlockID__Prototype{}
}

type _BlockID__Prototype struct{}

func (_BlockID__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _BlockID__Builder
	nb.Reset()
	return &nb
}

type _BlockID__Builder struct {
	_BlockID__Assembler
}

func (nb *_BlockID__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_BlockID__Builder) Reset() {
	var w _BlockID
	var m schema.Maybe
	*nb = _BlockID__Builder{_BlockID__Assembler{w: &w, m: &m}}
}

type _BlockID__Assembler struct {
	w     *_BlockID
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm               schema.Maybe
	ca_Hash          _Link__Assembler
	ca_PartSetHeader _PartSetHeader__Assembler
}

func (na *_BlockID__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Hash.reset()
	na.ca_PartSetHeader.reset()
}

var (
	fieldBit__BlockID_Hash          = 1 << 0
	fieldBit__BlockID_PartSetHeader = 1 << 1
	fieldBits__BlockID_sufficient   = 0 + 1<<0 + 1<<1
)

func (na *_BlockID__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_BlockID{}
	}
	return na, nil
}
func (_BlockID__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.BeginList(0)
}
func (na *_BlockID__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_BlockID__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignBool(false)
}
func (_BlockID__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignInt(0)
}
func (_BlockID__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignFloat(0)
}
func (_BlockID__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignString("")
}
func (_BlockID__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignBytes(nil)
}
func (_BlockID__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignLink(nil)
}
func (na *_BlockID__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_BlockID); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.BlockID", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_BlockID__Assembler) Prototype() ipld.NodePrototype {
	return _BlockID__Prototype{}
}
func (ma *_BlockID__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Hash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PartSetHeader.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_BlockID__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Hash":
		if ma.s&fieldBit__BlockID_Hash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_Hash}
		}
		ma.s += fieldBit__BlockID_Hash
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash, nil
	case "PartSetHeader":
		if ma.s&fieldBit__BlockID_PartSetHeader != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_PartSetHeader}
		}
		ma.s += fieldBit__BlockID_PartSetHeader
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PartSetHeader.w = &ma.w.PartSetHeader
		ma.ca_PartSetHeader.m = &ma.cm
		return &ma.ca_PartSetHeader, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockID", Key: &_String{k}}
}
func (ma *_BlockID__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_BlockID__KeyAssembler)(ma)
}
func (ma *_BlockID__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash
	case 1:
		ma.ca_PartSetHeader.w = &ma.w.PartSetHeader
		ma.ca_PartSetHeader.m = &ma.cm
		return &ma.ca_PartSetHeader
	default:
		panic("unreachable")
	}
}
func (ma *_BlockID__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__BlockID_sufficient != fieldBits__BlockID_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__BlockID_Hash == 0 {
			err.Missing = append(err.Missing, "Hash")
		}
		if ma.s&fieldBit__BlockID_PartSetHeader == 0 {
			err.Missing = append(err.Missing, "PartSetHeader")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_BlockID__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_BlockID__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _BlockID__KeyAssembler _BlockID__Assembler

func (_BlockID__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.BeginMap(0)
}
func (_BlockID__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.BeginList(0)
}
func (na *_BlockID__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignNull()
}
func (_BlockID__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignBool(false)
}
func (_BlockID__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignInt(0)
}
func (_BlockID__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignFloat(0)
}
func (ka *_BlockID__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Hash":
		if ka.s&fieldBit__BlockID_Hash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_Hash}
		}
		ka.s += fieldBit__BlockID_Hash
		ka.state = maState_expectValue
		ka.f = 0
	case "PartSetHeader":
		if ka.s&fieldBit__BlockID_PartSetHeader != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_PartSetHeader}
		}
		ka.s += fieldBit__BlockID_PartSetHeader
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockID", Key: &_String{k}}
	}
	return nil
}
func (_BlockID__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignBytes(nil)
}
func (_BlockID__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignLink(nil)
}
func (ka *_BlockID__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_BlockID__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (BlockID) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n BlockID) Representation() ipld.Node {
	return (*_BlockID__Repr)(n)
}

type _BlockID__Repr _BlockID

var (
	fieldName__BlockID_Hash_serial          = _String{"Hash"}
	fieldName__BlockID_PartSetHeader_serial = _String{"PartSetHeader"}
)
var _ ipld.Node = &_BlockID__Repr{}

func (_BlockID__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_BlockID__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Hash":
		return n.Hash.Representation(), nil
	case "PartSetHeader":
		return n.PartSetHeader.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_BlockID__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_BlockID__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.LookupByIndex(0)
}
func (n _BlockID__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_BlockID__Repr) MapIterator() ipld.MapIterator {
	return &_BlockID__ReprMapItr{n, 0}
}

type _BlockID__ReprMapItr struct {
	n   *_BlockID__Repr
	idx int
}

func (itr *_BlockID__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__BlockID_Hash_serial
		v = itr.n.Hash.Representation()
	case 1:
		k = &fieldName__BlockID_PartSetHeader_serial
		v = itr.n.PartSetHeader.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_BlockID__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_BlockID__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_BlockID__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_BlockID__Repr) IsAbsent() bool {
	return false
}
func (_BlockID__Repr) IsNull() bool {
	return false
}
func (_BlockID__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsBool()
}
func (_BlockID__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsInt()
}
func (_BlockID__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsFloat()
}
func (_BlockID__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsString()
}
func (_BlockID__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsBytes()
}
func (_BlockID__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsLink()
}
func (_BlockID__Repr) Prototype() ipld.NodePrototype {
	return _BlockID__ReprPrototype{}
}

type _BlockID__ReprPrototype struct{}

func (_BlockID__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _BlockID__ReprBuilder
	nb.Reset()
	return &nb
}

type _BlockID__ReprBuilder struct {
	_BlockID__ReprAssembler
}

func (nb *_BlockID__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_BlockID__ReprBuilder) Reset() {
	var w _BlockID
	var m schema.Maybe
	*nb = _BlockID__ReprBuilder{_BlockID__ReprAssembler{w: &w, m: &m}}
}

type _BlockID__ReprAssembler struct {
	w     *_BlockID
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm               schema.Maybe
	ca_Hash          _Link__ReprAssembler
	ca_PartSetHeader _PartSetHeader__ReprAssembler
}

func (na *_BlockID__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Hash.reset()
	na.ca_PartSetHeader.reset()
}
func (na *_BlockID__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_BlockID{}
	}
	return na, nil
}
func (_BlockID__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.BeginList(0)
}
func (na *_BlockID__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.BlockID.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_BlockID__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignBool(false)
}
func (_BlockID__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignInt(0)
}
func (_BlockID__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignFloat(0)
}
func (_BlockID__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignString("")
}
func (_BlockID__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignBytes(nil)
}
func (_BlockID__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignLink(nil)
}
func (na *_BlockID__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_BlockID); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.BlockID.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_BlockID__ReprAssembler) Prototype() ipld.NodePrototype {
	return _BlockID__ReprPrototype{}
}
func (ma *_BlockID__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_BlockID__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Hash":
		if ma.s&fieldBit__BlockID_Hash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_Hash_serial}
		}
		ma.s += fieldBit__BlockID_Hash
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash, nil
	case "PartSetHeader":
		if ma.s&fieldBit__BlockID_PartSetHeader != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_PartSetHeader_serial}
		}
		ma.s += fieldBit__BlockID_PartSetHeader
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PartSetHeader.w = &ma.w.PartSetHeader
		ma.ca_PartSetHeader.m = &ma.cm
		return &ma.ca_PartSetHeader, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockID.Repr", Key: &_String{k}}
}
func (ma *_BlockID__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_BlockID__ReprKeyAssembler)(ma)
}
func (ma *_BlockID__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash
	case 1:
		ma.ca_PartSetHeader.w = &ma.w.PartSetHeader
		ma.ca_PartSetHeader.m = &ma.cm
		return &ma.ca_PartSetHeader
	default:
		panic("unreachable")
	}
}
func (ma *_BlockID__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__BlockID_sufficient != fieldBits__BlockID_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__BlockID_Hash == 0 {
			err.Missing = append(err.Missing, "Hash")
		}
		if ma.s&fieldBit__BlockID_PartSetHeader == 0 {
			err.Missing = append(err.Missing, "PartSetHeader")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_BlockID__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_BlockID__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _BlockID__ReprKeyAssembler _BlockID__ReprAssembler

func (_BlockID__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.BeginMap(0)
}
func (_BlockID__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_BlockID__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignNull()
}
func (_BlockID__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignBool(false)
}
func (_BlockID__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignInt(0)
}
func (_BlockID__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_BlockID__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Hash":
		if ka.s&fieldBit__BlockID_Hash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_Hash_serial}
		}
		ka.s += fieldBit__BlockID_Hash
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "PartSetHeader":
		if ka.s&fieldBit__BlockID_PartSetHeader != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_PartSetHeader_serial}
		}
		ka.s += fieldBit__BlockID_PartSetHeader
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockID.Repr", Key: &_String{k}}
}
func (_BlockID__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_BlockID__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_BlockID__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_BlockID__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n BlockIDFlag) Int() int64 {
	return n.x
}
func (_BlockIDFlag__Prototype) FromInt(v int64) (BlockIDFlag, error) {
	n := _BlockIDFlag{v}
	return &n, nil
}

type _BlockIDFlag__Maybe struct {
	m schema.Maybe
	v BlockIDFlag
}
type MaybeBlockIDFlag = *_BlockIDFlag__Maybe

func (m MaybeBlockIDFlag) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBlockIDFlag) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBlockIDFlag) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBlockIDFlag) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBlockIDFlag) Must() BlockIDFlag {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (BlockIDFlag)(&_BlockIDFlag{})
var _ schema.TypedNode = (BlockIDFlag)(&_BlockIDFlag{})

func (BlockIDFlag) Kind() ipld.Kind {
	return ipld.Kind_Int
}
func (BlockIDFlag) LookupByString(string) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.LookupByString("")
}
func (BlockIDFlag) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.LookupByNode(nil)
}
func (BlockIDFlag) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.LookupByIndex(0)
}
func (BlockIDFlag) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.LookupBySegment(seg)
}
func (BlockIDFlag) MapIterator() ipld.MapIterator {
	return nil
}
func (BlockIDFlag) ListIterator() ipld.ListIterator {
	return nil
}
func (BlockIDFlag) Length() int64 {
	return -1
}
func (BlockIDFlag) IsAbsent() bool {
	return false
}
func (BlockIDFlag) IsNull() bool {
	return false
}
func (BlockIDFlag) AsBool() (bool, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.AsBool()
}
func (n BlockIDFlag) AsInt() (int64, error) {
	return n.x, nil
}
func (BlockIDFlag) AsFloat() (float64, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.AsFloat()
}
func (BlockIDFlag) AsString() (string, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.AsString()
}
func (BlockIDFlag) AsBytes() ([]byte, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.AsBytes()
}
func (BlockIDFlag) AsLink() (ipld.Link, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.AsLink()
}
func (BlockIDFlag) Prototype() ipld.NodePrototype {
	return _BlockIDFlag__Prototype{}
}

type _BlockIDFlag__Prototype struct{}

func (_BlockIDFlag__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _BlockIDFlag__Builder
	nb.Reset()
	return &nb
}

type _BlockIDFlag__Builder struct {
	_BlockIDFlag__Assembler
}

func (nb *_BlockIDFlag__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_BlockIDFlag__Builder) Reset() {
	var w _BlockIDFlag
	var m schema.Maybe
	*nb = _BlockIDFlag__Builder{_BlockIDFlag__Assembler{w: &w, m: &m}}
}

type _BlockIDFlag__Assembler struct {
	w *_BlockIDFlag
	m *schema.Maybe
}

func (na *_BlockIDFlag__Assembler) reset() {}
func (_BlockIDFlag__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.BeginMap(0)
}
func (_BlockIDFlag__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.BeginList(0)
}
func (na *_BlockIDFlag__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_BlockIDFlag__Assembler) AssignBool(bool) error {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignBool(false)
}
func (na *_BlockIDFlag__Assembler) AssignInt(v int64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_BlockIDFlag{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_BlockIDFlag__Assembler) AssignFloat(float64) error {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignFloat(0)
}
func (_BlockIDFlag__Assembler) AssignString(string) error {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignString("")
}
func (_BlockIDFlag__Assembler) AssignBytes([]byte) error {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignBytes(nil)
}
func (_BlockIDFlag__Assembler) AssignLink(ipld.Link) error {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignLink(nil)
}
func (na *_BlockIDFlag__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_BlockIDFlag); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsInt(); err != nil {
		return err
	} else {
		return na.AssignInt(v2)
	}
}
func (_BlockIDFlag__Assembler) Prototype() ipld.NodePrototype {
	return _BlockIDFlag__Prototype{}
}
func (BlockIDFlag) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n BlockIDFlag) Representation() ipld.Node {
	return (*_BlockIDFlag__Repr)(n)
}

type _BlockIDFlag__Repr = _BlockIDFlag

var _ ipld.Node = &_BlockIDFlag__Repr{}

type _BlockIDFlag__ReprPrototype = _BlockIDFlag__Prototype
type _BlockIDFlag__ReprAssembler = _BlockIDFlag__Assembler

func (n Bytes) Bytes() []byte {
	return n.x
}
func (_Bytes__Prototype) FromBytes(v []byte) (Bytes, error) {
	n := _Bytes{v}
	return &n, nil
}

type _Bytes__Maybe struct {
	m schema.Maybe
	v Bytes
}
type MaybeBytes = *_Bytes__Maybe

func (m MaybeBytes) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBytes) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBytes) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBytes) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBytes) Must() Bytes {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Bytes)(&_Bytes{})
var _ schema.TypedNode = (Bytes)(&_Bytes{})

func (Bytes) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Bytes) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.LookupByString("")
}
func (Bytes) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.LookupByNode(nil)
}
func (Bytes) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.LookupByIndex(0)
}
func (Bytes) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.LookupBySegment(seg)
}
func (Bytes) MapIterator() ipld.MapIterator {
	return nil
}
func (Bytes) ListIterator() ipld.ListIterator {
	return nil
}
func (Bytes) Length() int64 {
	return -1
}
func (Bytes) IsAbsent() bool {
	return false
}
func (Bytes) IsNull() bool {
	return false
}
func (Bytes) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.AsBool()
}
func (Bytes) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.AsInt()
}
func (Bytes) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.AsFloat()
}
func (Bytes) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.AsString()
}
func (n Bytes) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Bytes) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.AsLink()
}
func (Bytes) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}

type _Bytes__Prototype struct{}

func (_Bytes__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Bytes__Builder
	nb.Reset()
	return &nb
}

type _Bytes__Builder struct {
	_Bytes__Assembler
}

func (nb *_Bytes__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Bytes__Builder) Reset() {
	var w _Bytes
	var m schema.Maybe
	*nb = _Bytes__Builder{_Bytes__Assembler{w: &w, m: &m}}
}

type _Bytes__Assembler struct {
	w *_Bytes
	m *schema.Maybe
}

func (na *_Bytes__Assembler) reset() {}
func (_Bytes__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.BeginMap(0)
}
func (_Bytes__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.BeginList(0)
}
func (na *_Bytes__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Bytes__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignBool(false)
}
func (_Bytes__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignInt(0)
}
func (_Bytes__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignFloat(0)
}
func (_Bytes__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignString("")
}
func (na *_Bytes__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Bytes{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Bytes__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignLink(nil)
}
func (na *_Bytes__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Bytes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Bytes__Assembler) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}
func (Bytes) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Bytes) Representation() ipld.Node {
	return (*_Bytes__Repr)(n)
}

type _Bytes__Repr = _Bytes

var _ ipld.Node = &_Bytes__Repr{}

type _Bytes__ReprPrototype = _Bytes__Prototype
type _Bytes__ReprAssembler = _Bytes__Assembler

func (n _Commit) FieldHeight() Int {
	return &n.Height
}
func (n _Commit) FieldRound() Int {
	return &n.Round
}
func (n _Commit) FieldBlockID() BlockID {
	return &n.BlockID
}
func (n _Commit) FieldSignatures() Signatures {
	return &n.Signatures
}

type _Commit__Maybe struct {
	m schema.Maybe
	v Commit
}
type MaybeCommit = *_Commit__Maybe

func (m MaybeCommit) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeCommit) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeCommit) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeCommit) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeCommit) Must() Commit {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Commit_Height     = _String{"Height"}
	fieldName__Commit_Round      = _String{"Round"}
	fieldName__Commit_BlockID    = _String{"BlockID"}
	fieldName__Commit_Signatures = _String{"Signatures"}
)
var _ ipld.Node = (Commit)(&_Commit{})
var _ schema.TypedNode = (Commit)(&_Commit{})

func (Commit) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Commit) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Height":
		return &n.Height, nil
	case "Round":
		return &n.Round, nil
	case "BlockID":
		return &n.BlockID, nil
	case "Signatures":
		return &n.Signatures, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Commit) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Commit) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Commit"}.LookupByIndex(0)
}
func (n Commit) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Commit) MapIterator() ipld.MapIterator {
	return &_Commit__MapItr{n, 0}
}

type _Commit__MapItr struct {
	n   Commit
	idx int
}

func (itr *_Commit__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Commit_Height
		v = &itr.n.Height
	case 1:
		k = &fieldName__Commit_Round
		v = &itr.n.Round
	case 2:
		k = &fieldName__Commit_BlockID
		v = &itr.n.BlockID
	case 3:
		k = &fieldName__Commit_Signatures
		v = &itr.n.Signatures
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Commit__MapItr) Done() bool {
	return itr.idx >= 4
}

func (Commit) ListIterator() ipld.ListIterator {
	return nil
}
func (Commit) Length() int64 {
	return 4
}
func (Commit) IsAbsent() bool {
	return false
}
func (Commit) IsNull() bool {
	return false
}
func (Commit) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsBool()
}
func (Commit) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsInt()
}
func (Commit) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsFloat()
}
func (Commit) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsString()
}
func (Commit) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsBytes()
}
func (Commit) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsLink()
}
func (Commit) Prototype() ipld.NodePrototype {
	return _Commit__Prototype{}
}

type _Commit__Prototype struct{}

func (_Commit__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Commit__Builder
	nb.Reset()
	return &nb
}

type _Commit__Builder struct {
	_Commit__Assembler
}

func (nb *_Commit__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Commit__Builder) Reset() {
	var w _Commit
	var m schema.Maybe
	*nb = _Commit__Builder{_Commit__Assembler{w: &w, m: &m}}
}

type _Commit__Assembler struct {
	w     *_Commit
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Height     _Int__Assembler
	ca_Round      _Int__Assembler
	ca_BlockID    _BlockID__Assembler
	ca_Signatures _Signatures__Assembler
}

func (na *_Commit__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_BlockID.reset()
	na.ca_Signatures.reset()
}

var (
	fieldBit__Commit_Height      = 1 << 0
	fieldBit__Commit_Round       = 1 << 1
	fieldBit__Commit_BlockID     = 1 << 2
	fieldBit__Commit_Signatures  = 1 << 3
	fieldBits__Commit_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_Commit__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Commit{}
	}
	return na, nil
}
func (_Commit__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Commit"}.BeginList(0)
}
func (na *_Commit__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Commit"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Commit__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignBool(false)
}
func (_Commit__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignInt(0)
}
func (_Commit__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignFloat(0)
}
func (_Commit__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignString("")
}
func (_Commit__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignBytes(nil)
}
func (_Commit__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignLink(nil)
}
func (na *_Commit__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Commit); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Commit", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Commit__Assembler) Prototype() ipld.NodePrototype {
	return _Commit__Prototype{}
}
func (ma *_Commit__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Height.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Round.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Signatures.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Commit__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Height":
		if ma.s&fieldBit__Commit_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Height}
		}
		ma.s += fieldBit__Commit_Height
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Commit_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Round}
		}
		ma.s += fieldBit__Commit_Round
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "BlockID":
		if ma.s&fieldBit__Commit_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_BlockID}
		}
		ma.s += fieldBit__Commit_BlockID
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Signatures":
		if ma.s&fieldBit__Commit_Signatures != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Signatures}
		}
		ma.s += fieldBit__Commit_Signatures
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Signatures.w = &ma.w.Signatures
		ma.ca_Signatures.m = &ma.cm
		return &ma.ca_Signatures, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Commit", Key: &_String{k}}
}
func (ma *_Commit__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Commit__KeyAssembler)(ma)
}
func (ma *_Commit__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 1:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 2:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 3:
		ma.ca_Signatures.w = &ma.w.Signatures
		ma.ca_Signatures.m = &ma.cm
		return &ma.ca_Signatures
	default:
		panic("unreachable")
	}
}
func (ma *_Commit__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Commit_sufficient != fieldBits__Commit_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Commit_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Commit_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Commit_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Commit_Signatures == 0 {
			err.Missing = append(err.Missing, "Signatures")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Commit__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Commit__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Commit__KeyAssembler _Commit__Assembler

func (_Commit__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.BeginMap(0)
}
func (_Commit__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.BeginList(0)
}
func (na *_Commit__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignNull()
}
func (_Commit__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignBool(false)
}
func (_Commit__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignInt(0)
}
func (_Commit__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Commit__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Height":
		if ka.s&fieldBit__Commit_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Height}
		}
		ka.s += fieldBit__Commit_Height
		ka.state = maState_expectValue
		ka.f = 0
	case "Round":
		if ka.s&fieldBit__Commit_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Round}
		}
		ka.s += fieldBit__Commit_Round
		ka.state = maState_expectValue
		ka.f = 1
	case "BlockID":
		if ka.s&fieldBit__Commit_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_BlockID}
		}
		ka.s += fieldBit__Commit_BlockID
		ka.state = maState_expectValue
		ka.f = 2
	case "Signatures":
		if ka.s&fieldBit__Commit_Signatures != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Signatures}
		}
		ka.s += fieldBit__Commit_Signatures
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Commit", Key: &_String{k}}
	}
	return nil
}
func (_Commit__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignBytes(nil)
}
func (_Commit__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Commit__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Commit__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Commit) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Commit) Representation() ipld.Node {
	return (*_Commit__Repr)(n)
}

type _Commit__Repr _Commit

var (
	fieldName__Commit_Height_serial     = _String{"Height"}
	fieldName__Commit_Round_serial      = _String{"Round"}
	fieldName__Commit_BlockID_serial    = _String{"BlockID"}
	fieldName__Commit_Signatures_serial = _String{"Signatures"}
)
var _ ipld.Node = &_Commit__Repr{}

func (_Commit__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Commit__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Height":
		return n.Height.Representation(), nil
	case "Round":
		return n.Round.Representation(), nil
	case "BlockID":
		return n.BlockID.Representation(), nil
	case "Signatures":
		return n.Signatures.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Commit__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Commit__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.LookupByIndex(0)
}
func (n _Commit__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Commit__Repr) MapIterator() ipld.MapIterator {
	return &_Commit__ReprMapItr{n, 0}
}

type _Commit__ReprMapItr struct {
	n   *_Commit__Repr
	idx int
}

func (itr *_Commit__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Commit_Height_serial
		v = itr.n.Height.Representation()
	case 1:
		k = &fieldName__Commit_Round_serial
		v = itr.n.Round.Representation()
	case 2:
		k = &fieldName__Commit_BlockID_serial
		v = itr.n.BlockID.Representation()
	case 3:
		k = &fieldName__Commit_Signatures_serial
		v = itr.n.Signatures.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Commit__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_Commit__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Commit__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_Commit__Repr) IsAbsent() bool {
	return false
}
func (_Commit__Repr) IsNull() bool {
	return false
}
func (_Commit__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsBool()
}
func (_Commit__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsInt()
}
func (_Commit__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsFloat()
}
func (_Commit__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsString()
}
func (_Commit__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsBytes()
}
func (_Commit__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsLink()
}
func (_Commit__Repr) Prototype() ipld.NodePrototype {
	return _Commit__ReprPrototype{}
}

type _Commit__ReprPrototype struct{}

func (_Commit__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Commit__ReprBuilder
	nb.Reset()
	return &nb
}

type _Commit__ReprBuilder struct {
	_Commit__ReprAssembler
}

func (nb *_Commit__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Commit__ReprBuilder) Reset() {
	var w _Commit
	var m schema.Maybe
	*nb = _Commit__ReprBuilder{_Commit__ReprAssembler{w: &w, m: &m}}
}

type _Commit__ReprAssembler struct {
	w     *_Commit
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Height     _Int__ReprAssembler
	ca_Round      _Int__ReprAssembler
	ca_BlockID    _BlockID__ReprAssembler
	ca_Signatures _Signatures__ReprAssembler
}

func (na *_Commit__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_BlockID.reset()
	na.ca_Signatures.reset()
}
func (na *_Commit__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Commit{}
	}
	return na, nil
}
func (_Commit__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.BeginList(0)
}
func (na *_Commit__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Commit.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Commit__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignBool(false)
}
func (_Commit__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignInt(0)
}
func (_Commit__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignFloat(0)
}
func (_Commit__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignString("")
}
func (_Commit__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignBytes(nil)
}
func (_Commit__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignLink(nil)
}
func (na *_Commit__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Commit); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Commit.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Commit__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Commit__ReprPrototype{}
}
func (ma *_Commit__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Commit__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Height":
		if ma.s&fieldBit__Commit_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Height_serial}
		}
		ma.s += fieldBit__Commit_Height
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Commit_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Round_serial}
		}
		ma.s += fieldBit__Commit_Round
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "BlockID":
		if ma.s&fieldBit__Commit_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_BlockID_serial}
		}
		ma.s += fieldBit__Commit_BlockID
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Signatures":
		if ma.s&fieldBit__Commit_Signatures != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Signatures_serial}
		}
		ma.s += fieldBit__Commit_Signatures
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Signatures.w = &ma.w.Signatures
		ma.ca_Signatures.m = &ma.cm
		return &ma.ca_Signatures, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Commit.Repr", Key: &_String{k}}
}
func (ma *_Commit__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Commit__ReprKeyAssembler)(ma)
}
func (ma *_Commit__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 1:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 2:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 3:
		ma.ca_Signatures.w = &ma.w.Signatures
		ma.ca_Signatures.m = &ma.cm
		return &ma.ca_Signatures
	default:
		panic("unreachable")
	}
}
func (ma *_Commit__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Commit_sufficient != fieldBits__Commit_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Commit_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Commit_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Commit_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Commit_Signatures == 0 {
			err.Missing = append(err.Missing, "Signatures")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Commit__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Commit__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Commit__ReprKeyAssembler _Commit__ReprAssembler

func (_Commit__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Commit__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Commit__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignNull()
}
func (_Commit__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Commit__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Commit__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Commit__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Height":
		if ka.s&fieldBit__Commit_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Height_serial}
		}
		ka.s += fieldBit__Commit_Height
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Round":
		if ka.s&fieldBit__Commit_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Round_serial}
		}
		ka.s += fieldBit__Commit_Round
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "BlockID":
		if ka.s&fieldBit__Commit_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_BlockID_serial}
		}
		ka.s += fieldBit__Commit_BlockID
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Signatures":
		if ka.s&fieldBit__Commit_Signatures != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Signatures_serial}
		}
		ka.s += fieldBit__Commit_Signatures
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Commit.Repr", Key: &_String{k}}
}
func (_Commit__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Commit__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Commit__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Commit__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _CommitSig) FieldBlockIDFlag() BlockIDFlag {
	return &n.BlockIDFlag
}
func (n _CommitSig) FieldValidatorAddress() Address {
	return &n.ValidatorAddress
}
func (n _CommitSig) FieldTimestamp() Time {
	return &n.Timestamp
}
func (n _CommitSig) FieldSignature() Signature {
	return &n.Signature
}

type _CommitSig__Maybe struct {
	m schema.Maybe
	v CommitSig
}
type MaybeCommitSig = *_CommitSig__Maybe

func (m MaybeCommitSig) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeCommitSig) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeCommitSig) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeCommitSig) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeCommitSig) Must() CommitSig {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__CommitSig_BlockIDFlag      = _String{"BlockIDFlag"}
	fieldName__CommitSig_ValidatorAddress = _String{"ValidatorAddress"}
	fieldName__CommitSig_Timestamp        = _String{"Timestamp"}
	fieldName__CommitSig_Signature        = _String{"Signature"}
)
var _ ipld.Node = (CommitSig)(&_CommitSig{})
var _ schema.TypedNode = (CommitSig)(&_CommitSig{})

func (CommitSig) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n CommitSig) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "BlockIDFlag":
		return &n.BlockIDFlag, nil
	case "ValidatorAddress":
		return &n.ValidatorAddress, nil
	case "Timestamp":
		return &n.Timestamp, nil
	case "Signature":
		return &n.Signature, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n CommitSig) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (CommitSig) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.LookupByIndex(0)
}
func (n CommitSig) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n CommitSig) MapIterator() ipld.MapIterator {
	return &_CommitSig__MapItr{n, 0}
}

type _CommitSig__MapItr struct {
	n   CommitSig
	idx int
}

func (itr *_CommitSig__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__CommitSig_BlockIDFlag
		v = &itr.n.BlockIDFlag
	case 1:
		k = &fieldName__CommitSig_ValidatorAddress
		v = &itr.n.ValidatorAddress
	case 2:
		k = &fieldName__CommitSig_Timestamp
		v = &itr.n.Timestamp
	case 3:
		k = &fieldName__CommitSig_Signature
		v = &itr.n.Signature
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_CommitSig__MapItr) Done() bool {
	return itr.idx >= 4
}

func (CommitSig) ListIterator() ipld.ListIterator {
	return nil
}
func (CommitSig) Length() int64 {
	return 4
}
func (CommitSig) IsAbsent() bool {
	return false
}
func (CommitSig) IsNull() bool {
	return false
}
func (CommitSig) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsBool()
}
func (CommitSig) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsInt()
}
func (CommitSig) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsFloat()
}
func (CommitSig) AsString() (string, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsString()
}
func (CommitSig) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsBytes()
}
func (CommitSig) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsLink()
}
func (CommitSig) Prototype() ipld.NodePrototype {
	return _CommitSig__Prototype{}
}

type _CommitSig__Prototype struct{}

func (_CommitSig__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _CommitSig__Builder
	nb.Reset()
	return &nb
}

type _CommitSig__Builder struct {
	_CommitSig__Assembler
}

func (nb *_CommitSig__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_CommitSig__Builder) Reset() {
	var w _CommitSig
	var m schema.Maybe
	*nb = _CommitSig__Builder{_CommitSig__Assembler{w: &w, m: &m}}
}

type _CommitSig__Assembler struct {
	w     *_CommitSig
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_BlockIDFlag      _BlockIDFlag__Assembler
	ca_ValidatorAddress _Address__Assembler
	ca_Timestamp        _Time__Assembler
	ca_Signature        _Signature__Assembler
}

func (na *_CommitSig__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_BlockIDFlag.reset()
	na.ca_ValidatorAddress.reset()
	na.ca_Timestamp.reset()
	na.ca_Signature.reset()
}

var (
	fieldBit__CommitSig_BlockIDFlag      = 1 << 0
	fieldBit__CommitSig_ValidatorAddress = 1 << 1
	fieldBit__CommitSig_Timestamp        = 1 << 2
	fieldBit__CommitSig_Signature        = 1 << 3
	fieldBits__CommitSig_sufficient      = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_CommitSig__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_CommitSig{}
	}
	return na, nil
}
func (_CommitSig__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.BeginList(0)
}
func (na *_CommitSig__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_CommitSig__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignBool(false)
}
func (_CommitSig__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignInt(0)
}
func (_CommitSig__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignFloat(0)
}
func (_CommitSig__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignString("")
}
func (_CommitSig__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignBytes(nil)
}
func (_CommitSig__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignLink(nil)
}
func (na *_CommitSig__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_CommitSig); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.CommitSig", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_CommitSig__Assembler) Prototype() ipld.NodePrototype {
	return _CommitSig__Prototype{}
}
func (ma *_CommitSig__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockIDFlag.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorAddress.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Timestamp.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Signature.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_CommitSig__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "BlockIDFlag":
		if ma.s&fieldBit__CommitSig_BlockIDFlag != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_BlockIDFlag}
		}
		ma.s += fieldBit__CommitSig_BlockIDFlag
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_BlockIDFlag.w = &ma.w.BlockIDFlag
		ma.ca_BlockIDFlag.m = &ma.cm
		return &ma.ca_BlockIDFlag, nil
	case "ValidatorAddress":
		if ma.s&fieldBit__CommitSig_ValidatorAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_ValidatorAddress}
		}
		ma.s += fieldBit__CommitSig_ValidatorAddress
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress, nil
	case "Timestamp":
		if ma.s&fieldBit__CommitSig_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Timestamp}
		}
		ma.s += fieldBit__CommitSig_Timestamp
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "Signature":
		if ma.s&fieldBit__CommitSig_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Signature}
		}
		ma.s += fieldBit__CommitSig_Signature
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.CommitSig", Key: &_String{k}}
}
func (ma *_CommitSig__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_CommitSig__KeyAssembler)(ma)
}
func (ma *_CommitSig__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_BlockIDFlag.w = &ma.w.BlockIDFlag
		ma.ca_BlockIDFlag.m = &ma.cm
		return &ma.ca_BlockIDFlag
	case 1:
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress
	case 2:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 3:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_CommitSig__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__CommitSig_sufficient != fieldBits__CommitSig_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__CommitSig_BlockIDFlag == 0 {
			err.Missing = append(err.Missing, "BlockIDFlag")
		}
		if ma.s&fieldBit__CommitSig_ValidatorAddress == 0 {
			err.Missing = append(err.Missing, "ValidatorAddress")
		}
		if ma.s&fieldBit__CommitSig_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__CommitSig_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_CommitSig__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_CommitSig__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _CommitSig__KeyAssembler _CommitSig__Assembler

func (_CommitSig__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.BeginMap(0)
}
func (_CommitSig__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.BeginList(0)
}
func (na *_CommitSig__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignNull()
}
func (_CommitSig__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignBool(false)
}
func (_CommitSig__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignInt(0)
}
func (_CommitSig__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignFloat(0)
}
func (ka *_CommitSig__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "BlockIDFlag":
		if ka.s&fieldBit__CommitSig_BlockIDFlag != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_BlockIDFlag}
		}
		ka.s += fieldBit__CommitSig_BlockIDFlag
		ka.state = maState_expectValue
		ka.f = 0
	case "ValidatorAddress":
		if ka.s&fieldBit__CommitSig_ValidatorAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_ValidatorAddress}
		}
		ka.s += fieldBit__CommitSig_ValidatorAddress
		ka.state = maState_expectValue
		ka.f = 1
	case "Timestamp":
		if ka.s&fieldBit__CommitSig_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Timestamp}
		}
		ka.s += fieldBit__CommitSig_Timestamp
		ka.state = maState_expectValue
		ka.f = 2
	case "Signature":
		if ka.s&fieldBit__CommitSig_Signature != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Signature}
		}
		ka.s += fieldBit__CommitSig_Signature
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.CommitSig", Key: &_String{k}}
	}
	return nil
}
func (_CommitSig__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignBytes(nil)
}
func (_CommitSig__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignLink(nil)
}
func (ka *_CommitSig__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_CommitSig__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (CommitSig) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n CommitSig) Representation() ipld.Node {
	return (*_CommitSig__Repr)(n)
}

type _CommitSig__Repr _CommitSig

var (
	fieldName__CommitSig_BlockIDFlag_serial      = _String{"BlockIDFlag"}
	fieldName__CommitSig_ValidatorAddress_serial = _String{"ValidatorAddress"}
	fieldName__CommitSig_Timestamp_serial        = _String{"Timestamp"}
	fieldName__CommitSig_Signature_serial        = _String{"Signature"}
)
var _ ipld.Node = &_CommitSig__Repr{}

func (_CommitSig__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_CommitSig__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "BlockIDFlag":
		return n.BlockIDFlag.Representation(), nil
	case "ValidatorAddress":
		return n.ValidatorAddress.Representation(), nil
	case "Timestamp":
		return n.Timestamp.Representation(), nil
	case "Signature":
		return n.Signature.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_CommitSig__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_CommitSig__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.LookupByIndex(0)
}
func (n _CommitSig__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_CommitSig__Repr) MapIterator() ipld.MapIterator {
	return &_CommitSig__ReprMapItr{n, 0}
}

type _CommitSig__ReprMapItr struct {
	n   *_CommitSig__Repr
	idx int
}

func (itr *_CommitSig__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__CommitSig_BlockIDFlag_serial
		v = itr.n.BlockIDFlag.Representation()
	case 1:
		k = &fieldName__CommitSig_ValidatorAddress_serial
		v = itr.n.ValidatorAddress.Representation()
	case 2:
		k = &fieldName__CommitSig_Timestamp_serial
		v = itr.n.Timestamp.Representation()
	case 3:
		k = &fieldName__CommitSig_Signature_serial
		v = itr.n.Signature.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_CommitSig__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_CommitSig__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_CommitSig__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_CommitSig__Repr) IsAbsent() bool {
	return false
}
func (_CommitSig__Repr) IsNull() bool {
	return false
}
func (_CommitSig__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsBool()
}
func (_CommitSig__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsInt()
}
func (_CommitSig__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsFloat()
}
func (_CommitSig__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsString()
}
func (_CommitSig__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsBytes()
}
func (_CommitSig__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsLink()
}
func (_CommitSig__Repr) Prototype() ipld.NodePrototype {
	return _CommitSig__ReprPrototype{}
}

type _CommitSig__ReprPrototype struct{}

func (_CommitSig__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _CommitSig__ReprBuilder
	nb.Reset()
	return &nb
}

type _CommitSig__ReprBuilder struct {
	_CommitSig__ReprAssembler
}

func (nb *_CommitSig__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_CommitSig__ReprBuilder) Reset() {
	var w _CommitSig
	var m schema.Maybe
	*nb = _CommitSig__ReprBuilder{_CommitSig__ReprAssembler{w: &w, m: &m}}
}

type _CommitSig__ReprAssembler struct {
	w     *_CommitSig
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_BlockIDFlag      _BlockIDFlag__ReprAssembler
	ca_ValidatorAddress _Address__ReprAssembler
	ca_Timestamp        _Time__ReprAssembler
	ca_Signature        _Signature__ReprAssembler
}

func (na *_CommitSig__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_BlockIDFlag.reset()
	na.ca_ValidatorAddress.reset()
	na.ca_Timestamp.reset()
	na.ca_Signature.reset()
}
func (na *_CommitSig__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_CommitSig{}
	}
	return na, nil
}
func (_CommitSig__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.BeginList(0)
}
func (na *_CommitSig__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.CommitSig.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_CommitSig__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignBool(false)
}
func (_CommitSig__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignInt(0)
}
func (_CommitSig__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignFloat(0)
}
func (_CommitSig__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignString("")
}
func (_CommitSig__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignBytes(nil)
}
func (_CommitSig__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignLink(nil)
}
func (na *_CommitSig__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_CommitSig); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.CommitSig.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_CommitSig__ReprAssembler) Prototype() ipld.NodePrototype {
	return _CommitSig__ReprPrototype{}
}
func (ma *_CommitSig__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_CommitSig__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "BlockIDFlag":
		if ma.s&fieldBit__CommitSig_BlockIDFlag != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_BlockIDFlag_serial}
		}
		ma.s += fieldBit__CommitSig_BlockIDFlag
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_BlockIDFlag.w = &ma.w.BlockIDFlag
		ma.ca_BlockIDFlag.m = &ma.cm
		return &ma.ca_BlockIDFlag, nil
	case "ValidatorAddress":
		if ma.s&fieldBit__CommitSig_ValidatorAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_ValidatorAddress_serial}
		}
		ma.s += fieldBit__CommitSig_ValidatorAddress
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress, nil
	case "Timestamp":
		if ma.s&fieldBit__CommitSig_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Timestamp_serial}
		}
		ma.s += fieldBit__CommitSig_Timestamp
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "Signature":
		if ma.s&fieldBit__CommitSig_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Signature_serial}
		}
		ma.s += fieldBit__CommitSig_Signature
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.CommitSig.Repr", Key: &_String{k}}
}
func (ma *_CommitSig__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_CommitSig__ReprKeyAssembler)(ma)
}
func (ma *_CommitSig__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_BlockIDFlag.w = &ma.w.BlockIDFlag
		ma.ca_BlockIDFlag.m = &ma.cm
		return &ma.ca_BlockIDFlag
	case 1:
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress
	case 2:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 3:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_CommitSig__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__CommitSig_sufficient != fieldBits__CommitSig_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__CommitSig_BlockIDFlag == 0 {
			err.Missing = append(err.Missing, "BlockIDFlag")
		}
		if ma.s&fieldBit__CommitSig_ValidatorAddress == 0 {
			err.Missing = append(err.Missing, "ValidatorAddress")
		}
		if ma.s&fieldBit__CommitSig_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__CommitSig_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_CommitSig__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_CommitSig__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _CommitSig__ReprKeyAssembler _CommitSig__ReprAssembler

func (_CommitSig__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.BeginMap(0)
}
func (_CommitSig__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_CommitSig__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignNull()
}
func (_CommitSig__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignBool(false)
}
func (_CommitSig__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignInt(0)
}
func (_CommitSig__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_CommitSig__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "BlockIDFlag":
		if ka.s&fieldBit__CommitSig_BlockIDFlag != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_BlockIDFlag_serial}
		}
		ka.s += fieldBit__CommitSig_BlockIDFlag
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "ValidatorAddress":
		if ka.s&fieldBit__CommitSig_ValidatorAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_ValidatorAddress_serial}
		}
		ka.s += fieldBit__CommitSig_ValidatorAddress
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Timestamp":
		if ka.s&fieldBit__CommitSig_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Timestamp_serial}
		}
		ka.s += fieldBit__CommitSig_Timestamp
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Signature":
		if ka.s&fieldBit__CommitSig_Signature != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Signature_serial}
		}
		ka.s += fieldBit__CommitSig_Signature
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.CommitSig.Repr", Key: &_String{k}}
}
func (_CommitSig__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_CommitSig__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_CommitSig__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_CommitSig__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _Data) FieldTxs() Txs {
	return &n.Txs
}

type _Data__Maybe struct {
	m schema.Maybe
	v Data
}
type MaybeData = *_Data__Maybe

func (m MaybeData) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeData) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeData) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeData) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeData) Must() Data {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Data_Txs = _String{"Txs"}
)
var _ ipld.Node = (Data)(&_Data{})
var _ schema.TypedNode = (Data)(&_Data{})

func (Data) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Data) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Txs":
		return &n.Txs, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Data) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Data) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Data"}.LookupByIndex(0)
}
func (n Data) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Data) MapIterator() ipld.MapIterator {
	return &_Data__MapItr{n, 0}
}

type _Data__MapItr struct {
	n   Data
	idx int
}

func (itr *_Data__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Data_Txs
		v = &itr.n.Txs
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Data__MapItr) Done() bool {
	return itr.idx >= 1
}

func (Data) ListIterator() ipld.ListIterator {
	return nil
}
func (Data) Length() int64 {
	return 1
}
func (Data) IsAbsent() bool {
	return false
}
func (Data) IsNull() bool {
	return false
}
func (Data) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Data"}.AsBool()
}
func (Data) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Data"}.AsInt()
}
func (Data) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Data"}.AsFloat()
}
func (Data) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Data"}.AsString()
}
func (Data) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Data"}.AsBytes()
}
func (Data) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Data"}.AsLink()
}
func (Data) Prototype() ipld.NodePrototype {
	return _Data__Prototype{}
}

type _Data__Prototype struct{}

func (_Data__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Data__Builder
	nb.Reset()
	return &nb
}

type _Data__Builder struct {
	_Data__Assembler
}

func (nb *_Data__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Data__Builder) Reset() {
	var w _Data
	var m schema.Maybe
	*nb = _Data__Builder{_Data__Assembler{w: &w, m: &m}}
}

type _Data__Assembler struct {
	w     *_Data
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm     schema.Maybe
	ca_Txs _Txs__Assembler
}

func (na *_Data__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Txs.reset()
}

var (
	fieldBit__Data_Txs         = 1 << 0
	fieldBits__Data_sufficient = 0 + 1<<0
)

func (na *_Data__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Data{}
	}
	return na, nil
}
func (_Data__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Data"}.BeginList(0)
}
func (na *_Data__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Data"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Data__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignBool(false)
}
func (_Data__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignInt(0)
}
func (_Data__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignFloat(0)
}
func (_Data__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignString("")
}
func (_Data__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignBytes(nil)
}
func (_Data__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignLink(nil)
}
func (na *_Data__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Data); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Data", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Data__Assembler) Prototype() ipld.NodePrototype {
	return _Data__Prototype{}
}
func (ma *_Data__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Txs.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Data__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Txs":
		if ma.s&fieldBit__Data_Txs != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Data_Txs}
		}
		ma.s += fieldBit__Data_Txs
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Txs.w = &ma.w.Txs
		ma.ca_Txs.m = &ma.cm
		return &ma.ca_Txs, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Data", Key: &_String{k}}
}
func (ma *_Data__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Data__KeyAssembler)(ma)
}
func (ma *_Data__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Txs.w = &ma.w.Txs
		ma.ca_Txs.m = &ma.cm
		return &ma.ca_Txs
	default:
		panic("unreachable")
	}
}
func (ma *_Data__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Data_sufficient != fieldBits__Data_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Data_Txs == 0 {
			err.Missing = append(err.Missing, "Txs")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Data__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Data__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Data__KeyAssembler _Data__Assembler

func (_Data__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.BeginMap(0)
}
func (_Data__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.BeginList(0)
}
func (na *_Data__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignNull()
}
func (_Data__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignBool(false)
}
func (_Data__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignInt(0)
}
func (_Data__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Data__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Txs":
		if ka.s&fieldBit__Data_Txs != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Data_Txs}
		}
		ka.s += fieldBit__Data_Txs
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Data", Key: &_String{k}}
	}
	return nil
}
func (_Data__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignBytes(nil)
}
func (_Data__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Data__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Data__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Data) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Data) Representation() ipld.Node {
	return (*_Data__Repr)(n)
}

type _Data__Repr _Data

var (
	fieldName__Data_Txs_serial = _String{"Txs"}
)
var _ ipld.Node = &_Data__Repr{}

func (_Data__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Data__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Txs":
		return n.Txs.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Data__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Data__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.LookupByIndex(0)
}
func (n _Data__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Data__Repr) MapIterator() ipld.MapIterator {
	return &_Data__ReprMapItr{n, 0}
}

type _Data__ReprMapItr struct {
	n   *_Data__Repr
	idx int
}

func (itr *_Data__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Data_Txs_serial
		v = itr.n.Txs.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Data__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_Data__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Data__Repr) Length() int64 {
	l := 1
	return int64(l)
}
func (_Data__Repr) IsAbsent() bool {
	return false
}
func (_Data__Repr) IsNull() bool {
	return false
}
func (_Data__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsBool()
}
func (_Data__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsInt()
}
func (_Data__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsFloat()
}
func (_Data__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsString()
}
func (_Data__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsBytes()
}
func (_Data__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsLink()
}
func (_Data__Repr) Prototype() ipld.NodePrototype {
	return _Data__ReprPrototype{}
}

type _Data__ReprPrototype struct{}

func (_Data__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Data__ReprBuilder
	nb.Reset()
	return &nb
}

type _Data__ReprBuilder struct {
	_Data__ReprAssembler
}

func (nb *_Data__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Data__ReprBuilder) Reset() {
	var w _Data
	var m schema.Maybe
	*nb = _Data__ReprBuilder{_Data__ReprAssembler{w: &w, m: &m}}
}

type _Data__ReprAssembler struct {
	w     *_Data
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm     schema.Maybe
	ca_Txs _Txs__ReprAssembler
}

func (na *_Data__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Txs.reset()
}
func (na *_Data__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Data{}
	}
	return na, nil
}
func (_Data__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.BeginList(0)
}
func (na *_Data__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Data.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Data__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignBool(false)
}
func (_Data__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignInt(0)
}
func (_Data__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignFloat(0)
}
func (_Data__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignString("")
}
func (_Data__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignBytes(nil)
}
func (_Data__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignLink(nil)
}
func (na *_Data__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Data); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Data.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Data__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Data__ReprPrototype{}
}
func (ma *_Data__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Data__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Txs":
		if ma.s&fieldBit__Data_Txs != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Data_Txs_serial}
		}
		ma.s += fieldBit__Data_Txs
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Txs.w = &ma.w.Txs
		ma.ca_Txs.m = &ma.cm
		return &ma.ca_Txs, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Data.Repr", Key: &_String{k}}
}
func (ma *_Data__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Data__ReprKeyAssembler)(ma)
}
func (ma *_Data__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Txs.w = &ma.w.Txs
		ma.ca_Txs.m = &ma.cm
		return &ma.ca_Txs
	default:
		panic("unreachable")
	}
}
func (ma *_Data__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Data_sufficient != fieldBits__Data_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Data_Txs == 0 {
			err.Missing = append(err.Missing, "Txs")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Data__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Data__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Data__ReprKeyAssembler _Data__ReprAssembler

func (_Data__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Data__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Data__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignNull()
}
func (_Data__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Data__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Data__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Data__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Txs":
		if ka.s&fieldBit__Data_Txs != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Data_Txs_serial}
		}
		ka.s += fieldBit__Data_Txs
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Data.Repr", Key: &_String{k}}
}
func (_Data__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Data__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Data__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Data__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _DuplicateVoteEvidence) FieldVoteA() Vote {
	return &n.VoteA
}
func (n _DuplicateVoteEvidence) FieldVoteB() Vote {
	return &n.VoteB
}
func (n _DuplicateVoteEvidence) FieldTotalVotingPower() Int {
	return &n.TotalVotingPower
}
func (n _DuplicateVoteEvidence) FieldValidatorPower() Int {
	return &n.ValidatorPower
}
func (n _DuplicateVoteEvidence) FieldTimestamp() Time {
	return &n.Timestamp
}

type _DuplicateVoteEvidence__Maybe struct {
	m schema.Maybe
	v DuplicateVoteEvidence
}
type MaybeDuplicateVoteEvidence = *_DuplicateVoteEvidence__Maybe

func (m MaybeDuplicateVoteEvidence) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeDuplicateVoteEvidence) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeDuplicateVoteEvidence) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeDuplicateVoteEvidence) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeDuplicateVoteEvidence) Must() DuplicateVoteEvidence {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__DuplicateVoteEvidence_VoteA            = _String{"VoteA"}
	fieldName__DuplicateVoteEvidence_VoteB            = _String{"VoteB"}
	fieldName__DuplicateVoteEvidence_TotalVotingPower = _String{"TotalVotingPower"}
	fieldName__DuplicateVoteEvidence_ValidatorPower   = _String{"ValidatorPower"}
	fieldName__DuplicateVoteEvidence_Timestamp        = _String{"Timestamp"}
)
var _ ipld.Node = (DuplicateVoteEvidence)(&_DuplicateVoteEvidence{})
var _ schema.TypedNode = (DuplicateVoteEvidence)(&_DuplicateVoteEvidence{})

func (DuplicateVoteEvidence) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n DuplicateVoteEvidence) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "VoteA":
		return &n.VoteA, nil
	case "VoteB":
		return &n.VoteB, nil
	case "TotalVotingPower":
		return &n.TotalVotingPower, nil
	case "ValidatorPower":
		return &n.ValidatorPower, nil
	case "Timestamp":
		return &n.Timestamp, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n DuplicateVoteEvidence) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (DuplicateVoteEvidence) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.LookupByIndex(0)
}
func (n DuplicateVoteEvidence) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n DuplicateVoteEvidence) MapIterator() ipld.MapIterator {
	return &_DuplicateVoteEvidence__MapItr{n, 0}
}

type _DuplicateVoteEvidence__MapItr struct {
	n   DuplicateVoteEvidence
	idx int
}

func (itr *_DuplicateVoteEvidence__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__DuplicateVoteEvidence_VoteA
		v = &itr.n.VoteA
	case 1:
		k = &fieldName__DuplicateVoteEvidence_VoteB
		v = &itr.n.VoteB
	case 2:
		k = &fieldName__DuplicateVoteEvidence_TotalVotingPower
		v = &itr.n.TotalVotingPower
	case 3:
		k = &fieldName__DuplicateVoteEvidence_ValidatorPower
		v = &itr.n.ValidatorPower
	case 4:
		k = &fieldName__DuplicateVoteEvidence_Timestamp
		v = &itr.n.Timestamp
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_DuplicateVoteEvidence__MapItr) Done() bool {
	return itr.idx >= 5
}

func (DuplicateVoteEvidence) ListIterator() ipld.ListIterator {
	return nil
}
func (DuplicateVoteEvidence) Length() int64 {
	return 5
}
func (DuplicateVoteEvidence) IsAbsent() bool {
	return false
}
func (DuplicateVoteEvidence) IsNull() bool {
	return false
}
func (DuplicateVoteEvidence) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsBool()
}
func (DuplicateVoteEvidence) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsInt()
}
func (DuplicateVoteEvidence) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsFloat()
}
func (DuplicateVoteEvidence) AsString() (string, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsString()
}
func (DuplicateVoteEvidence) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsBytes()
}
func (DuplicateVoteEvidence) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsLink()
}
func (DuplicateVoteEvidence) Prototype() ipld.NodePrototype {
	return _DuplicateVoteEvidence__Prototype{}
}

type _DuplicateVoteEvidence__Prototype struct{}

func (_DuplicateVoteEvidence__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _DuplicateVoteEvidence__Builder
	nb.Reset()
	return &nb
}

type _DuplicateVoteEvidence__Builder struct {
	_DuplicateVoteEvidence__Assembler
}

func (nb *_DuplicateVoteEvidence__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_DuplicateVoteEvidence__Builder) Reset() {
	var w _DuplicateVoteEvidence
	var m schema.Maybe
	*nb = _DuplicateVoteEvidence__Builder{_DuplicateVoteEvidence__Assembler{w: &w, m: &m}}
}

type _DuplicateVoteEvidence__Assembler struct {
	w     *_DuplicateVoteEvidence
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_VoteA            _Vote__Assembler
	ca_VoteB            _Vote__Assembler
	ca_TotalVotingPower _Int__Assembler
	ca_ValidatorPower   _Int__Assembler
	ca_Timestamp        _Time__Assembler
}

func (na *_DuplicateVoteEvidence__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_VoteA.reset()
	na.ca_VoteB.reset()
	na.ca_TotalVotingPower.reset()
	na.ca_ValidatorPower.reset()
	na.ca_Timestamp.reset()
}

var (
	fieldBit__DuplicateVoteEvidence_VoteA            = 1 << 0
	fieldBit__DuplicateVoteEvidence_VoteB            = 1 << 1
	fieldBit__DuplicateVoteEvidence_TotalVotingPower = 1 << 2
	fieldBit__DuplicateVoteEvidence_ValidatorPower   = 1 << 3
	fieldBit__DuplicateVoteEvidence_Timestamp        = 1 << 4
	fieldBits__DuplicateVoteEvidence_sufficient      = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4
)

func (na *_DuplicateVoteEvidence__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_DuplicateVoteEvidence{}
	}
	return na, nil
}
func (_DuplicateVoteEvidence__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.BeginList(0)
}
func (na *_DuplicateVoteEvidence__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_DuplicateVoteEvidence__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignBool(false)
}
func (_DuplicateVoteEvidence__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignInt(0)
}
func (_DuplicateVoteEvidence__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignFloat(0)
}
func (_DuplicateVoteEvidence__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignString("")
}
func (_DuplicateVoteEvidence__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignBytes(nil)
}
func (_DuplicateVoteEvidence__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignLink(nil)
}
func (na *_DuplicateVoteEvidence__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_DuplicateVoteEvidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.DuplicateVoteEvidence", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_DuplicateVoteEvidence__Assembler) Prototype() ipld.NodePrototype {
	return _DuplicateVoteEvidence__Prototype{}
}
func (ma *_DuplicateVoteEvidence__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_VoteA.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_VoteB.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_TotalVotingPower.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorPower.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Timestamp.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_DuplicateVoteEvidence__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "VoteA":
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteA != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteA}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_VoteA
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_VoteA.w = &ma.w.VoteA
		ma.ca_VoteA.m = &ma.cm
		return &ma.ca_VoteA, nil
	case "VoteB":
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteB != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteB}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_VoteB
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_VoteB.w = &ma.w.VoteB
		ma.ca_VoteB.m = &ma.cm
		return &ma.ca_VoteB, nil
	case "TotalVotingPower":
		if ma.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_TotalVotingPower}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_TotalVotingPower
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower, nil
	case "ValidatorPower":
		if ma.s&fieldBit__DuplicateVoteEvidence_ValidatorPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_ValidatorPower}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_ValidatorPower
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_ValidatorPower.w = &ma.w.ValidatorPower
		ma.ca_ValidatorPower.m = &ma.cm
		return &ma.ca_ValidatorPower, nil
	case "Timestamp":
		if ma.s&fieldBit__DuplicateVoteEvidence_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_Timestamp}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.DuplicateVoteEvidence", Key: &_String{k}}
}
func (ma *_DuplicateVoteEvidence__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_DuplicateVoteEvidence__KeyAssembler)(ma)
}
func (ma *_DuplicateVoteEvidence__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_VoteA.w = &ma.w.VoteA
		ma.ca_VoteA.m = &ma.cm
		return &ma.ca_VoteA
	case 1:
		ma.ca_VoteB.w = &ma.w.VoteB
		ma.ca_VoteB.m = &ma.cm
		return &ma.ca_VoteB
	case 2:
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower
	case 3:
		ma.ca_ValidatorPower.w = &ma.w.ValidatorPower
		ma.ca_ValidatorPower.m = &ma.cm
		return &ma.ca_ValidatorPower
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	default:
		panic("unreachable")
	}
}
func (ma *_DuplicateVoteEvidence__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__DuplicateVoteEvidence_sufficient != fieldBits__DuplicateVoteEvidence_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteA == 0 {
			err.Missing = append(err.Missing, "VoteA")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteB == 0 {
			err.Missing = append(err.Missing, "VoteB")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower == 0 {
			err.Missing = append(err.Missing, "TotalVotingPower")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_ValidatorPower == 0 {
			err.Missing = append(err.Missing, "ValidatorPower")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_DuplicateVoteEvidence__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_DuplicateVoteEvidence__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _DuplicateVoteEvidence__KeyAssembler _DuplicateVoteEvidence__Assembler

func (_DuplicateVoteEvidence__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.BeginMap(0)
}
func (_DuplicateVoteEvidence__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.BeginList(0)
}
func (na *_DuplicateVoteEvidence__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignNull()
}
func (_DuplicateVoteEvidence__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignBool(false)
}
func (_DuplicateVoteEvidence__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignInt(0)
}
func (_DuplicateVoteEvidence__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignFloat(0)
}
func (ka *_DuplicateVoteEvidence__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "VoteA":
		if ka.s&fieldBit__DuplicateVoteEvidence_VoteA != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteA}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_VoteA
		ka.state = maState_expectValue
		ka.f = 0
	case "VoteB":
		if ka.s&fieldBit__DuplicateVoteEvidence_VoteB != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteB}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_VoteB
		ka.state = maState_expectValue
		ka.f = 1
	case "TotalVotingPower":
		if ka.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_TotalVotingPower}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_TotalVotingPower
		ka.state = maState_expectValue
		ka.f = 2
	case "ValidatorPower":
		if ka.s&fieldBit__DuplicateVoteEvidence_ValidatorPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_ValidatorPower}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_ValidatorPower
		ka.state = maState_expectValue
		ka.f = 3
	case "Timestamp":
		if ka.s&fieldBit__DuplicateVoteEvidence_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_Timestamp}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.DuplicateVoteEvidence", Key: &_String{k}}
	}
	return nil
}
func (_DuplicateVoteEvidence__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignBytes(nil)
}
func (_DuplicateVoteEvidence__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignLink(nil)
}
func (ka *_DuplicateVoteEvidence__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_DuplicateVoteEvidence__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (DuplicateVoteEvidence) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n DuplicateVoteEvidence) Representation() ipld.Node {
	return (*_DuplicateVoteEvidence__Repr)(n)
}

type _DuplicateVoteEvidence__Repr _DuplicateVoteEvidence

var (
	fieldName__DuplicateVoteEvidence_VoteA_serial            = _String{"VoteA"}
	fieldName__DuplicateVoteEvidence_VoteB_serial            = _String{"VoteB"}
	fieldName__DuplicateVoteEvidence_TotalVotingPower_serial = _String{"TotalVotingPower"}
	fieldName__DuplicateVoteEvidence_ValidatorPower_serial   = _String{"ValidatorPower"}
	fieldName__DuplicateVoteEvidence_Timestamp_serial        = _String{"Timestamp"}
)
var _ ipld.Node = &_DuplicateVoteEvidence__Repr{}

func (_DuplicateVoteEvidence__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_DuplicateVoteEvidence__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "VoteA":
		return n.VoteA.Representation(), nil
	case "VoteB":
		return n.VoteB.Representation(), nil
	case "TotalVotingPower":
		return n.TotalVotingPower.Representation(), nil
	case "ValidatorPower":
		return n.ValidatorPower.Representation(), nil
	case "Timestamp":
		return n.Timestamp.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_DuplicateVoteEvidence__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_DuplicateVoteEvidence__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.LookupByIndex(0)
}
func (n _DuplicateVoteEvidence__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_DuplicateVoteEvidence__Repr) MapIterator() ipld.MapIterator {
	return &_DuplicateVoteEvidence__ReprMapItr{n, 0}
}

type _DuplicateVoteEvidence__ReprMapItr struct {
	n   *_DuplicateVoteEvidence__Repr
	idx int
}

func (itr *_DuplicateVoteEvidence__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__DuplicateVoteEvidence_VoteA_serial
		v = itr.n.VoteA.Representation()
	case 1:
		k = &fieldName__DuplicateVoteEvidence_VoteB_serial
		v = itr.n.VoteB.Representation()
	case 2:
		k = &fieldName__DuplicateVoteEvidence_TotalVotingPower_serial
		v = itr.n.TotalVotingPower.Representation()
	case 3:
		k = &fieldName__DuplicateVoteEvidence_ValidatorPower_serial
		v = itr.n.ValidatorPower.Representation()
	case 4:
		k = &fieldName__DuplicateVoteEvidence_Timestamp_serial
		v = itr.n.Timestamp.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_DuplicateVoteEvidence__ReprMapItr) Done() bool {
	return itr.idx >= 5
}
func (_DuplicateVoteEvidence__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_DuplicateVoteEvidence__Repr) Length() int64 {
	l := 5
	return int64(l)
}
func (_DuplicateVoteEvidence__Repr) IsAbsent() bool {
	return false
}
func (_DuplicateVoteEvidence__Repr) IsNull() bool {
	return false
}
func (_DuplicateVoteEvidence__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsBool()
}
func (_DuplicateVoteEvidence__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsInt()
}
func (_DuplicateVoteEvidence__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsFloat()
}
func (_DuplicateVoteEvidence__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsString()
}
func (_DuplicateVoteEvidence__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsBytes()
}
func (_DuplicateVoteEvidence__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsLink()
}
func (_DuplicateVoteEvidence__Repr) Prototype() ipld.NodePrototype {
	return _DuplicateVoteEvidence__ReprPrototype{}
}

type _DuplicateVoteEvidence__ReprPrototype struct{}

func (_DuplicateVoteEvidence__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _DuplicateVoteEvidence__ReprBuilder
	nb.Reset()
	return &nb
}

type _DuplicateVoteEvidence__ReprBuilder struct {
	_DuplicateVoteEvidence__ReprAssembler
}

func (nb *_DuplicateVoteEvidence__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_DuplicateVoteEvidence__ReprBuilder) Reset() {
	var w _DuplicateVoteEvidence
	var m schema.Maybe
	*nb = _DuplicateVoteEvidence__ReprBuilder{_DuplicateVoteEvidence__ReprAssembler{w: &w, m: &m}}
}

type _DuplicateVoteEvidence__ReprAssembler struct {
	w     *_DuplicateVoteEvidence
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_VoteA            _Vote__ReprAssembler
	ca_VoteB            _Vote__ReprAssembler
	ca_TotalVotingPower _Int__ReprAssembler
	ca_ValidatorPower   _Int__ReprAssembler
	ca_Timestamp        _Time__ReprAssembler
}

func (na *_DuplicateVoteEvidence__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_VoteA.reset()
	na.ca_VoteB.reset()
	na.ca_TotalVotingPower.reset()
	na.ca_ValidatorPower.reset()
	na.ca_Timestamp.reset()
}
func (na *_DuplicateVoteEvidence__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_DuplicateVoteEvidence{}
	}
	return na, nil
}
func (_DuplicateVoteEvidence__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.BeginList(0)
}
func (na *_DuplicateVoteEvidence__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignBool(false)
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignInt(0)
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignFloat(0)
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignString("")
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignBytes(nil)
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignLink(nil)
}
func (na *_DuplicateVoteEvidence__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_DuplicateVoteEvidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.DuplicateVoteEvidence.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_DuplicateVoteEvidence__ReprAssembler) Prototype() ipld.NodePrototype {
	return _DuplicateVoteEvidence__ReprPrototype{}
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "VoteA":
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteA != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteA_serial}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_VoteA
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_VoteA.w = &ma.w.VoteA
		ma.ca_VoteA.m = &ma.cm
		return &ma.ca_VoteA, nil
	case "VoteB":
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteB != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteB_serial}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_VoteB
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_VoteB.w = &ma.w.VoteB
		ma.ca_VoteB.m = &ma.cm
		return &ma.ca_VoteB, nil
	case "TotalVotingPower":
		if ma.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_TotalVotingPower_serial}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_TotalVotingPower
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower, nil
	case "ValidatorPower":
		if ma.s&fieldBit__DuplicateVoteEvidence_ValidatorPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_ValidatorPower_serial}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_ValidatorPower
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_ValidatorPower.w = &ma.w.ValidatorPower
		ma.ca_ValidatorPower.m = &ma.cm
		return &ma.ca_ValidatorPower, nil
	case "Timestamp":
		if ma.s&fieldBit__DuplicateVoteEvidence_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_Timestamp_serial}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.DuplicateVoteEvidence.Repr", Key: &_String{k}}
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_DuplicateVoteEvidence__ReprKeyAssembler)(ma)
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_VoteA.w = &ma.w.VoteA
		ma.ca_VoteA.m = &ma.cm
		return &ma.ca_VoteA
	case 1:
		ma.ca_VoteB.w = &ma.w.VoteB
		ma.ca_VoteB.m = &ma.cm
		return &ma.ca_VoteB
	case 2:
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower
	case 3:
		ma.ca_ValidatorPower.w = &ma.w.ValidatorPower
		ma.ca_ValidatorPower.m = &ma.cm
		return &ma.ca_ValidatorPower
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	default:
		panic("unreachable")
	}
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__DuplicateVoteEvidence_sufficient != fieldBits__DuplicateVoteEvidence_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteA == 0 {
			err.Missing = append(err.Missing, "VoteA")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteB == 0 {
			err.Missing = append(err.Missing, "VoteB")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower == 0 {
			err.Missing = append(err.Missing, "TotalVotingPower")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_ValidatorPower == 0 {
			err.Missing = append(err.Missing, "ValidatorPower")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _DuplicateVoteEvidence__ReprKeyAssembler _DuplicateVoteEvidence__ReprAssembler

func (_DuplicateVoteEvidence__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.BeginMap(0)
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_DuplicateVoteEvidence__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignNull()
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignBool(false)
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignInt(0)
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_DuplicateVoteEvidence__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "VoteA":
		if ka.s&fieldBit__DuplicateVoteEvidence_VoteA != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteA_serial}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_VoteA
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "VoteB":
		if ka.s&fieldBit__DuplicateVoteEvidence_VoteB != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteB_serial}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_VoteB
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "TotalVotingPower":
		if ka.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_TotalVotingPower_serial}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_TotalVotingPower
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "ValidatorPower":
		if ka.s&fieldBit__DuplicateVoteEvidence_ValidatorPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_ValidatorPower_serial}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_ValidatorPower
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Timestamp":
		if ka.s&fieldBit__DuplicateVoteEvidence_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_Timestamp_serial}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.DuplicateVoteEvidence.Repr", Key: &_String{k}}
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_DuplicateVoteEvidence__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Duration) Bytes() []byte {
	return n.x
}
func (_Duration__Prototype) FromBytes(v []byte) (Duration, error) {
	n := _Duration{v}
	return &n, nil
}

type _Duration__Maybe struct {
	m schema.Maybe
	v Duration
}
type MaybeDuration = *_Duration__Maybe

func (m MaybeDuration) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeDuration) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeDuration) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeDuration) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeDuration) Must() Duration {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Duration)(&_Duration{})
var _ schema.TypedNode = (Duration)(&_Duration{})

func (Duration) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Duration) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.LookupByString("")
}
func (Duration) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.LookupByNode(nil)
}
func (Duration) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.LookupByIndex(0)
}
func (Duration) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.LookupBySegment(seg)
}
func (Duration) MapIterator() ipld.MapIterator {
	return nil
}
func (Duration) ListIterator() ipld.ListIterator {
	return nil
}
func (Duration) Length() int64 {
	return -1
}
func (Duration) IsAbsent() bool {
	return false
}
func (Duration) IsNull() bool {
	return false
}
func (Duration) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.AsBool()
}
func (Duration) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.AsInt()
}
func (Duration) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.AsFloat()
}
func (Duration) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.AsString()
}
func (n Duration) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Duration) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.AsLink()
}
func (Duration) Prototype() ipld.NodePrototype {
	return _Duration__Prototype{}
}

type _Duration__Prototype struct{}

func (_Duration__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Duration__Builder
	nb.Reset()
	return &nb
}

type _Duration__Builder struct {
	_Duration__Assembler
}

func (nb *_Duration__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Duration__Builder) Reset() {
	var w _Duration
	var m schema.Maybe
	*nb = _Duration__Builder{_Duration__Assembler{w: &w, m: &m}}
}

type _Duration__Assembler struct {
	w *_Duration
	m *schema.Maybe
}

func (na *_Duration__Assembler) reset() {}
func (_Duration__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.BeginMap(0)
}
func (_Duration__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.BeginList(0)
}
func (na *_Duration__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Duration__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignBool(false)
}
func (_Duration__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignInt(0)
}
func (_Duration__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignFloat(0)
}
func (_Duration__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignString("")
}
func (na *_Duration__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Duration{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Duration__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignLink(nil)
}
func (na *_Duration__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Duration); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Duration__Assembler) Prototype() ipld.NodePrototype {
	return _Duration__Prototype{}
}
func (Duration) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Duration) Representation() ipld.Node {
	return (*_Duration__Repr)(n)
}

type _Duration__Repr = _Duration

var _ ipld.Node = &_Duration__Repr{}

type _Duration__ReprPrototype = _Duration__Prototype
type _Duration__ReprAssembler = _Duration__Assembler

func (n _Evidence) AsInterface() _Evidence__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	default:
		panic("invalid union state; how did you create this object?")
	}
}

type _Evidence__Maybe struct {
	m schema.Maybe
	v Evidence
}
type MaybeEvidence = *_Evidence__Maybe

func (m MaybeEvidence) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeEvidence) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeEvidence) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeEvidence) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeEvidence) Must() Evidence {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	memberName__Evidence_DuplicateVoteEvidence     = _String{"DuplicateVoteEvidence"}
	memberName__Evidence_LightClientAttackEvidence = _String{"LightClientAttackEvidence"}
)
var _ ipld.Node = (Evidence)(&_Evidence{})
var _ schema.TypedNode = (Evidence)(&_Evidence{})

func (Evidence) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Evidence) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "DuplicateVoteEvidence":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "LightClientAttackEvidence":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Evidence) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Evidence) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Evidence"}.LookupByIndex(0)
}
func (n Evidence) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Evidence) MapIterator() ipld.MapIterator {
	return &_Evidence__MapItr{n, false}
}

type _Evidence__MapItr struct {
	n    Evidence
	done bool
}

func (itr *_Evidence__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__Evidence_DuplicateVoteEvidence, &itr.n.x1
	case 2:
		k, v = &memberName__Evidence_LightClientAttackEvidence, &itr.n.x2
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_Evidence__MapItr) Done() bool {
	return itr.done
}

func (Evidence) ListIterator() ipld.ListIterator {
	return nil
}
func (Evidence) Length() int64 {
	return 1
}
func (Evidence) IsAbsent() bool {
	return false
}
func (Evidence) IsNull() bool {
	return false
}
func (Evidence) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsBool()
}
func (Evidence) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsInt()
}
func (Evidence) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsFloat()
}
func (Evidence) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsString()
}
func (Evidence) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsBytes()
}
func (Evidence) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsLink()
}
func (Evidence) Prototype() ipld.NodePrototype {
	return _Evidence__Prototype{}
}

type _Evidence__Prototype struct{}

func (_Evidence__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Evidence__Builder
	nb.Reset()
	return &nb
}

type _Evidence__Builder struct {
	_Evidence__Assembler
}

func (nb *_Evidence__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Evidence__Builder) Reset() {
	var w _Evidence
	var m schema.Maybe
	*nb = _Evidence__Builder{_Evidence__Assembler{w: &w, m: &m}}
}

type _Evidence__Assembler struct {
	w     *_Evidence
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _DuplicateVoteEvidence__Assembler

	ca2 _LightClientAttackEvidence__Assembler
	ca  uint
}

func (na *_Evidence__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_Evidence__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Evidence{}
	}
	return na, nil
}
func (_Evidence__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.BeginList(0)
}
func (na *_Evidence__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Evidence__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignBool(false)
}
func (_Evidence__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignInt(0)
}
func (_Evidence__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignFloat(0)
}
func (_Evidence__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignString("")
}
func (_Evidence__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignBytes(nil)
}
func (_Evidence__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignLink(nil)
}
func (na *_Evidence__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Evidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Evidence", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Evidence__Assembler) Prototype() ipld.NodePrototype {
	return _Evidence__Prototype{}
}
func (ma *_Evidence__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_Evidence__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "DuplicateVoteEvidence":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "LightClientAttackEvidence":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Evidence", Key: &_String{k}}
}
func (ma *_Evidence__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Evidence__KeyAssembler)(ma)
}
func (ma *_Evidence__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_Evidence__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Evidence__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Evidence__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "DuplicateVoteEvidence":
		return _DuplicateVoteEvidence__Prototype{}
	case "LightClientAttackEvidence":
		return _LightClientAttackEvidence__Prototype{}
	default:
		return nil
	}
}

type _Evidence__KeyAssembler _Evidence__Assembler

func (_Evidence__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.BeginMap(0)
}
func (_Evidence__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.BeginList(0)
}
func (na *_Evidence__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignNull()
}
func (_Evidence__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignBool(false)
}
func (_Evidence__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignInt(0)
}
func (_Evidence__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Evidence__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "DuplicateVoteEvidence":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "LightClientAttackEvidence":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Evidence", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_Evidence__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignBytes(nil)
}
func (_Evidence__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Evidence__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Evidence__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Evidence) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Evidence) Representation() ipld.Node {
	return (*_Evidence__Repr)(n)
}

type _Evidence__Repr _Evidence

var (
	memberName__Evidence_DuplicateVoteEvidence_serial     = _String{"duplicate"}
	memberName__Evidence_LightClientAttackEvidence_serial = _String{"light"}
)
var _ ipld.Node = &_Evidence__Repr{}

func (_Evidence__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Evidence__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "duplicate":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "light":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Evidence__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Evidence__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.LookupByIndex(0)
}
func (n _Evidence__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Evidence__Repr) MapIterator() ipld.MapIterator {
	return &_Evidence__ReprMapItr{n, false}
}

type _Evidence__ReprMapItr struct {
	n    *_Evidence__Repr
	done bool
}

func (itr *_Evidence__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__Evidence_DuplicateVoteEvidence_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__Evidence_LightClientAttackEvidence_serial, itr.n.x2.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_Evidence__ReprMapItr) Done() bool {
	return itr.done
}

func (_Evidence__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_Evidence__Repr) Length() int64 {
	return 1
}
func (_Evidence__Repr) IsAbsent() bool {
	return false
}
func (_Evidence__Repr) IsNull() bool {
	return false
}
func (_Evidence__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsBool()
}
func (_Evidence__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsInt()
}
func (_Evidence__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsFloat()
}
func (_Evidence__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsString()
}
func (_Evidence__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsBytes()
}
func (_Evidence__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsLink()
}
func (_Evidence__Repr) Prototype() ipld.NodePrototype {
	return _Evidence__ReprPrototype{}
}

type _Evidence__ReprPrototype struct{}

func (_Evidence__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Evidence__ReprBuilder
	nb.Reset()
	return &nb
}

type _Evidence__ReprBuilder struct {
	_Evidence__ReprAssembler
}

func (nb *_Evidence__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Evidence__ReprBuilder) Reset() {
	var w _Evidence
	var m schema.Maybe
	*nb = _Evidence__ReprBuilder{_Evidence__ReprAssembler{w: &w, m: &m}}
}

type _Evidence__ReprAssembler struct {
	w     *_Evidence
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _DuplicateVoteEvidence__ReprAssembler

	ca2 _LightClientAttackEvidence__ReprAssembler
	ca  uint
}

func (na *_Evidence__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_Evidence__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Evidence{}
	}
	return na, nil
}
func (_Evidence__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.BeginList(0)
}
func (na *_Evidence__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Evidence.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Evidence__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignBool(false)
}
func (_Evidence__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignInt(0)
}
func (_Evidence__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignFloat(0)
}
func (_Evidence__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignString("")
}
func (_Evidence__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignBytes(nil)
}
func (_Evidence__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignLink(nil)
}
func (na *_Evidence__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Evidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Evidence.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Evidence__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Evidence__ReprPrototype{}
}
func (ma *_Evidence__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_Evidence__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "duplicate":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "light":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Evidence.Repr", Key: &_String{k}}
}
func (ma *_Evidence__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Evidence__ReprKeyAssembler)(ma)
}
func (ma *_Evidence__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_Evidence__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Evidence__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Evidence__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "DuplicateVoteEvidence":
		return _DuplicateVoteEvidence__ReprPrototype{}
	case "LightClientAttackEvidence":
		return _LightClientAttackEvidence__ReprPrototype{}
	default:
		return nil
	}
}

type _Evidence__ReprKeyAssembler _Evidence__ReprAssembler

func (_Evidence__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Evidence__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Evidence__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignNull()
}
func (_Evidence__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Evidence__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Evidence__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Evidence__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "duplicate":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "light":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Evidence.Repr", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_Evidence__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Evidence__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Evidence__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Evidence__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _EvidenceData) FieldEvidence() EvidenceList {
	return &n.Evidence
}

type _EvidenceData__Maybe struct {
	m schema.Maybe
	v EvidenceData
}
type MaybeEvidenceData = *_EvidenceData__Maybe

func (m MaybeEvidenceData) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeEvidenceData) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeEvidenceData) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeEvidenceData) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeEvidenceData) Must() EvidenceData {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__EvidenceData_Evidence = _String{"Evidence"}
)
var _ ipld.Node = (EvidenceData)(&_EvidenceData{})
var _ schema.TypedNode = (EvidenceData)(&_EvidenceData{})

func (EvidenceData) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n EvidenceData) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Evidence":
		return &n.Evidence, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n EvidenceData) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (EvidenceData) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.LookupByIndex(0)
}
func (n EvidenceData) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n EvidenceData) MapIterator() ipld.MapIterator {
	return &_EvidenceData__MapItr{n, 0}
}

type _EvidenceData__MapItr struct {
	n   EvidenceData
	idx int
}

func (itr *_EvidenceData__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__EvidenceData_Evidence
		v = &itr.n.Evidence
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_EvidenceData__MapItr) Done() bool {
	return itr.idx >= 1
}

func (EvidenceData) ListIterator() ipld.ListIterator {
	return nil
}
func (EvidenceData) Length() int64 {
	return 1
}
func (EvidenceData) IsAbsent() bool {
	return false
}
func (EvidenceData) IsNull() bool {
	return false
}
func (EvidenceData) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsBool()
}
func (EvidenceData) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsInt()
}
func (EvidenceData) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsFloat()
}
func (EvidenceData) AsString() (string, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsString()
}
func (EvidenceData) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsBytes()
}
func (EvidenceData) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsLink()
}
func (EvidenceData) Prototype() ipld.NodePrototype {
	return _EvidenceData__Prototype{}
}

type _EvidenceData__Prototype struct{}

func (_EvidenceData__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _EvidenceData__Builder
	nb.Reset()
	return &nb
}

type _EvidenceData__Builder struct {
	_EvidenceData__Assembler
}

func (nb *_EvidenceData__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EvidenceData__Builder) Reset() {
	var w _EvidenceData
	var m schema.Maybe
	*nb = _EvidenceData__Builder{_EvidenceData__Assembler{w: &w, m: &m}}
}

type _EvidenceData__Assembler struct {
	w     *_EvidenceData
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm          schema.Maybe
	ca_Evidence _EvidenceList__Assembler
}

func (na *_EvidenceData__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Evidence.reset()
}

var (
	fieldBit__EvidenceData_Evidence    = 1 << 0
	fieldBits__EvidenceData_sufficient = 0 + 1<<0
)

func (na *_EvidenceData__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_EvidenceData{}
	}
	return na, nil
}
func (_EvidenceData__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.BeginList(0)
}
func (na *_EvidenceData__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EvidenceData__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignBool(false)
}
func (_EvidenceData__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignInt(0)
}
func (_EvidenceData__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignFloat(0)
}
func (_EvidenceData__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignString("")
}
func (_EvidenceData__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignBytes(nil)
}
func (_EvidenceData__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignLink(nil)
}
func (na *_EvidenceData__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EvidenceData); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.EvidenceData", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EvidenceData__Assembler) Prototype() ipld.NodePrototype {
	return _EvidenceData__Prototype{}
}
func (ma *_EvidenceData__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Evidence.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceData__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Evidence":
		if ma.s&fieldBit__EvidenceData_Evidence != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceData_Evidence}
		}
		ma.s += fieldBit__EvidenceData_Evidence
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceData", Key: &_String{k}}
}
func (ma *_EvidenceData__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_EvidenceData__KeyAssembler)(ma)
}
func (ma *_EvidenceData__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceData__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__EvidenceData_sufficient != fieldBits__EvidenceData_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__EvidenceData_Evidence == 0 {
			err.Missing = append(err.Missing, "Evidence")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EvidenceData__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_EvidenceData__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _EvidenceData__KeyAssembler _EvidenceData__Assembler

func (_EvidenceData__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.BeginMap(0)
}
func (_EvidenceData__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.BeginList(0)
}
func (na *_EvidenceData__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignNull()
}
func (_EvidenceData__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignBool(false)
}
func (_EvidenceData__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignInt(0)
}
func (_EvidenceData__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignFloat(0)
}
func (ka *_EvidenceData__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Evidence":
		if ka.s&fieldBit__EvidenceData_Evidence != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceData_Evidence}
		}
		ka.s += fieldBit__EvidenceData_Evidence
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceData", Key: &_String{k}}
	}
	return nil
}
func (_EvidenceData__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignBytes(nil)
}
func (_EvidenceData__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignLink(nil)
}
func (ka *_EvidenceData__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_EvidenceData__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (EvidenceData) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n EvidenceData) Representation() ipld.Node {
	return (*_EvidenceData__Repr)(n)
}

type _EvidenceData__Repr _EvidenceData

var (
	fieldName__EvidenceData_Evidence_serial = _String{"Evidence"}
)
var _ ipld.Node = &_EvidenceData__Repr{}

func (_EvidenceData__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_EvidenceData__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Evidence":
		return n.Evidence.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_EvidenceData__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_EvidenceData__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.LookupByIndex(0)
}
func (n _EvidenceData__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_EvidenceData__Repr) MapIterator() ipld.MapIterator {
	return &_EvidenceData__ReprMapItr{n, 0}
}

type _EvidenceData__ReprMapItr struct {
	n   *_EvidenceData__Repr
	idx int
}

func (itr *_EvidenceData__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__EvidenceData_Evidence_serial
		v = itr.n.Evidence.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_EvidenceData__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_EvidenceData__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_EvidenceData__Repr) Length() int64 {
	l := 1
	return int64(l)
}
func (_EvidenceData__Repr) IsAbsent() bool {
	return false
}
func (_EvidenceData__Repr) IsNull() bool {
	return false
}
func (_EvidenceData__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsBool()
}
func (_EvidenceData__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsInt()
}
func (_EvidenceData__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsFloat()
}
func (_EvidenceData__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsString()
}
func (_EvidenceData__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsBytes()
}
func (_EvidenceData__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsLink()
}
func (_EvidenceData__Repr) Prototype() ipld.NodePrototype {
	return _EvidenceData__ReprPrototype{}
}

type _EvidenceData__ReprPrototype struct{}

func (_EvidenceData__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _EvidenceData__ReprBuilder
	nb.Reset()
	return &nb
}

type _EvidenceData__ReprBuilder struct {
	_EvidenceData__ReprAssembler
}

func (nb *_EvidenceData__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EvidenceData__ReprBuilder) Reset() {
	var w _EvidenceData
	var m schema.Maybe
	*nb = _EvidenceData__ReprBuilder{_EvidenceData__ReprAssembler{w: &w, m: &m}}
}

type _EvidenceData__ReprAssembler struct {
	w     *_EvidenceData
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm          schema.Maybe
	ca_Evidence _EvidenceList__ReprAssembler
}

func (na *_EvidenceData__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Evidence.reset()
}
func (na *_EvidenceData__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_EvidenceData{}
	}
	return na, nil
}
func (_EvidenceData__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.BeginList(0)
}
func (na *_EvidenceData__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EvidenceData__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignBool(false)
}
func (_EvidenceData__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignInt(0)
}
func (_EvidenceData__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignFloat(0)
}
func (_EvidenceData__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignString("")
}
func (_EvidenceData__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignBytes(nil)
}
func (_EvidenceData__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignLink(nil)
}
func (na *_EvidenceData__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EvidenceData); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.EvidenceData.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EvidenceData__ReprAssembler) Prototype() ipld.NodePrototype {
	return _EvidenceData__ReprPrototype{}
}
func (ma *_EvidenceData__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceData__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Evidence":
		if ma.s&fieldBit__EvidenceData_Evidence != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceData_Evidence_serial}
		}
		ma.s += fieldBit__EvidenceData_Evidence
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceData.Repr", Key: &_String{k}}
}
func (ma *_EvidenceData__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_EvidenceData__ReprKeyAssembler)(ma)
}
func (ma *_EvidenceData__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceData__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__EvidenceData_sufficient != fieldBits__EvidenceData_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__EvidenceData_Evidence == 0 {
			err.Missing = append(err.Missing, "Evidence")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EvidenceData__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_EvidenceData__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _EvidenceData__ReprKeyAssembler _EvidenceData__ReprAssembler

func (_EvidenceData__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.BeginMap(0)
}
func (_EvidenceData__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_EvidenceData__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignNull()
}
func (_EvidenceData__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignBool(false)
}
func (_EvidenceData__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignInt(0)
}
func (_EvidenceData__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_EvidenceData__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Evidence":
		if ka.s&fieldBit__EvidenceData_Evidence != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceData_Evidence_serial}
		}
		ka.s += fieldBit__EvidenceData_Evidence
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceData.Repr", Key: &_String{k}}
}
func (_EvidenceData__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_EvidenceData__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_EvidenceData__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_EvidenceData__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_EvidenceList) Lookup(idx int64) Evidence {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_EvidenceList) LookupMaybe(idx int64) MaybeEvidence {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Evidence__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _EvidenceList__valueAbsent = _Evidence__Maybe{m: schema.Maybe_Absent}

func (n EvidenceList) Iterator() *EvidenceList__Itr {
	return &EvidenceList__Itr{n, 0}
}

type EvidenceList__Itr struct {
	n   EvidenceList
	idx int
}

func (itr *EvidenceList__Itr) Next() (idx int64, v Evidence) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *EvidenceList__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _EvidenceList__Maybe struct {
	m schema.Maybe
	v EvidenceList
}
type MaybeEvidenceList = *_EvidenceList__Maybe

func (m MaybeEvidenceList) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeEvidenceList) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeEvidenceList) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeEvidenceList) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeEvidenceList) Must() EvidenceList {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (EvidenceList)(&_EvidenceList{})
var _ schema.TypedNode = (EvidenceList)(&_EvidenceList{})

func (EvidenceList) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (EvidenceList) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.LookupByString("")
}
func (n EvidenceList) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n EvidenceList) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n EvidenceList) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.EvidenceList", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (EvidenceList) MapIterator() ipld.MapIterator {
	return nil
}
func (n EvidenceList) ListIterator() ipld.ListIterator {
	return &_EvidenceList__ListItr{n, 0}
}

type _EvidenceList__ListItr struct {
	n   EvidenceList
	idx int
}

func (itr *_EvidenceList__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_EvidenceList__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n EvidenceList) Length() int64 {
	return int64(len(n.x))
}
func (EvidenceList) IsAbsent() bool {
	return false
}
func (EvidenceList) IsNull() bool {
	return false
}
func (EvidenceList) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsBool()
}
func (EvidenceList) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsInt()
}
func (EvidenceList) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsFloat()
}
func (EvidenceList) AsString() (string, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsString()
}
func (EvidenceList) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsBytes()
}
func (EvidenceList) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsLink()
}
func (EvidenceList) Prototype() ipld.NodePrototype {
	return _EvidenceList__Prototype{}
}

type _EvidenceList__Prototype struct{}

func (_EvidenceList__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _EvidenceList__Builder
	nb.Reset()
	return &nb
}

type _EvidenceList__Builder struct {
	_EvidenceList__Assembler
}

func (nb *_EvidenceList__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EvidenceList__Builder) Reset() {
	var w _EvidenceList
	var m schema.Maybe
	*nb = _EvidenceList__Builder{_EvidenceList__Assembler{w: &w, m: &m}}
}

type _EvidenceList__Assembler struct {
	w     *_EvidenceList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Evidence__Assembler
}

func (na *_EvidenceList__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_EvidenceList__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.BeginMap(0)
}
func (na *_EvidenceList__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_EvidenceList{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Evidence, 0, sizeHint)
	}
	return na, nil
}
func (na *_EvidenceList__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EvidenceList__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignBool(false)
}
func (_EvidenceList__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignInt(0)
}
func (_EvidenceList__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignFloat(0)
}
func (_EvidenceList__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignString("")
}
func (_EvidenceList__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignBytes(nil)
}
func (_EvidenceList__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignLink(nil)
}
func (na *_EvidenceList__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EvidenceList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.EvidenceList", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EvidenceList__Assembler) Prototype() ipld.NodePrototype {
	return _EvidenceList__Prototype{}
}
func (la *_EvidenceList__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_EvidenceList__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Evidence{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_EvidenceList__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_EvidenceList__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Evidence__Prototype{}
}
func (EvidenceList) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n EvidenceList) Representation() ipld.Node {
	return (*_EvidenceList__Repr)(n)
}

type _EvidenceList__Repr _EvidenceList

var _ ipld.Node = &_EvidenceList__Repr{}

func (_EvidenceList__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_EvidenceList__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.LookupByString("")
}
func (nr *_EvidenceList__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (EvidenceList)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Evidence).Representation(), nil
}
func (nr *_EvidenceList__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (EvidenceList)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Evidence).Representation(), nil
}
func (n _EvidenceList__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.EvidenceList.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_EvidenceList__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_EvidenceList__Repr) ListIterator() ipld.ListIterator {
	return &_EvidenceList__ReprListItr{(EvidenceList)(nr), 0}
}

type _EvidenceList__ReprListItr _EvidenceList__ListItr

func (itr *_EvidenceList__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_EvidenceList__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Evidence).Representation(), nil
}
func (itr *_EvidenceList__ReprListItr) Done() bool {
	return (*_EvidenceList__ListItr)(itr).Done()
}

func (rn *_EvidenceList__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_EvidenceList__Repr) IsAbsent() bool {
	return false
}
func (_EvidenceList__Repr) IsNull() bool {
	return false
}
func (_EvidenceList__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsBool()
}
func (_EvidenceList__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsInt()
}
func (_EvidenceList__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsFloat()
}
func (_EvidenceList__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsString()
}
func (_EvidenceList__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsBytes()
}
func (_EvidenceList__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsLink()
}
func (_EvidenceList__Repr) Prototype() ipld.NodePrototype {
	return _EvidenceList__ReprPrototype{}
}

type _EvidenceList__ReprPrototype struct{}

func (_EvidenceList__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _EvidenceList__ReprBuilder
	nb.Reset()
	return &nb
}

type _EvidenceList__ReprBuilder struct {
	_EvidenceList__ReprAssembler
}

func (nb *_EvidenceList__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EvidenceList__ReprBuilder) Reset() {
	var w _EvidenceList
	var m schema.Maybe
	*nb = _EvidenceList__ReprBuilder{_EvidenceList__ReprAssembler{w: &w, m: &m}}
}

type _EvidenceList__ReprAssembler struct {
	w     *_EvidenceList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Evidence__ReprAssembler
}

func (na *_EvidenceList__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_EvidenceList__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.BeginMap(0)
}
func (na *_EvidenceList__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_EvidenceList{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Evidence, 0, sizeHint)
	}
	return na, nil
}
func (na *_EvidenceList__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EvidenceList__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignBool(false)
}
func (_EvidenceList__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignInt(0)
}
func (_EvidenceList__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignFloat(0)
}
func (_EvidenceList__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignString("")
}
func (_EvidenceList__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignBytes(nil)
}
func (_EvidenceList__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignLink(nil)
}
func (na *_EvidenceList__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EvidenceList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.EvidenceList.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EvidenceList__ReprAssembler) Prototype() ipld.NodePrototype {
	return _EvidenceList__ReprPrototype{}
}
func (la *_EvidenceList__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_EvidenceList__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Evidence{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_EvidenceList__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_EvidenceList__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Evidence__ReprPrototype{}
}

func (n Hash) Bytes() []byte {
	return n.x
}
func (_Hash__Prototype) FromBytes(v []byte) (Hash, error) {
	n := _Hash{v}
	return &n, nil
}

type _Hash__Maybe struct {
	m schema.Maybe
	v Hash
}
type MaybeHash = *_Hash__Maybe

func (m MaybeHash) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHash) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHash) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHash) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHash) Must() Hash {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Hash)(&_Hash{})
var _ schema.TypedNode = (Hash)(&_Hash{})

func (Hash) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Hash) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.LookupByString("")
}
func (Hash) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.LookupByNode(nil)
}
func (Hash) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.LookupByIndex(0)
}
func (Hash) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.LookupBySegment(seg)
}
func (Hash) MapIterator() ipld.MapIterator {
	return nil
}
func (Hash) ListIterator() ipld.ListIterator {
	return nil
}
func (Hash) Length() int64 {
	return -1
}
func (Hash) IsAbsent() bool {
	return false
}
func (Hash) IsNull() bool {
	return false
}
func (Hash) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.AsBool()
}
func (Hash) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.AsInt()
}
func (Hash) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.AsFloat()
}
func (Hash) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.AsString()
}
func (n Hash) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Hash) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.AsLink()
}
func (Hash) Prototype() ipld.NodePrototype {
	return _Hash__Prototype{}
}

type _Hash__Prototype struct{}

func (_Hash__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Hash__Builder
	nb.Reset()
	return &nb
}

type _Hash__Builder struct {
	_Hash__Assembler
}

func (nb *_Hash__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Hash__Builder) Reset() {
	var w _Hash
	var m schema.Maybe
	*nb = _Hash__Builder{_Hash__Assembler{w: &w, m: &m}}
}

type _Hash__Assembler struct {
	w *_Hash
	m *schema.Maybe
}

func (na *_Hash__Assembler) reset() {}
func (_Hash__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.BeginMap(0)
}
func (_Hash__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.BeginList(0)
}
func (na *_Hash__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Hash__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignBool(false)
}
func (_Hash__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignInt(0)
}
func (_Hash__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignFloat(0)
}
func (_Hash__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignString("")
}
func (na *_Hash__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Hash{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Hash__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignLink(nil)
}
func (na *_Hash__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Hash); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Hash__Assembler) Prototype() ipld.NodePrototype {
	return _Hash__Prototype{}
}
func (Hash) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Hash) Representation() ipld.Node {
	return (*_Hash__Repr)(n)
}

type _Hash__Repr = _Hash

var _ ipld.Node = &_Hash__Repr{}

type _Hash__ReprPrototype = _Hash__Prototype
type _Hash__ReprAssembler = _Hash__Assembler

func (n _HashedParams) FieldBlockMaxBytes() Int {
	return &n.BlockMaxBytes
}
func (n _HashedParams) FieldBlockMaxGas() Int {
	return &n.BlockMaxGas
}

type _HashedParams__Maybe struct {
	m schema.Maybe
	v HashedParams
}
type MaybeHashedParams = *_HashedParams__Maybe

func (m MaybeHashedParams) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHashedParams) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHashedParams) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHashedParams) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHashedParams) Must() HashedParams {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__HashedParams_BlockMaxBytes = _String{"BlockMaxBytes"}
	fieldName__HashedParams_BlockMaxGas   = _String{"BlockMaxGas"}
)
var _ ipld.Node = (HashedParams)(&_HashedParams{})
var _ schema.TypedNode = (HashedParams)(&_HashedParams{})

func (HashedParams) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n HashedParams) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "BlockMaxBytes":
		return &n.BlockMaxBytes, nil
	case "BlockMaxGas":
		return &n.BlockMaxGas, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n HashedParams) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (HashedParams) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.LookupByIndex(0)
}
func (n HashedParams) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n HashedParams) MapIterator() ipld.MapIterator {
	return &_HashedParams__MapItr{n, 0}
}

type _HashedParams__MapItr struct {
	n   HashedParams
	idx int
}

func (itr *_HashedParams__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__HashedParams_BlockMaxBytes
		v = &itr.n.BlockMaxBytes
	case 1:
		k = &fieldName__HashedParams_BlockMaxGas
		v = &itr.n.BlockMaxGas
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_HashedParams__MapItr) Done() bool {
	return itr.idx >= 2
}

func (HashedParams) ListIterator() ipld.ListIterator {
	return nil
}
func (HashedParams) Length() int64 {
	return 2
}
func (HashedParams) IsAbsent() bool {
	return false
}
func (HashedParams) IsNull() bool {
	return false
}
func (HashedParams) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsBool()
}
func (HashedParams) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsInt()
}
func (HashedParams) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsFloat()
}
func (HashedParams) AsString() (string, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsString()
}
func (HashedParams) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsBytes()
}
func (HashedParams) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsLink()
}
func (HashedParams) Prototype() ipld.NodePrototype {
	return _HashedParams__Prototype{}
}

type _HashedParams__Prototype struct{}

func (_HashedParams__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _HashedParams__Builder
	nb.Reset()
	return &nb
}

type _HashedParams__Builder struct {
	_HashedParams__Assembler
}

func (nb *_HashedParams__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_HashedParams__Builder) Reset() {
	var w _HashedParams
	var m schema.Maybe
	*nb = _HashedParams__Builder{_HashedParams__Assembler{w: &w, m: &m}}
}

type _HashedParams__Assembler struct {
	w     *_HashedParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm               schema.Maybe
	ca_BlockMaxBytes _Int__Assembler
	ca_BlockMaxGas   _Int__Assembler
}

func (na *_HashedParams__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_BlockMaxBytes.reset()
	na.ca_BlockMaxGas.reset()
}

var (
	fieldBit__HashedParams_BlockMaxBytes = 1 << 0
	fieldBit__HashedParams_BlockMaxGas   = 1 << 1
	fieldBits__HashedParams_sufficient   = 0 + 1<<0 + 1<<1
)

func (na *_HashedParams__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_HashedParams{}
	}
	return na, nil
}
func (_HashedParams__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.BeginList(0)
}
func (na *_HashedParams__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_HashedParams__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignBool(false)
}
func (_HashedParams__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignInt(0)
}
func (_HashedParams__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignFloat(0)
}
func (_HashedParams__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignString("")
}
func (_HashedParams__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignBytes(nil)
}
func (_HashedParams__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignLink(nil)
}
func (na *_HashedParams__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_HashedParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.HashedParams", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_HashedParams__Assembler) Prototype() ipld.NodePrototype {
	return _HashedParams__Prototype{}
}
func (ma *_HashedParams__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockMaxBytes.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockMaxGas.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_HashedParams__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "BlockMaxBytes":
		if ma.s&fieldBit__HashedParams_BlockMaxBytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxBytes}
		}
		ma.s += fieldBit__HashedParams_BlockMaxBytes
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_BlockMaxBytes.w = &ma.w.BlockMaxBytes
		ma.ca_BlockMaxBytes.m = &ma.cm
		return &ma.ca_BlockMaxBytes, nil
	case "BlockMaxGas":
		if ma.s&fieldBit__HashedParams_BlockMaxGas != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxGas}
		}
		ma.s += fieldBit__HashedParams_BlockMaxGas
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_BlockMaxGas.w = &ma.w.BlockMaxGas
		ma.ca_BlockMaxGas.m = &ma.cm
		return &ma.ca_BlockMaxGas, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.HashedParams", Key: &_String{k}}
}
func (ma *_HashedParams__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_HashedParams__KeyAssembler)(ma)
}
func (ma *_HashedParams__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_BlockMaxBytes.w = &ma.w.BlockMaxBytes
		ma.ca_BlockMaxBytes.m = &ma.cm
		return &ma.ca_BlockMaxBytes
	case 1:
		ma.ca_BlockMaxGas.w = &ma.w.BlockMaxGas
		ma.ca_BlockMaxGas.m = &ma.cm
		return &ma.ca_BlockMaxGas
	default:
		panic("unreachable")
	}
}
func (ma *_HashedParams__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__HashedParams_sufficient != fieldBits__HashedParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__HashedParams_BlockMaxBytes == 0 {
			err.Missing = append(err.Missing, "BlockMaxBytes")
		}
		if ma.s&fieldBit__HashedParams_BlockMaxGas == 0 {
			err.Missing = append(err.Missing, "BlockMaxGas")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_HashedParams__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_HashedParams__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _HashedParams__KeyAssembler _HashedParams__Assembler

func (_HashedParams__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.BeginMap(0)
}
func (_HashedParams__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.BeginList(0)
}
func (na *_HashedParams__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignNull()
}
func (_HashedParams__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignBool(false)
}
func (_HashedParams__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignInt(0)
}
func (_HashedParams__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignFloat(0)
}
func (ka *_HashedParams__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "BlockMaxBytes":
		if ka.s&fieldBit__HashedParams_BlockMaxBytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxBytes}
		}
		ka.s += fieldBit__HashedParams_BlockMaxBytes
		ka.state = maState_expectValue
		ka.f = 0
	case "BlockMaxGas":
		if ka.s&fieldBit__HashedParams_BlockMaxGas != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxGas}
		}
		ka.s += fieldBit__HashedParams_BlockMaxGas
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.HashedParams", Key: &_String{k}}
	}
	return nil
}
func (_HashedParams__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignBytes(nil)
}
func (_HashedParams__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignLink(nil)
}
func (ka *_HashedParams__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_HashedParams__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (HashedParams) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n HashedParams) Representation() ipld.Node {
	return (*_HashedParams__Repr)(n)
}

type _HashedParams__Repr _HashedParams

var (
	fieldName__HashedParams_BlockMaxBytes_serial = _String{"BlockMaxBytes"}
	fieldName__HashedParams_BlockMaxGas_serial   = _String{"BlockMaxGas"}
)
var _ ipld.Node = &_HashedParams__Repr{}

func (_HashedParams__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_HashedParams__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "BlockMaxBytes":
		return n.BlockMaxBytes.Representation(), nil
	case "BlockMaxGas":
		return n.BlockMaxGas.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_HashedParams__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_HashedParams__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.LookupByIndex(0)
}
func (n _HashedParams__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_HashedParams__Repr) MapIterator() ipld.MapIterator {
	return &_HashedParams__ReprMapItr{n, 0}
}

type _HashedParams__ReprMapItr struct {
	n   *_HashedParams__Repr
	idx int
}

func (itr *_HashedParams__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__HashedParams_BlockMaxBytes_serial
		v = itr.n.BlockMaxBytes.Representation()
	case 1:
		k = &fieldName__HashedParams_BlockMaxGas_serial
		v = itr.n.BlockMaxGas.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_HashedParams__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_HashedParams__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_HashedParams__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_HashedParams__Repr) IsAbsent() bool {
	return false
}
func (_HashedParams__Repr) IsNull() bool {
	return false
}
func (_HashedParams__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsBool()
}
func (_HashedParams__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsInt()
}
func (_HashedParams__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsFloat()
}
func (_HashedParams__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsString()
}
func (_HashedParams__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsBytes()
}
func (_HashedParams__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsLink()
}
func (_HashedParams__Repr) Prototype() ipld.NodePrototype {
	return _HashedParams__ReprPrototype{}
}

type _HashedParams__ReprPrototype struct{}

func (_HashedParams__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _HashedParams__ReprBuilder
	nb.Reset()
	return &nb
}

type _HashedParams__ReprBuilder struct {
	_HashedParams__ReprAssembler
}

func (nb *_HashedParams__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_HashedParams__ReprBuilder) Reset() {
	var w _HashedParams
	var m schema.Maybe
	*nb = _HashedParams__ReprBuilder{_HashedParams__ReprAssembler{w: &w, m: &m}}
}

type _HashedParams__ReprAssembler struct {
	w     *_HashedParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm               schema.Maybe
	ca_BlockMaxBytes _Int__ReprAssembler
	ca_BlockMaxGas   _Int__ReprAssembler
}

func (na *_HashedParams__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_BlockMaxBytes.reset()
	na.ca_BlockMaxGas.reset()
}
func (na *_HashedParams__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_HashedParams{}
	}
	return na, nil
}
func (_HashedParams__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.BeginList(0)
}
func (na *_HashedParams__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.HashedParams.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_HashedParams__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignBool(false)
}
func (_HashedParams__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignInt(0)
}
func (_HashedParams__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignFloat(0)
}
func (_HashedParams__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignString("")
}
func (_HashedParams__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignBytes(nil)
}
func (_HashedParams__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignLink(nil)
}
func (na *_HashedParams__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_HashedParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.HashedParams.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_HashedParams__ReprAssembler) Prototype() ipld.NodePrototype {
	return _HashedParams__ReprPrototype{}
}
func (ma *_HashedParams__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_HashedParams__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "BlockMaxBytes":
		if ma.s&fieldBit__HashedParams_BlockMaxBytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxBytes_serial}
		}
		ma.s += fieldBit__HashedParams_BlockMaxBytes
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_BlockMaxBytes.w = &ma.w.BlockMaxBytes
		ma.ca_BlockMaxBytes.m = &ma.cm
		return &ma.ca_BlockMaxBytes, nil
	case "BlockMaxGas":
		if ma.s&fieldBit__HashedParams_BlockMaxGas != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxGas_serial}
		}
		ma.s += fieldBit__HashedParams_BlockMaxGas
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_BlockMaxGas.w = &ma.w.BlockMaxGas
		ma.ca_BlockMaxGas.m = &ma.cm
		return &ma.ca_BlockMaxGas, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.HashedParams.Repr", Key: &_String{k}}
}
func (ma *_HashedParams__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_HashedParams__ReprKeyAssembler)(ma)
}
func (ma *_HashedParams__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_BlockMaxBytes.w = &ma.w.BlockMaxBytes
		ma.ca_BlockMaxBytes.m = &ma.cm
		return &ma.ca_BlockMaxBytes
	case 1:
		ma.ca_BlockMaxGas.w = &ma.w.BlockMaxGas
		ma.ca_BlockMaxGas.m = &ma.cm
		return &ma.ca_BlockMaxGas
	default:
		panic("unreachable")
	}
}
func (ma *_HashedParams__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__HashedParams_sufficient != fieldBits__HashedParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__HashedParams_BlockMaxBytes == 0 {
			err.Missing = append(err.Missing, "BlockMaxBytes")
		}
		if ma.s&fieldBit__HashedParams_BlockMaxGas == 0 {
			err.Missing = append(err.Missing, "BlockMaxGas")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_HashedParams__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_HashedParams__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _HashedParams__ReprKeyAssembler _HashedParams__ReprAssembler

func (_HashedParams__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.BeginMap(0)
}
func (_HashedParams__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_HashedParams__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignNull()
}
func (_HashedParams__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignBool(false)
}
func (_HashedParams__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignInt(0)
}
func (_HashedParams__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_HashedParams__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "BlockMaxBytes":
		if ka.s&fieldBit__HashedParams_BlockMaxBytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxBytes_serial}
		}
		ka.s += fieldBit__HashedParams_BlockMaxBytes
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "BlockMaxGas":
		if ka.s&fieldBit__HashedParams_BlockMaxGas != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxGas_serial}
		}
		ka.s += fieldBit__HashedParams_BlockMaxGas
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.HashedParams.Repr", Key: &_String{k}}
}
func (_HashedParams__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_HashedParams__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_HashedParams__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_HashedParams__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _Header) FieldVersion() Version {
	return &n.Version
}
func (n _Header) FieldChainID() String {
	return &n.ChainID
}
func (n _Header) FieldHeight() Int {
	return &n.Height
}
func (n _Header) FieldTime() Time {
	return &n.Time
}
func (n _Header) FieldLastBlockID() BlockID {
	return &n.LastBlockID
}
func (n _Header) FieldLastCommitHash() Link {
	return &n.LastCommitHash
}
func (n _Header) FieldDataHash() Link {
	return &n.DataHash
}
func (n _Header) FieldValidatorsHash() Link {
	return &n.ValidatorsHash
}
func (n _Header) FieldNextValidatorsHash() Link {
	return &n.NextValidatorsHash
}
func (n _Header) FieldConsensusHash() Link {
	return &n.ConsensusHash
}
func (n _Header) FieldAppHash() Link {
	return &n.AppHash
}
func (n _Header) FieldLastResultsHash() Link {
	return &n.LastResultsHash
}
func (n _Header) FieldEvidenceHash() Link {
	return &n.EvidenceHash
}
func (n _Header) FieldProposerAddress() Address {
	return &n.ProposerAddress
}

type _Header__Maybe struct {
	m schema.Maybe
	v Header
}
type MaybeHeader = *_Header__Maybe

func (m MaybeHeader) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHeader) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHeader) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHeader) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHeader) Must() Header {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Header_Version            = _String{"Version"}
	fieldName__Header_ChainID            = _String{"ChainID"}
	fieldName__Header_Height             = _String{"Height"}
	fieldName__Header_Time               = _String{"Time"}
	fieldName__Header_LastBlockID        = _String{"LastBlockID"}
	fieldName__Header_LastCommitHash     = _String{"LastCommitHash"}
	fieldName__Header_DataHash           = _String{"DataHash"}
	fieldName__Header_ValidatorsHash     = _String{"ValidatorsHash"}
	fieldName__Header_NextValidatorsHash = _String{"NextValidatorsHash"}
	fieldName__Header_ConsensusHash      = _String{"ConsensusHash"}
	fieldName__Header_AppHash            = _String{"AppHash"}
	fieldName__Header_LastResultsHash    = _String{"LastResultsHash"}
	fieldName__Header_EvidenceHash       = _String{"EvidenceHash"}
	fieldName__Header_ProposerAddress    = _String{"ProposerAddress"}
)
var _ ipld.Node = (Header)(&_Header{})
var _ schema.TypedNode = (Header)(&_Header{})

func (Header) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Header) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Version":
		return &n.Version, nil
	case "ChainID":
		return &n.ChainID, nil
	case "Height":
		return &n.Height, nil
	case "Time":
		return &n.Time, nil
	case "LastBlockID":
		return &n.LastBlockID, nil
	case "LastCommitHash":
		return &n.LastCommitHash, nil
	case "DataHash":
		return &n.DataHash, nil
	case "ValidatorsHash":
		return &n.ValidatorsHash, nil
	case "NextValidatorsHash":
		return &n.NextValidatorsHash, nil
	case "ConsensusHash":
		return &n.ConsensusHash, nil
	case "AppHash":
		return &n.AppHash, nil
	case "LastResultsHash":
		return &n.LastResultsHash, nil
	case "EvidenceHash":
		return &n.EvidenceHash, nil
	case "ProposerAddress":
		return &n.ProposerAddress, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Header) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Header) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Header"}.LookupByIndex(0)
}
func (n Header) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Header) MapIterator() ipld.MapIterator {
	return &_Header__MapItr{n, 0}
}

type _Header__MapItr struct {
	n   Header
	idx int
}

func (itr *_Header__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 14 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Header_Version
		v = &itr.n.Version
	case 1:
		k = &fieldName__Header_ChainID
		v = &itr.n.ChainID
	case 2:
		k = &fieldName__Header_Height
		v = &itr.n.Height
	case 3:
		k = &fieldName__Header_Time
		v = &itr.n.Time
	case 4:
		k = &fieldName__Header_LastBlockID
		v = &itr.n.LastBlockID
	case 5:
		k = &fieldName__Header_LastCommitHash
		v = &itr.n.LastCommitHash
	case 6:
		k = &fieldName__Header_DataHash
		v = &itr.n.DataHash
	case 7:
		k = &fieldName__Header_ValidatorsHash
		v = &itr.n.ValidatorsHash
	case 8:
		k = &fieldName__Header_NextValidatorsHash
		v = &itr.n.NextValidatorsHash
	case 9:
		k = &fieldName__Header_ConsensusHash
		v = &itr.n.ConsensusHash
	case 10:
		k = &fieldName__Header_AppHash
		v = &itr.n.AppHash
	case 11:
		k = &fieldName__Header_LastResultsHash
		v = &itr.n.LastResultsHash
	case 12:
		k = &fieldName__Header_EvidenceHash
		v = &itr.n.EvidenceHash
	case 13:
		k = &fieldName__Header_ProposerAddress
		v = &itr.n.ProposerAddress
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Header__MapItr) Done() bool {
	return itr.idx >= 14
}

func (Header) ListIterator() ipld.ListIterator {
	return nil
}
func (Header) Length() int64 {
	return 14
}
func (Header) IsAbsent() bool {
	return false
}
func (Header) IsNull() bool {
	return false
}
func (Header) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Header"}.AsBool()
}
func (Header) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Header"}.AsInt()
}
func (Header) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Header"}.AsFloat()
}
func (Header) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Header"}.AsString()
}
func (Header) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Header"}.AsBytes()
}
func (Header) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Header"}.AsLink()
}
func (Header) Prototype() ipld.NodePrototype {
	return _Header__Prototype{}
}

type _Header__Prototype struct{}

func (_Header__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Header__Builder
	nb.Reset()
	return &nb
}

type _Header__Builder struct {
	_Header__Assembler
}

func (nb *_Header__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Header__Builder) Reset() {
	var w _Header
	var m schema.Maybe
	*nb = _Header__Builder{_Header__Assembler{w: &w, m: &m}}
}

type _Header__Assembler struct {
	w     *_Header
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                    schema.Maybe
	ca_Version            _Version__Assembler
	ca_ChainID            _String__Assembler
	ca_Height             _Int__Assembler
	ca_Time               _Time__Assembler
	ca_LastBlockID        _BlockID__Assembler
	ca_LastCommitHash     _Link__Assembler
	ca_DataHash           _Link__Assembler
	ca_ValidatorsHash     _Link__Assembler
	ca_NextValidatorsHash _Link__Assembler
	ca_ConsensusHash      _Link__Assembler
	ca_AppHash            _Link__Assembler
	ca_LastResultsHash    _Link__Assembler
	ca_EvidenceHash       _Link__Assembler
	ca_ProposerAddress    _Address__Assembler
}

func (na *_Header__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Version.reset()
	na.ca_ChainID.reset()
	na.ca_Height.reset()
	na.ca_Time.reset()
	na.ca_LastBlockID.reset()
	na.ca_LastCommitHash.reset()
	na.ca_DataHash.reset()
	na.ca_ValidatorsHash.reset()
	na.ca_NextValidatorsHash.reset()
	na.ca_ConsensusHash.reset()
	na.ca_AppHash.reset()
	na.ca_LastResultsHash.reset()
	na.ca_EvidenceHash.reset()
	na.ca_ProposerAddress.reset()
}

var (
	fieldBit__Header_Version            = 1 << 0
	fieldBit__Header_ChainID            = 1 << 1
	fieldBit__Header_Height             = 1 << 2
	fieldBit__Header_Time               = 1 << 3
	fieldBit__Header_LastBlockID        = 1 << 4
	fieldBit__Header_LastCommitHash     = 1 << 5
	fieldBit__Header_DataHash           = 1 << 6
	fieldBit__Header_ValidatorsHash     = 1 << 7
	fieldBit__Header_NextValidatorsHash = 1 << 8
	fieldBit__Header_ConsensusHash      = 1 << 9
	fieldBit__Header_AppHash            = 1 << 10
	fieldBit__Header_LastResultsHash    = 1 << 11
	fieldBit__Header_EvidenceHash       = 1 << 12
	fieldBit__Header_ProposerAddress    = 1 << 13
	fieldBits__Header_sufficient        = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6 + 1<<7 + 1<<8 + 1<<9 + 1<<10 + 1<<11 + 1<<12 + 1<<13
)

func (na *_Header__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Header{}
	}
	return na, nil
}
func (_Header__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Header"}.BeginList(0)
}
func (na *_Header__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Header"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Header__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignBool(false)
}
func (_Header__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignInt(0)
}
func (_Header__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignFloat(0)
}
func (_Header__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignString("")
}
func (_Header__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignBytes(nil)
}
func (_Header__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignLink(nil)
}
func (na *_Header__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Header); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Header", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Header__Assembler) Prototype() ipld.NodePrototype {
	return _Header__Prototype{}
}
func (ma *_Header__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Version.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ChainID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Height.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Time.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_LastBlockID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_LastCommitHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_DataHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorsHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_NextValidatorsHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ConsensusHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_AppHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_LastResultsHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_EvidenceHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ProposerAddress.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Header__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Version":
		if ma.s&fieldBit__Header_Version != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Version}
		}
		ma.s += fieldBit__Header_Version
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version, nil
	case "ChainID":
		if ma.s&fieldBit__Header_ChainID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ChainID}
		}
		ma.s += fieldBit__Header_ChainID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID, nil
	case "Height":
		if ma.s&fieldBit__Header_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Height}
		}
		ma.s += fieldBit__Header_Height
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Time":
		if ma.s&fieldBit__Header_Time != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time}
		}
		ma.s += fieldBit__Header_Time
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time, nil
	case "LastBlockID":
		if ma.s&fieldBit__Header_LastBlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastBlockID}
		}
		ma.s += fieldBit__Header_LastBlockID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_LastBlockID.w = &ma.w.LastBlockID
		ma.ca_LastBlockID.m = &ma.cm
		return &ma.ca_LastBlockID, nil
	case "LastCommitHash":
		if ma.s&fieldBit__Header_LastCommitHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastCommitHash}
		}
		ma.s += fieldBit__Header_LastCommitHash
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_LastCommitHash.w = &ma.w.LastCommitHash
		ma.ca_LastCommitHash.m = &ma.cm
		return &ma.ca_LastCommitHash, nil
	case "DataHash":
		if ma.s&fieldBit__Header_DataHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_DataHash}
		}
		ma.s += fieldBit__Header_DataHash
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_DataHash.w = &ma.w.DataHash
		ma.ca_DataHash.m = &ma.cm
		return &ma.ca_DataHash, nil
	case "ValidatorsHash":
		if ma.s&fieldBit__Header_ValidatorsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ValidatorsHash}
		}
		ma.s += fieldBit__Header_ValidatorsHash
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_ValidatorsHash.w = &ma.w.ValidatorsHash
		ma.ca_ValidatorsHash.m = &ma.cm
		return &ma.ca_ValidatorsHash, nil
	case "NextValidatorsHash":
		if ma.s&fieldBit__Header_NextValidatorsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_NextValidatorsHash}
		}
		ma.s += fieldBit__Header_NextValidatorsHash
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_NextValidatorsHash.w = &ma.w.NextValidatorsHash
		ma.ca_NextValidatorsHash.m = &ma.cm
		return &ma.ca_NextValidatorsHash, nil
	case "ConsensusHash":
		if ma.s&fieldBit__Header_ConsensusHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ConsensusHash}
		}
		ma.s += fieldBit__Header_ConsensusHash
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_ConsensusHash.w = &ma.w.ConsensusHash
		ma.ca_ConsensusHash.m = &ma.cm
		return &ma.ca_ConsensusHash, nil
	case "AppHash":
		if ma.s&fieldBit__Header_AppHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_AppHash}
		}
		ma.s += fieldBit__Header_AppHash
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_AppHash.w = &ma.w.AppHash
		ma.ca_AppHash.m = &ma.cm
		return &ma.ca_AppHash, nil
	case "LastResultsHash":
		if ma.s&fieldBit__Header_LastResultsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastResultsHash}
		}
		ma.s += fieldBit__Header_LastResultsHash
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_LastResultsHash.w = &ma.w.LastResultsHash
		ma.ca_LastResultsHash.m = &ma.cm
		return &ma.ca_LastResultsHash, nil
	case "EvidenceHash":
		if ma.s&fieldBit__Header_EvidenceHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_EvidenceHash}
		}
		ma.s += fieldBit__Header_EvidenceHash
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_EvidenceHash.w = &ma.w.EvidenceHash
		ma.ca_EvidenceHash.m = &ma.cm
		return &ma.ca_EvidenceHash, nil
	case "ProposerAddress":
		if ma.s&fieldBit__Header_ProposerAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ProposerAddress}
		}
		ma.s += fieldBit__Header_ProposerAddress
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_ProposerAddress.w = &ma.w.ProposerAddress
		ma.ca_ProposerAddress.m = &ma.cm
		return &ma.ca_ProposerAddress, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Header", Key: &_String{k}}
}
func (ma *_Header__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Header__KeyAssembler)(ma)
}
func (ma *_Header__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version
	case 1:
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID
	case 2:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 3:
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time
	case 4:
		ma.ca_LastBlockID.w = &ma.w.LastBlockID
		ma.ca_LastBlockID.m = &ma.cm
		return &ma.ca_LastBlockID
	case 5:
		ma.ca_LastCommitHash.w = &ma.w.LastCommitHash
		ma.ca_LastCommitHash.m = &ma.cm
		return &ma.ca_LastCommitHash
	case 6:
		ma.ca_DataHash.w = &ma.w.DataHash
		ma.ca_DataHash.m = &ma.cm
		return &ma.ca_DataHash
	case 7:
		ma.ca_ValidatorsHash.w = &ma.w.ValidatorsHash
		ma.ca_ValidatorsHash.m = &ma.cm
		return &ma.ca_ValidatorsHash
	case 8:
		ma.ca_NextValidatorsHash.w = &ma.w.NextValidatorsHash
		ma.ca_NextValidatorsHash.m = &ma.cm
		return &ma.ca_NextValidatorsHash
	case 9:
		ma.ca_ConsensusHash.w = &ma.w.ConsensusHash
		ma.ca_ConsensusHash.m = &ma.cm
		return &ma.ca_ConsensusHash
	case 10:
		ma.ca_AppHash.w = &ma.w.AppHash
		ma.ca_AppHash.m = &ma.cm
		return &ma.ca_AppHash
	case 11:
		ma.ca_LastResultsHash.w = &ma.w.LastResultsHash
		ma.ca_LastResultsHash.m = &ma.cm
		return &ma.ca_LastResultsHash
	case 12:
		ma.ca_EvidenceHash.w = &ma.w.EvidenceHash
		ma.ca_EvidenceHash.m = &ma.cm
		return &ma.ca_EvidenceHash
	case 13:
		ma.ca_ProposerAddress.w = &ma.w.ProposerAddress
		ma.ca_ProposerAddress.m = &ma.cm
		return &ma.ca_ProposerAddress
	default:
		panic("unreachable")
	}
}
func (ma *_Header__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Header_sufficient != fieldBits__Header_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Header_Version == 0 {
			err.Missing = append(err.Missing, "Version")
		}
		if ma.s&fieldBit__Header_ChainID == 0 {
			err.Missing = append(err.Missing, "ChainID")
		}
		if ma.s&fieldBit__Header_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Header_Time == 0 {
			err.Missing = append(err.Missing, "Time")
		}
		if ma.s&fieldBit__Header_LastBlockID == 0 {
			err.Missing = append(err.Missing, "LastBlockID")
		}
		if ma.s&fieldBit__Header_LastCommitHash == 0 {
			err.Missing = append(err.Missing, "LastCommitHash")
		}
		if ma.s&fieldBit__Header_DataHash == 0 {
			err.Missing = append(err.Missing, "DataHash")
		}
		if ma.s&fieldBit__Header_ValidatorsHash == 0 {
			err.Missing = append(err.Missing, "ValidatorsHash")
		}
		if ma.s&fieldBit__Header_NextValidatorsHash == 0 {
			err.Missing = append(err.Missing, "NextValidatorsHash")
		}
		if ma.s&fieldBit__Header_ConsensusHash == 0 {
			err.Missing = append(err.Missing, "ConsensusHash")
		}
		if ma.s&fieldBit__Header_AppHash == 0 {
			err.Missing = append(err.Missing, "AppHash")
		}
		if ma.s&fieldBit__Header_LastResultsHash == 0 {
			err.Missing = append(err.Missing, "LastResultsHash")
		}
		if ma.s&fieldBit__Header_EvidenceHash == 0 {
			err.Missing = append(err.Missing, "EvidenceHash")
		}
		if ma.s&fieldBit__Header_ProposerAddress == 0 {
			err.Missing = append(err.Missing, "ProposerAddress")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Header__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Header__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Header__KeyAssembler _Header__Assembler

func (_Header__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.BeginMap(0)
}
func (_Header__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.BeginList(0)
}
func (na *_Header__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignNull()
}
func (_Header__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignBool(false)
}
func (_Header__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignInt(0)
}
func (_Header__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Header__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Version":
		if ka.s&fieldBit__Header_Version != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Version}
		}
		ka.s += fieldBit__Header_Version
		ka.state = maState_expectValue
		ka.f = 0
	case "ChainID":
		if ka.s&fieldBit__Header_ChainID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ChainID}
		}
		ka.s += fieldBit__Header_ChainID
		ka.state = maState_expectValue
		ka.f = 1
	case "Height":
		if ka.s&fieldBit__Header_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Height}
		}
		ka.s += fieldBit__Header_Height
		ka.state = maState_expectValue
		ka.f = 2
	case "Time":
		if ka.s&fieldBit__Header_Time != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time}
		}
		ka.s += fieldBit__Header_Time
		ka.state = maState_expectValue
		ka.f = 3
	case "LastBlockID":
		if ka.s&fieldBit__Header_LastBlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastBlockID}
		}
		ka.s += fieldBit__Header_LastBlockID
		ka.state = maState_expectValue
		ka.f = 4
	case "LastCommitHash":
		if ka.s&fieldBit__Header_LastCommitHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastCommitHash}
		}
		ka.s += fieldBit__Header_LastCommitHash
		ka.state = maState_expectValue
		ka.f = 5
	case "DataHash":
		if ka.s&fieldBit__Header_DataHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_DataHash}
		}
		ka.s += fieldBit__Header_DataHash
		ka.state = maState_expectValue
		ka.f = 6
	case "ValidatorsHash":
		if ka.s&fieldBit__Header_ValidatorsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ValidatorsHash}
		}
		ka.s += fieldBit__Header_ValidatorsHash
		ka.state = maState_expectValue
		ka.f = 7
	case "NextValidatorsHash":
		if ka.s&fieldBit__Header_NextValidatorsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_NextValidatorsHash}
		}
		ka.s += fieldBit__Header_NextValidatorsHash
		ka.state = maState_expectValue
		ka.f = 8
	case "ConsensusHash":
		if ka.s&fieldBit__Header_ConsensusHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ConsensusHash}
		}
		ka.s += fieldBit__Header_ConsensusHash
		ka.state = maState_expectValue
		ka.f = 9
	case "AppHash":
		if ka.s&fieldBit__Header_AppHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_AppHash}
		}
		ka.s += fieldBit__Header_AppHash
		ka.state = maState_expectValue
		ka.f = 10
	case "LastResultsHash":
		if ka.s&fieldBit__Header_LastResultsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastResultsHash}
		}
		ka.s += fieldBit__Header_LastResultsHash
		ka.state = maState_expectValue
		ka.f = 11
	case "EvidenceHash":
		if ka.s&fieldBit__Header_EvidenceHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_EvidenceHash}
		}
		ka.s += fieldBit__Header_EvidenceHash
		ka.state = maState_expectValue
		ka.f = 12
	case "ProposerAddress":
		if ka.s&fieldBit__Header_ProposerAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ProposerAddress}
		}
		ka.s += fieldBit__Header_ProposerAddress
		ka.state = maState_expectValue
		ka.f = 13
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Header", Key: &_String{k}}
	}
	return nil
}
func (_Header__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignBytes(nil)
}
func (_Header__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Header__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Header__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Header) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Header) Representation() ipld.Node {
	return (*_Header__Repr)(n)
}

type _Header__Repr _Header

var (
	fieldName__Header_Version_serial            = _String{"Version"}
	fieldName__Header_ChainID_serial            = _String{"ChainID"}
	fieldName__Header_Height_serial             = _String{"Height"}
	fieldName__Header_Time_serial               = _String{"Time"}
	fieldName__Header_LastBlockID_serial        = _String{"LastBlockID"}
	fieldName__Header_LastCommitHash_serial     = _String{"LastCommitHash"}
	fieldName__Header_DataHash_serial           = _String{"DataHash"}
	fieldName__Header_ValidatorsHash_serial     = _String{"ValidatorsHash"}
	fieldName__Header_NextValidatorsHash_serial = _String{"NextValidatorsHash"}
	fieldName__Header_ConsensusHash_serial      = _String{"ConsensusHash"}
	fieldName__Header_AppHash_serial            = _String{"AppHash"}
	fieldName__Header_LastResultsHash_serial    = _String{"LastResultsHash"}
	fieldName__Header_EvidenceHash_serial       = _String{"EvidenceHash"}
	fieldName__Header_ProposerAddress_serial    = _String{"ProposerAddress"}
)
var _ ipld.Node = &_Header__Repr{}

func (_Header__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Header__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Version":
		return n.Version.Representation(), nil
	case "ChainID":
		return n.ChainID.Representation(), nil
	case "Height":
		return n.Height.Representation(), nil
	case "Time":
		return n.Time.Representation(), nil
	case "LastBlockID":
		return n.LastBlockID.Representation(), nil
	case "LastCommitHash":
		return n.LastCommitHash.Representation(), nil
	case "DataHash":
		return n.DataHash.Representation(), nil
	case "ValidatorsHash":
		return n.ValidatorsHash.Representation(), nil
	case "NextValidatorsHash":
		return n.NextValidatorsHash.Representation(), nil
	case "ConsensusHash":
		return n.ConsensusHash.Representation(), nil
	case "AppHash":
		return n.AppHash.Representation(), nil
	case "LastResultsHash":
		return n.LastResultsHash.Representation(), nil
	case "EvidenceHash":
		return n.EvidenceHash.Representation(), nil
	case "ProposerAddress":
		return n.ProposerAddress.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Header__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Header__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.LookupByIndex(0)
}
func (n _Header__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Header__Repr) MapIterator() ipld.MapIterator {
	return &_Header__ReprMapItr{n, 0}
}

type _Header__ReprMapItr struct {
	n   *_Header__Repr
	idx int
}

func (itr *_Header__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 14 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Header_Version_serial
		v = itr.n.Version.Representation()
	case 1:
		k = &fieldName__Header_ChainID_serial
		v = itr.n.ChainID.Representation()
	case 2:
		k = &fieldName__Header_Height_serial
		v = itr.n.Height.Representation()
	case 3:
		k = &fieldName__Header_Time_serial
		v = itr.n.Time.Representation()
	case 4:
		k = &fieldName__Header_LastBlockID_serial
		v = itr.n.LastBlockID.Representation()
	case 5:
		k = &fieldName__Header_LastCommitHash_serial
		v = itr.n.LastCommitHash.Representation()
	case 6:
		k = &fieldName__Header_DataHash_serial
		v = itr.n.DataHash.Representation()
	case 7:
		k = &fieldName__Header_ValidatorsHash_serial
		v = itr.n.ValidatorsHash.Representation()
	case 8:
		k = &fieldName__Header_NextValidatorsHash_serial
		v = itr.n.NextValidatorsHash.Representation()
	case 9:
		k = &fieldName__Header_ConsensusHash_serial
		v = itr.n.ConsensusHash.Representation()
	case 10:
		k = &fieldName__Header_AppHash_serial
		v = itr.n.AppHash.Representation()
	case 11:
		k = &fieldName__Header_LastResultsHash_serial
		v = itr.n.LastResultsHash.Representation()
	case 12:
		k = &fieldName__Header_EvidenceHash_serial
		v = itr.n.EvidenceHash.Representation()
	case 13:
		k = &fieldName__Header_ProposerAddress_serial
		v = itr.n.ProposerAddress.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Header__ReprMapItr) Done() bool {
	return itr.idx >= 14
}
func (_Header__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Header__Repr) Length() int64 {
	l := 14
	return int64(l)
}
func (_Header__Repr) IsAbsent() bool {
	return false
}
func (_Header__Repr) IsNull() bool {
	return false
}
func (_Header__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsBool()
}
func (_Header__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsInt()
}
func (_Header__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsFloat()
}
func (_Header__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsString()
}
func (_Header__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsBytes()
}
func (_Header__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsLink()
}
func (_Header__Repr) Prototype() ipld.NodePrototype {
	return _Header__ReprPrototype{}
}

type _Header__ReprPrototype struct{}

func (_Header__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Header__ReprBuilder
	nb.Reset()
	return &nb
}

type _Header__ReprBuilder struct {
	_Header__ReprAssembler
}

func (nb *_Header__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Header__ReprBuilder) Reset() {
	var w _Header
	var m schema.Maybe
	*nb = _Header__ReprBuilder{_Header__ReprAssembler{w: &w, m: &m}}
}

type _Header__ReprAssembler struct {
	w     *_Header
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                    schema.Maybe
	ca_Version            _Version__ReprAssembler
	ca_ChainID            _String__ReprAssembler
	ca_Height             _Int__ReprAssembler
	ca_Time               _Time__ReprAssembler
	ca_LastBlockID        _BlockID__ReprAssembler
	ca_LastCommitHash     _Link__ReprAssembler
	ca_DataHash           _Link__ReprAssembler
	ca_ValidatorsHash     _Link__ReprAssembler
	ca_NextValidatorsHash _Link__ReprAssembler
	ca_ConsensusHash      _Link__ReprAssembler
	ca_AppHash            _Link__ReprAssembler
	ca_LastResultsHash    _Link__ReprAssembler
	ca_EvidenceHash       _Link__ReprAssembler
	ca_ProposerAddress    _Address__ReprAssembler
}

func (na *_Header__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Version.reset()
	na.ca_ChainID.reset()
	na.ca_Height.reset()
	na.ca_Time.reset()
	na.ca_LastBlockID.reset()
	na.ca_LastCommitHash.reset()
	na.ca_DataHash.reset()
	na.ca_ValidatorsHash.reset()
	na.ca_NextValidatorsHash.reset()
	na.ca_ConsensusHash.reset()
	na.ca_AppHash.reset()
	na.ca_LastResultsHash.reset()
	na.ca_EvidenceHash.reset()
	na.ca_ProposerAddress.reset()
}
func (na *_Header__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Header{}
	}
	return na, nil
}
func (_Header__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.BeginList(0)
}
func (na *_Header__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Header.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Header__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignBool(false)
}
func (_Header__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignInt(0)
}
func (_Header__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignFloat(0)
}
func (_Header__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignString("")
}
func (_Header__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignBytes(nil)
}
func (_Header__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignLink(nil)
}
func (na *_Header__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Header); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Header.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Header__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Header__ReprPrototype{}
}
func (ma *_Header__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Header__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Version":
		if ma.s&fieldBit__Header_Version != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Version_serial}
		}
		ma.s += fieldBit__Header_Version
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version, nil
	case "ChainID":
		if ma.s&fieldBit__Header_ChainID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ChainID_serial}
		}
		ma.s += fieldBit__Header_ChainID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID, nil
	case "Height":
		if ma.s&fieldBit__Header_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Height_serial}
		}
		ma.s += fieldBit__Header_Height
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Time":
		if ma.s&fieldBit__Header_Time != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time_serial}
		}
		ma.s += fieldBit__Header_Time
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time, nil
	case "LastBlockID":
		if ma.s&fieldBit__Header_LastBlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastBlockID_serial}
		}
		ma.s += fieldBit__Header_LastBlockID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_LastBlockID.w = &ma.w.LastBlockID
		ma.ca_LastBlockID.m = &ma.cm
		return &ma.ca_LastBlockID, nil
	case "LastCommitHash":
		if ma.s&fieldBit__Header_LastCommitHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastCommitHash_serial}
		}
		ma.s += fieldBit__Header_LastCommitHash
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_LastCommitHash.w = &ma.w.LastCommitHash
		ma.ca_LastCommitHash.m = &ma.cm
		return &ma.ca_LastCommitHash, nil
	case "DataHash":
		if ma.s&fieldBit__Header_DataHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_DataHash_serial}
		}
		ma.s += fieldBit__Header_DataHash
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_DataHash.w = &ma.w.DataHash
		ma.ca_DataHash.m = &ma.cm
		return &ma.ca_DataHash, nil
	case "ValidatorsHash":
		if ma.s&fieldBit__Header_ValidatorsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ValidatorsHash_serial}
		}
		ma.s += fieldBit__Header_ValidatorsHash
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_ValidatorsHash.w = &ma.w.ValidatorsHash
		ma.ca_ValidatorsHash.m = &ma.cm
		return &ma.ca_ValidatorsHash, nil
	case "NextValidatorsHash":
		if ma.s&fieldBit__Header_NextValidatorsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_NextValidatorsHash_serial}
		}
		ma.s += fieldBit__Header_NextValidatorsHash
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_NextValidatorsHash.w = &ma.w.NextValidatorsHash
		ma.ca_NextValidatorsHash.m = &ma.cm
		return &ma.ca_NextValidatorsHash, nil
	case "ConsensusHash":
		if ma.s&fieldBit__Header_ConsensusHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ConsensusHash_serial}
		}
		ma.s += fieldBit__Header_ConsensusHash
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_ConsensusHash.w = &ma.w.ConsensusHash
		ma.ca_ConsensusHash.m = &ma.cm
		return &ma.ca_ConsensusHash, nil
	case "AppHash":
		if ma.s&fieldBit__Header_AppHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_AppHash_serial}
		}
		ma.s += fieldBit__Header_AppHash
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_AppHash.w = &ma.w.AppHash
		ma.ca_AppHash.m = &ma.cm
		return &ma.ca_AppHash, nil
	case "LastResultsHash":
		if ma.s&fieldBit__Header_LastResultsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastResultsHash_serial}
		}
		ma.s += fieldBit__Header_LastResultsHash
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_LastResultsHash.w = &ma.w.LastResultsHash
		ma.ca_LastResultsHash.m = &ma.cm
		return &ma.ca_LastResultsHash, nil
	case "EvidenceHash":
		if ma.s&fieldBit__Header_EvidenceHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_EvidenceHash_serial}
		}
		ma.s += fieldBit__Header_EvidenceHash
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_EvidenceHash.w = &ma.w.EvidenceHash
		ma.ca_EvidenceHash.m = &ma.cm
		return &ma.ca_EvidenceHash, nil
	case "ProposerAddress":
		if ma.s&fieldBit__Header_ProposerAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ProposerAddress_serial}
		}
		ma.s += fieldBit__Header_ProposerAddress
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_ProposerAddress.w = &ma.w.ProposerAddress
		ma.ca_ProposerAddress.m = &ma.cm
		return &ma.ca_ProposerAddress, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Header.Repr", Key: &_String{k}}
}
func (ma *_Header__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Header__ReprKeyAssembler)(ma)
}
func (ma *_Header__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version
	case 1:
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID
	case 2:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 3:
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time
	case 4:
		ma.ca_LastBlockID.w = &ma.w.LastBlockID
		ma.ca_LastBlockID.m = &ma.cm
		return &ma.ca_LastBlockID
	case 5:
		ma.ca_LastCommitHash.w = &ma.w.LastCommitHash
		ma.ca_LastCommitHash.m = &ma.cm
		return &ma.ca_LastCommitHash
	case 6:
		ma.ca_DataHash.w = &ma.w.DataHash
		ma.ca_DataHash.m = &ma.cm
		return &ma.ca_DataHash
	case 7:
		ma.ca_ValidatorsHash.w = &ma.w.ValidatorsHash
		ma.ca_ValidatorsHash.m = &ma.cm
		return &ma.ca_ValidatorsHash
	case 8:
		ma.ca_NextValidatorsHash.w = &ma.w.NextValidatorsHash
		ma.ca_NextValidatorsHash.m = &ma.cm
		return &ma.ca_NextValidatorsHash
	case 9:
		ma.ca_ConsensusHash.w = &ma.w.ConsensusHash
		ma.ca_ConsensusHash.m = &ma.cm
		return &ma.ca_ConsensusHash
	case 10:
		ma.ca_AppHash.w = &ma.w.AppHash
		ma.ca_AppHash.m = &ma.cm
		return &ma.ca_AppHash
	case 11:
		ma.ca_LastResultsHash.w = &ma.w.LastResultsHash
		ma.ca_LastResultsHash.m = &ma.cm
		return &ma.ca_LastResultsHash
	case 12:
		ma.ca_EvidenceHash.w = &ma.w.EvidenceHash
		ma.ca_EvidenceHash.m = &ma.cm
		return &ma.ca_EvidenceHash
	case 13:
		ma.ca_ProposerAddress.w = &ma.w.ProposerAddress
		ma.ca_ProposerAddress.m = &ma.cm
		return &ma.ca_ProposerAddress
	default:
		panic("unreachable")
	}
}
func (ma *_Header__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Header_sufficient != fieldBits__Header_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Header_Version == 0 {
			err.Missing = append(err.Missing, "Version")
		}
		if ma.s&fieldBit__Header_ChainID == 0 {
			err.Missing = append(err.Missing, "ChainID")
		}
		if ma.s&fieldBit__Header_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Header_Time == 0 {
			err.Missing = append(err.Missing, "Time")
		}
		if ma.s&fieldBit__Header_LastBlockID == 0 {
			err.Missing = append(err.Missing, "LastBlockID")
		}
		if ma.s&fieldBit__Header_LastCommitHash == 0 {
			err.Missing = append(err.Missing, "LastCommitHash")
		}
		if ma.s&fieldBit__Header_DataHash == 0 {
			err.Missing = append(err.Missing, "DataHash")
		}
		if ma.s&fieldBit__Header_ValidatorsHash == 0 {
			err.Missing = append(err.Missing, "ValidatorsHash")
		}
		if ma.s&fieldBit__Header_NextValidatorsHash == 0 {
			err.Missing = append(err.Missing, "NextValidatorsHash")
		}
		if ma.s&fieldBit__Header_ConsensusHash == 0 {
			err.Missing = append(err.Missing, "ConsensusHash")
		}
		if ma.s&fieldBit__Header_AppHash == 0 {
			err.Missing = append(err.Missing, "AppHash")
		}
		if ma.s&fieldBit__Header_LastResultsHash == 0 {
			err.Missing = append(err.Missing, "LastResultsHash")
		}
		if ma.s&fieldBit__Header_EvidenceHash == 0 {
			err.Missing = append(err.Missing, "EvidenceHash")
		}
		if ma.s&fieldBit__Header_ProposerAddress == 0 {
			err.Missing = append(err.Missing, "ProposerAddress")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Header__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Header__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Header__ReprKeyAssembler _Header__ReprAssembler

func (_Header__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Header__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Header__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignNull()
}
func (_Header__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Header__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Header__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Header__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Version":
		if ka.s&fieldBit__Header_Version != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Version_serial}
		}
		ka.s += fieldBit__Header_Version
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "ChainID":
		if ka.s&fieldBit__Header_ChainID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ChainID_serial}
		}
		ka.s += fieldBit__Header_ChainID
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Height":
		if ka.s&fieldBit__Header_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Height_serial}
		}
		ka.s += fieldBit__Header_Height
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Time":
		if ka.s&fieldBit__Header_Time != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time_serial}
		}
		ka.s += fieldBit__Header_Time
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "LastBlockID":
		if ka.s&fieldBit__Header_LastBlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastBlockID_serial}
		}
		ka.s += fieldBit__Header_LastBlockID
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "LastCommitHash":
		if ka.s&fieldBit__Header_LastCommitHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastCommitHash_serial}
		}
		ka.s += fieldBit__Header_LastCommitHash
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "DataHash":
		if ka.s&fieldBit__Header_DataHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_DataHash_serial}
		}
		ka.s += fieldBit__Header_DataHash
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	case "ValidatorsHash":
		if ka.s&fieldBit__Header_ValidatorsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ValidatorsHash_serial}
		}
		ka.s += fieldBit__Header_ValidatorsHash
		ka.state = maState_expectValue
		ka.f = 7
		return nil
	case "NextValidatorsHash":
		if ka.s&fieldBit__Header_NextValidatorsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_NextValidatorsHash_serial}
		}
		ka.s += fieldBit__Header_NextValidatorsHash
		ka.state = maState_expectValue
		ka.f = 8
		return nil
	case "ConsensusHash":
		if ka.s&fieldBit__Header_ConsensusHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ConsensusHash_serial}
		}
		ka.s += fieldBit__Header_ConsensusHash
		ka.state = maState_expectValue
		ka.f = 9
		return nil
	case "AppHash":
		if ka.s&fieldBit__Header_AppHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_AppHash_serial}
		}
		ka.s += fieldBit__Header_AppHash
		ka.state = maState_expectValue
		ka.f = 10
		return nil
	case "LastResultsHash":
		if ka.s&fieldBit__Header_LastResultsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastResultsHash_serial}
		}
		ka.s += fieldBit__Header_LastResultsHash
		ka.state = maState_expectValue
		ka.f = 11
		return nil
	case "EvidenceHash":
		if ka.s&fieldBit__Header_EvidenceHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_EvidenceHash_serial}
		}
		ka.s += fieldBit__Header_EvidenceHash
		ka.state = maState_expectValue
		ka.f = 12
		return nil
	case "ProposerAddress":
		if ka.s&fieldBit__Header_ProposerAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ProposerAddress_serial}
		}
		ka.s += fieldBit__Header_ProposerAddress
		ka.state = maState_expectValue
		ka.f = 13
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Header.Repr", Key: &_String{k}}
}
func (_Header__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Header__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Header__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Header__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n HexBytes) Bytes() []byte {
	return n.x
}
func (_HexBytes__Prototype) FromBytes(v []byte) (HexBytes, error) {
	n := _HexBytes{v}
	return &n, nil
}

type _HexBytes__Maybe struct {
	m schema.Maybe
	v HexBytes
}
type MaybeHexBytes = *_HexBytes__Maybe

func (m MaybeHexBytes) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHexBytes) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHexBytes) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHexBytes) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHexBytes) Must() HexBytes {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (HexBytes)(&_HexBytes{})
var _ schema.TypedNode = (HexBytes)(&_HexBytes{})

func (HexBytes) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (HexBytes) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.LookupByString("")
}
func (HexBytes) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.LookupByNode(nil)
}
func (HexBytes) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.LookupByIndex(0)
}
func (HexBytes) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.LookupBySegment(seg)
}
func (HexBytes) MapIterator() ipld.MapIterator {
	return nil
}
func (HexBytes) ListIterator() ipld.ListIterator {
	return nil
}
func (HexBytes) Length() int64 {
	return -1
}
func (HexBytes) IsAbsent() bool {
	return false
}
func (HexBytes) IsNull() bool {
	return false
}
func (HexBytes) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.AsBool()
}
func (HexBytes) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.AsInt()
}
func (HexBytes) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.AsFloat()
}
func (HexBytes) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.AsString()
}
func (n HexBytes) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (HexBytes) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.AsLink()
}
func (HexBytes) Prototype() ipld.NodePrototype {
	return _HexBytes__Prototype{}
}

type _HexBytes__Prototype struct{}

func (_HexBytes__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _HexBytes__Builder
	nb.Reset()
	return &nb
}

type _HexBytes__Builder struct {
	_HexBytes__Assembler
}

func (nb *_HexBytes__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_HexBytes__Builder) Reset() {
	var w _HexBytes
	var m schema.Maybe
	*nb = _HexBytes__Builder{_HexBytes__Assembler{w: &w, m: &m}}
}

type _HexBytes__Assembler struct {
	w *_HexBytes
	m *schema.Maybe
}

func (na *_HexBytes__Assembler) reset() {}
func (_HexBytes__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.BeginMap(0)
}
func (_HexBytes__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.BeginList(0)
}
func (na *_HexBytes__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_HexBytes__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignBool(false)
}
func (_HexBytes__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignInt(0)
}
func (_HexBytes__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignFloat(0)
}
func (_HexBytes__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignString("")
}
func (na *_HexBytes__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_HexBytes{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_HexBytes__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignLink(nil)
}
func (na *_HexBytes__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_HexBytes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_HexBytes__Assembler) Prototype() ipld.NodePrototype {
	return _HexBytes__Prototype{}
}
func (HexBytes) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n HexBytes) Representation() ipld.Node {
	return (*_HexBytes__Repr)(n)
}

type _HexBytes__Repr = _HexBytes

var _ ipld.Node = &_HexBytes__Repr{}

type _HexBytes__ReprPrototype = _HexBytes__Prototype
type _HexBytes__ReprAssembler = _HexBytes__Assembler

func (n _IAVLInnerNode) FieldLeft() MaybeLink {
	return &n.Left
}
func (n _IAVLInnerNode) FieldRight() MaybeLink {
	return &n.Right
}
func (n _IAVLInnerNode) FieldVersion() Int {
	return &n.Version
}
func (n _IAVLInnerNode) FieldSize() Int {
	return &n.Size
}
func (n _IAVLInnerNode) FieldHeight() Int {
	return &n.Height
}

type _IAVLInnerNode__Maybe struct {
	m schema.Maybe
	v IAVLInnerNode
}
type MaybeIAVLInnerNode = *_IAVLInnerNode__Maybe

func (m MaybeIAVLInnerNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeIAVLInnerNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeIAVLInnerNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeIAVLInnerNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeIAVLInnerNode) Must() IAVLInnerNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__IAVLInnerNode_Left    = _String{"Left"}
	fieldName__IAVLInnerNode_Right   = _String{"Right"}
	fieldName__IAVLInnerNode_Version = _String{"Version"}
	fieldName__IAVLInnerNode_Size    = _String{"Size"}
	fieldName__IAVLInnerNode_Height  = _String{"Height"}
)
var _ ipld.Node = (IAVLInnerNode)(&_IAVLInnerNode{})
var _ schema.TypedNode = (IAVLInnerNode)(&_IAVLInnerNode{})

func (IAVLInnerNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n IAVLInnerNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Left":
		if n.Left.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Left.v, nil
	case "Right":
		if n.Right.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Right.v, nil
	case "Version":
		return &n.Version, nil
	case "Size":
		return &n.Size, nil
	case "Height":
		return &n.Height, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n IAVLInnerNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (IAVLInnerNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode"}.LookupByIndex(0)
}
func (n IAVLInnerNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n IAVLInnerNode) MapIterator() ipld.MapIterator {
	return &_IAVLInnerNode__MapItr{n, 0}
}

type _IAVLInnerNode__MapItr struct {
	n   IAVLInnerNode
	idx int
}

func (itr *_IAVLInnerNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__IAVLInnerNode_Left
		if itr.n.Left.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Left.v
	case 1:
		k = &fieldName__IAVLInnerNode_Right
		if itr.n.Right.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Right.v
	case 2:
		k = &fieldName__IAVLInnerNode_Version
		v = &itr.n.Version
	case 3:
		k = &fieldName__IAVLInnerNode_Size
		v = &itr.n.Size
	case 4:
		k = &fieldName__IAVLInnerNode_Height
		v = &itr.n.Height
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_IAVLInnerNode__MapItr) Done() bool {
	return itr.idx >= 5
}

func (IAVLInnerNode) ListIterator() ipld.ListIterator {
	return nil
}
func (IAVLInnerNode) Length() int64 {
	return 5
}
func (IAVLInnerNode) IsAbsent() bool {
	return false
}
func (IAVLInnerNode) IsNull() bool {
	return false
}
func (IAVLInnerNode) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode"}.AsBool()
}
func (IAVLInnerNode) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode"}.AsInt()
}
func (IAVLInnerNode) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode"}.AsFloat()
}
func (IAVLInnerNode) AsString() (string, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode"}.AsString()
}
func (IAVLInnerNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode"}.AsBytes()
}
func (IAVLInnerNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode"}.AsLink()
}
func (IAVLInnerNode) Prototype() ipld.NodePrototype {
	return _IAVLInnerNode__Prototype{}
}

type _IAVLInnerNode__Prototype struct{}

func (_IAVLInnerNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _IAVLInnerNode__Builder
	nb.Reset()
	return &nb
}

type _IAVLInnerNode__Builder struct {
	_IAVLInnerNode__Assembler
}

func (nb *_IAVLInnerNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_IAVLInnerNode__Builder) Reset() {
	var w _IAVLInnerNode
	var m schema.Maybe
	*nb = _IAVLInnerNode__Builder{_IAVLInnerNode__Assembler{w: &w, m: &m}}
}

type _IAVLInnerNode__Assembler struct {
	w     *_IAVLInnerNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm         schema.Maybe
	ca_Left    _Link__Assembler
	ca_Right   _Link__Assembler
	ca_Version _Int__Assembler
	ca_Size    _Int__Assembler
	ca_Height  _Int__Assembler
}

func (na *_IAVLInnerNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Left.reset()
	na.ca_Right.reset()
	na.ca_Version.reset()
	na.ca_Size.reset()
	na.ca_Height.reset()
}

var (
	fieldBit__IAVLInnerNode_Left        = 1 << 0
	fieldBit__IAVLInnerNode_Right       = 1 << 1
	fieldBit__IAVLInnerNode_Version     = 1 << 2
	fieldBit__IAVLInnerNode_Size        = 1 << 3
	fieldBit__IAVLInnerNode_Height      = 1 << 4
	fieldBits__IAVLInnerNode_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4
)

func (na *_IAVLInnerNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_IAVLInnerNode{}
	}
	return na, nil
}
func (_IAVLInnerNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode"}.BeginList(0)
}
func (na *_IAVLInnerNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.IAVLInnerNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_IAVLInnerNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode"}.AssignBool(false)
}
func (_IAVLInnerNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode"}.AssignInt(0)
}
func (_IAVLInnerNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode"}.AssignFloat(0)
}
func (_IAVLInnerNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode"}.AssignString("")
}
func (_IAVLInnerNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode"}.AssignBytes(nil)
}
func (_IAVLInnerNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode"}.AssignLink(nil)
}
func (na *_IAVLInnerNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_IAVLInnerNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.IAVLInnerNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_IAVLInnerNode__Assembler) Prototype() ipld.NodePrototype {
	return _IAVLInnerNode__Prototype{}
}
func (ma *_IAVLInnerNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Left.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Left.v = ma.ca_Left.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.Right.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Right.v = ma.ca_Right.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Version.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Size.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Height.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_IAVLInnerNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Left":
		if ma.s&fieldBit__IAVLInnerNode_Left != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Left}
		}
		ma.s += fieldBit__IAVLInnerNode_Left
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left, nil
	case "Right":
		if ma.s&fieldBit__IAVLInnerNode_Right != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Right}
		}
		ma.s += fieldBit__IAVLInnerNode_Right
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right, nil
	case "Version":
		if ma.s&fieldBit__IAVLInnerNode_Version != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Version}
		}
		ma.s += fieldBit__IAVLInnerNode_Version
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version, nil
	case "Size":
		if ma.s&fieldBit__IAVLInnerNode_Size != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Size}
		}
		ma.s += fieldBit__IAVLInnerNode_Size
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size, nil
	case "Height":
		if ma.s&fieldBit__IAVLInnerNode_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Height}
		}
		ma.s += fieldBit__IAVLInnerNode_Height
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLInnerNode", Key: &_String{k}}
}
func (ma *_IAVLInnerNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_IAVLInnerNode__KeyAssembler)(ma)
}
func (ma *_IAVLInnerNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left
	case 1:
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right
	case 2:
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version
	case 3:
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size
	case 4:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	default:
		panic("unreachable")
	}
}
func (ma *_IAVLInnerNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__IAVLInnerNode_sufficient != fieldBits__IAVLInnerNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__IAVLInnerNode_Version == 0 {
			err.Missing = append(err.Missing, "Version")
		}
		if ma.s&fieldBit__IAVLInnerNode_Size == 0 {
			err.Missing = append(err.Missing, "Size")
		}
		if ma.s&fieldBit__IAVLInnerNode_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_IAVLInnerNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_IAVLInnerNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _IAVLInnerNode__KeyAssembler _IAVLInnerNode__Assembler

func (_IAVLInnerNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.KeyAssembler"}.BeginMap(0)
}
func (_IAVLInnerNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.KeyAssembler"}.BeginList(0)
}
func (na *_IAVLInnerNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.KeyAssembler"}.AssignNull()
}
func (_IAVLInnerNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.KeyAssembler"}.AssignBool(false)
}
func (_IAVLInnerNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.KeyAssembler"}.AssignInt(0)
}
func (_IAVLInnerNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_IAVLInnerNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Left":
		if ka.s&fieldBit__IAVLInnerNode_Left != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Left}
		}
		ka.s += fieldBit__IAVLInnerNode_Left
		ka.state = maState_expectValue
		ka.f = 0
	case "Right":
		if ka.s&fieldBit__IAVLInnerNode_Right != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Right}
		}
		ka.s += fieldBit__IAVLInnerNode_Right
		ka.state = maState_expectValue
		ka.f = 1
	case "Version":
		if ka.s&fieldBit__IAVLInnerNode_Version != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Version}
		}
		ka.s += fieldBit__IAVLInnerNode_Version
		ka.state = maState_expectValue
		ka.f = 2
	case "Size":
		if ka.s&fieldBit__IAVLInnerNode_Size != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Size}
		}
		ka.s += fieldBit__IAVLInnerNode_Size
		ka.state = maState_expectValue
		ka.f = 3
	case "Height":
		if ka.s&fieldBit__IAVLInnerNode_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Height}
		}
		ka.s += fieldBit__IAVLInnerNode_Height
		ka.state = maState_expectValue
		ka.f = 4
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLInnerNode", Key: &_String{k}}
	}
	return nil
}
func (_IAVLInnerNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.KeyAssembler"}.AssignBytes(nil)
}
func (_IAVLInnerNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_IAVLInnerNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_IAVLInnerNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (IAVLInnerNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n IAVLInnerNode) Representation() ipld.Node {
	return (*_IAVLInnerNode__Repr)(n)
}

type _IAVLInnerNode__Repr _IAVLInnerNode

var (
	fieldName__IAVLInnerNode_Left_serial    = _String{"Left"}
	fieldName__IAVLInnerNode_Right_serial   = _String{"Right"}
	fieldName__IAVLInnerNode_Version_serial = _String{"Version"}
	fieldName__IAVLInnerNode_Size_serial    = _String{"Size"}
	fieldName__IAVLInnerNode_Height_serial  = _String{"Height"}
)
var _ ipld.Node = &_IAVLInnerNode__Repr{}

func (_IAVLInnerNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_IAVLInnerNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Left":
		if n.Left.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Left.v.Representation(), nil
	case "Right":
		if n.Right.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Right.v.Representation(), nil
	case "Version":
		return n.Version.Representation(), nil
	case "Size":
		return n.Size.Representation(), nil
	case "Height":
		return n.Height.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_IAVLInnerNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_IAVLInnerNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode.Repr"}.LookupByIndex(0)
}
func (n _IAVLInnerNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_IAVLInnerNode__Repr) MapIterator() ipld.MapIterator {
	return &_IAVLInnerNode__ReprMapItr{n, 0}
}

type _IAVLInnerNode__ReprMapItr struct {
	n   *_IAVLInnerNode__Repr
	idx int
}

func (itr *_IAVLInnerNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__IAVLInnerNode_Left_serial
		if itr.n.Left.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Left.v.Representation()
	case 1:
		k = &fieldName__IAVLInnerNode_Right_serial
		if itr.n.Right.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Right.v.Representation()
	case 2:
		k = &fieldName__IAVLInnerNode_Version_serial
		v = itr.n.Version.Representation()
	case 3:
		k = &fieldName__IAVLInnerNode_Size_serial
		v = itr.n.Size.Representation()
	case 4:
		k = &fieldName__IAVLInnerNode_Height_serial
		v = itr.n.Height.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_IAVLInnerNode__ReprMapItr) Done() bool {
	return itr.idx >= 5
}
func (_IAVLInnerNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_IAVLInnerNode__Repr) Length() int64 {
	l := 5
	return int64(l)
}
func (_IAVLInnerNode__Repr) IsAbsent() bool {
	return false
}
func (_IAVLInnerNode__Repr) IsNull() bool {
	return false
}
func (_IAVLInnerNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode.Repr"}.AsBool()
}
func (_IAVLInnerNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode.Repr"}.AsInt()
}
func (_IAVLInnerNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode.Repr"}.AsFloat()
}
func (_IAVLInnerNode__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode.Repr"}.AsString()
}
func (_IAVLInnerNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode.Repr"}.AsBytes()
}
func (_IAVLInnerNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.IAVLInnerNode.Repr"}.AsLink()
}
func (_IAVLInnerNode__Repr) Prototype() ipld.NodePrototype {
	return _IAVLInnerNode__ReprPrototype{}
}

type _IAVLInnerNode__ReprPrototype struct{}

func (_IAVLInnerNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _IAVLInnerNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _IAVLInnerNode__ReprBuilder struct {
	_IAVLInnerNode__ReprAssembler
}

func (nb *_IAVLInnerNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_IAVLInnerNode__ReprBuilder) Reset() {
	var w _IAVLInnerNode
	var m schema.Maybe
	*nb = _IAVLInnerNode__ReprBuilder{_IAVLInnerNode__ReprAssembler{w: &w, m: &m}}
}

type _IAVLInnerNode__ReprAssembler struct {
	w     *_IAVLInnerNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm         schema.Maybe
	ca_Left    _Link__ReprAssembler
	ca_Right   _Link__ReprAssembler
	ca_Version _Int__ReprAssembler
	ca_Size    _Int__ReprAssembler
	ca_Height  _Int__ReprAssembler
}

func (na *_IAVLInnerNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Left.reset()
	na.ca_Right.reset()
	na.ca_Version.reset()
	na.ca_Size.reset()
	na.ca_Height.reset()
}
func (na *_IAVLInnerNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_IAVLInnerNode{}
	}
	return na, nil
}
func (_IAVLInnerNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode.Repr"}.BeginList(0)
}
func (na *_IAVLInnerNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.IAVLInnerNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_IAVLInnerNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode.Repr"}.AssignBool(false)
}
func (_IAVLInnerNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode.Repr"}.AssignInt(0)
}
func (_IAVLInnerNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode.Repr"}.AssignFloat(0)
}
func (_IAVLInnerNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode.Repr"}.AssignString("")
}
func (_IAVLInnerNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode.Repr"}.AssignBytes(nil)
}
func (_IAVLInnerNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.IAVLInnerNode.Repr"}.AssignLink(nil)
}
func (na *_IAVLInnerNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_IAVLInnerNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.IAVLInnerNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_IAVLInnerNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _IAVLInnerNode__ReprPrototype{}
}
func (ma *_IAVLInnerNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Left.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Left.v = ma.ca_Left.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.Right.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Right.v = ma.ca_Right.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_IAVLInnerNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Left":
		if ma.s&fieldBit__IAVLInnerNode_Left != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Left_serial}
		}
		ma.s += fieldBit__IAVLInnerNode_Left
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left, nil
	case "Right":
		if ma.s&fieldBit__IAVLInnerNode_Right != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Right_serial}
		}
		ma.s += fieldBit__IAVLInnerNode_Right
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right, nil
	case "Version":
		if ma.s&fieldBit__IAVLInnerNode_Version != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Version_serial}
		}
		ma.s += fieldBit__IAVLInnerNode_Version
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version, nil
	case "Size":
		if ma.s&fieldBit__IAVLInnerNode_Size != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Size_serial}
		}
		ma.s += fieldBit__IAVLInnerNode_Size
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size, nil
	case "Height":
		if ma.s&fieldBit__IAVLInnerNode_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Height_serial}
		}
		ma.s += fieldBit__IAVLInnerNode_Height
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLInnerNode.Repr", Key: &_String{k}}
}
func (ma *_IAVLInnerNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_IAVLInnerNode__ReprKeyAssembler)(ma)
}
func (ma *_IAVLInnerNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left
	case 1:
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right
	case 2:
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version
	case 3:
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size
	case 4:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	default:
		panic("unreachable")
	}
}
func (ma *_IAVLInnerNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__IAVLInnerNode_sufficient != fieldBits__IAVLInnerNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__IAVLInnerNode_Version == 0 {
			err.Missing = append(err.Missing, "Version")
		}
		if ma.s&fieldBit__IAVLInnerNode_Size == 0 {
			err.Missing = append(err.Missing, "Size")
		}
		if ma.s&fieldBit__IAVLInnerNode_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_IAVLInnerNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_IAVLInnerNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _IAVLInnerNode__ReprKeyAssembler _IAVLInnerNode__ReprAssembler

func (_IAVLInnerNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_IAVLInnerNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_IAVLInnerNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.Repr.KeyAssembler"}.AssignNull()
}
func (_IAVLInnerNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_IAVLInnerNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_IAVLInnerNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_IAVLInnerNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Left":
		if ka.s&fieldBit__IAVLInnerNode_Left != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Left_serial}
		}
		ka.s += fieldBit__IAVLInnerNode_Left
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Right":
		if ka.s&fieldBit__IAVLInnerNode_Right != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Right_serial}
		}
		ka.s += fieldBit__IAVLInnerNode_Right
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Version":
		if ka.s&fieldBit__IAVLInnerNode_Version != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Version_serial}
		}
		ka.s += fieldBit__IAVLInnerNode_Version
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Size":
		if ka.s&fieldBit__IAVLInnerNode_Size != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Size_serial}
		}
		ka.s += fieldBit__IAVLInnerNode_Size
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Height":
		if ka.s&fieldBit__IAVLInnerNode_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLInnerNode_Height_serial}
		}
		ka.s += fieldBit__IAVLInnerNode_Height
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLInnerNode.Repr", Key: &_String{k}}
}
func (_IAVLInnerNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_IAVLInnerNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.IAVLInnerNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_IAVLInnerNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_IAVLInnerNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _IAVLLeafNode) FieldKey() Bytes {
	return &n.Key
}
func (n _IAVLLeafNode) FieldValue() Bytes {
	return &n.Value
}
func (n _IAVLLeafNode) FieldVersion() Int {
	return &n.Version
}
func (n _IAVLLeafNode) FieldSize() Int {
	return &n.Size
}
func (n _IAVLLeafNode) FieldHeight() Int {
	return &n.Height
}

type _IAVLLeafNode__Maybe struct {
	m schema.Maybe
	v IAVLLeafNode
}
type MaybeIAVLLeafNode = *_IAVLLeafNode__Maybe

func (m MaybeIAVLLeafNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeIAVLLeafNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeIAVLLeafNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeIAVLLeafNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeIAVLLeafNode) Must() IAVLLeafNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__IAVLLeafNode_Key     = _String{"Key"}
	fieldName__IAVLLeafNode_Value   = _String{"Value"}
	fieldName__IAVLLeafNode_Version = _String{"Version"}
	fieldName__IAVLLeafNode_Size    = _String{"Size"}
	fieldName__IAVLLeafNode_Height  = _String{"Height"}
)
var _ ipld.Node = (IAVLLeafNode)(&_IAVLLeafNode{})
var _ schema.TypedNode = (IAVLLeafNode)(&_IAVLLeafNode{})

func (IAVLLeafNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n IAVLLeafNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Key":
		return &n.Key, nil
	case "Value":
		return &n.Value, nil
	case "Version":
		return &n.Version, nil
	case "Size":
		return &n.Size, nil
	case "Height":
		return &n.Height, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n IAVLLeafNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (IAVLLeafNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode"}.LookupByIndex(0)
}
func (n IAVLLeafNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n IAVLLeafNode) MapIterator() ipld.MapIterator {
	return &_IAVLLeafNode__MapItr{n, 0}
}

type _IAVLLeafNode__MapItr struct {
	n   IAVLLeafNode
	idx int
}

func (itr *_IAVLLeafNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__IAVLLeafNode_Key
		v = &itr.n.Key
	case 1:
		k = &fieldName__IAVLLeafNode_Value
		v = &itr.n.Value
	case 2:
		k = &fieldName__IAVLLeafNode_Version
		v = &itr.n.Version
	case 3:
		k = &fieldName__IAVLLeafNode_Size
		v = &itr.n.Size
	case 4:
		k = &fieldName__IAVLLeafNode_Height
		v = &itr.n.Height
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_IAVLLeafNode__MapItr) Done() bool {
	return itr.idx >= 5
}

func (IAVLLeafNode) ListIterator() ipld.ListIterator {
	return nil
}
func (IAVLLeafNode) Length() int64 {
	return 5
}
func (IAVLLeafNode) IsAbsent() bool {
	return false
}
func (IAVLLeafNode) IsNull() bool {
	return false
}
func (IAVLLeafNode) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode"}.AsBool()
}
func (IAVLLeafNode) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode"}.AsInt()
}
func (IAVLLeafNode) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode"}.AsFloat()
}
func (IAVLLeafNode) AsString() (string, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode"}.AsString()
}
func (IAVLLeafNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode"}.AsBytes()
}
func (IAVLLeafNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode"}.AsLink()
}
func (IAVLLeafNode) Prototype() ipld.NodePrototype {
	return _IAVLLeafNode__Prototype{}
}

type _IAVLLeafNode__Prototype struct{}

func (_IAVLLeafNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _IAVLLeafNode__Builder
	nb.Reset()
	return &nb
}

type _IAVLLeafNode__Builder struct {
	_IAVLLeafNode__Assembler
}

func (nb *_IAVLLeafNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_IAVLLeafNode__Builder) Reset() {
	var w _IAVLLeafNode
	var m schema.Maybe
	*nb = _IAVLLeafNode__Builder{_IAVLLeafNode__Assembler{w: &w, m: &m}}
}

type _IAVLLeafNode__Assembler struct {
	w     *_IAVLLeafNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm         schema.Maybe
	ca_Key     _Bytes__Assembler
	ca_Value   _Bytes__Assembler
	ca_Version _Int__Assembler
	ca_Size    _Int__Assembler
	ca_Height  _Int__Assembler
}

func (na *_IAVLLeafNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Key.reset()
	na.ca_Value.reset()
	na.ca_Version.reset()
	na.ca_Size.reset()
	na.ca_Height.reset()
}

var (
	fieldBit__IAVLLeafNode_Key         = 1 << 0
	fieldBit__IAVLLeafNode_Value       = 1 << 1
	fieldBit__IAVLLeafNode_Version     = 1 << 2
	fieldBit__IAVLLeafNode_Size        = 1 << 3
	fieldBit__IAVLLeafNode_Height      = 1 << 4
	fieldBits__IAVLLeafNode_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4
)

func (na *_IAVLLeafNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_IAVLLeafNode{}
	}
	return na, nil
}
func (_IAVLLeafNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode"}.BeginList(0)
}
func (na *_IAVLLeafNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.IAVLLeafNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_IAVLLeafNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode"}.AssignBool(false)
}
func (_IAVLLeafNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode"}.AssignInt(0)
}
func (_IAVLLeafNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode"}.AssignFloat(0)
}
func (_IAVLLeafNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode"}.AssignString("")
}
func (_IAVLLeafNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode"}.AssignBytes(nil)
}
func (_IAVLLeafNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode"}.AssignLink(nil)
}
func (na *_IAVLLeafNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_IAVLLeafNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.IAVLLeafNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_IAVLLeafNode__Assembler) Prototype() ipld.NodePrototype {
	return _IAVLLeafNode__Prototype{}
}
func (ma *_IAVLLeafNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Key.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Value.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Version.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Size.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Height.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_IAVLLeafNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Key":
		if ma.s&fieldBit__IAVLLeafNode_Key != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Key}
		}
		ma.s += fieldBit__IAVLLeafNode_Key
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Key.w = &ma.w.Key
		ma.ca_Key.m = &ma.cm
		return &ma.ca_Key, nil
	case "Value":
		if ma.s&fieldBit__IAVLLeafNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Value}
		}
		ma.s += fieldBit__IAVLLeafNode_Value
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	case "Version":
		if ma.s&fieldBit__IAVLLeafNode_Version != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Version}
		}
		ma.s += fieldBit__IAVLLeafNode_Version
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version, nil
	case "Size":
		if ma.s&fieldBit__IAVLLeafNode_Size != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Size}
		}
		ma.s += fieldBit__IAVLLeafNode_Size
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size, nil
	case "Height":
		if ma.s&fieldBit__IAVLLeafNode_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Height}
		}
		ma.s += fieldBit__IAVLLeafNode_Height
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLLeafNode", Key: &_String{k}}
}
func (ma *_IAVLLeafNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_IAVLLeafNode__KeyAssembler)(ma)
}
func (ma *_IAVLLeafNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Key.w = &ma.w.Key
		ma.ca_Key.m = &ma.cm
		return &ma.ca_Key
	case 1:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	case 2:
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version
	case 3:
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size
	case 4:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	default:
		panic("unreachable")
	}
}
func (ma *_IAVLLeafNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__IAVLLeafNode_sufficient != fieldBits__IAVLLeafNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__IAVLLeafNode_Key == 0 {
			err.Missing = append(err.Missing, "Key")
		}
		if ma.s&fieldBit__IAVLLeafNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		if ma.s&fieldBit__IAVLLeafNode_Version == 0 {
			err.Missing = append(err.Missing, "Version")
		}
		if ma.s&fieldBit__IAVLLeafNode_Size == 0 {
			err.Missing = append(err.Missing, "Size")
		}
		if ma.s&fieldBit__IAVLLeafNode_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_IAVLLeafNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_IAVLLeafNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _IAVLLeafNode__KeyAssembler _IAVLLeafNode__Assembler

func (_IAVLLeafNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.KeyAssembler"}.BeginMap(0)
}
func (_IAVLLeafNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.KeyAssembler"}.BeginList(0)
}
func (na *_IAVLLeafNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.KeyAssembler"}.AssignNull()
}
func (_IAVLLeafNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.KeyAssembler"}.AssignBool(false)
}
func (_IAVLLeafNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.KeyAssembler"}.AssignInt(0)
}
func (_IAVLLeafNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_IAVLLeafNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Key":
		if ka.s&fieldBit__IAVLLeafNode_Key != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Key}
		}
		ka.s += fieldBit__IAVLLeafNode_Key
		ka.state = maState_expectValue
		ka.f = 0
	case "Value":
		if ka.s&fieldBit__IAVLLeafNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Value}
		}
		ka.s += fieldBit__IAVLLeafNode_Value
		ka.state = maState_expectValue
		ka.f = 1
	case "Version":
		if ka.s&fieldBit__IAVLLeafNode_Version != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Version}
		}
		ka.s += fieldBit__IAVLLeafNode_Version
		ka.state = maState_expectValue
		ka.f = 2
	case "Size":
		if ka.s&fieldBit__IAVLLeafNode_Size != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Size}
		}
		ka.s += fieldBit__IAVLLeafNode_Size
		ka.state = maState_expectValue
		ka.f = 3
	case "Height":
		if ka.s&fieldBit__IAVLLeafNode_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Height}
		}
		ka.s += fieldBit__IAVLLeafNode_Height
		ka.state = maState_expectValue
		ka.f = 4
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLLeafNode", Key: &_String{k}}
	}
	return nil
}
func (_IAVLLeafNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.KeyAssembler"}.AssignBytes(nil)
}
func (_IAVLLeafNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_IAVLLeafNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_IAVLLeafNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (IAVLLeafNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n IAVLLeafNode) Representation() ipld.Node {
	return (*_IAVLLeafNode__Repr)(n)
}

type _IAVLLeafNode__Repr _IAVLLeafNode

var (
	fieldName__IAVLLeafNode_Key_serial     = _String{"Key"}
	fieldName__IAVLLeafNode_Value_serial   = _String{"Value"}
	fieldName__IAVLLeafNode_Version_serial = _String{"Version"}
	fieldName__IAVLLeafNode_Size_serial    = _String{"Size"}
	fieldName__IAVLLeafNode_Height_serial  = _String{"Height"}
)
var _ ipld.Node = &_IAVLLeafNode__Repr{}

func (_IAVLLeafNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_IAVLLeafNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Key":
		return n.Key.Representation(), nil
	case "Value":
		return n.Value.Representation(), nil
	case "Version":
		return n.Version.Representation(), nil
	case "Size":
		return n.Size.Representation(), nil
	case "Height":
		return n.Height.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_IAVLLeafNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_IAVLLeafNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode.Repr"}.LookupByIndex(0)
}
func (n _IAVLLeafNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_IAVLLeafNode__Repr) MapIterator() ipld.MapIterator {
	return &_IAVLLeafNode__ReprMapItr{n, 0}
}

type _IAVLLeafNode__ReprMapItr struct {
	n   *_IAVLLeafNode__Repr
	idx int
}

func (itr *_IAVLLeafNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__IAVLLeafNode_Key_serial
		v = itr.n.Key.Representation()
	case 1:
		k = &fieldName__IAVLLeafNode_Value_serial
		v = itr.n.Value.Representation()
	case 2:
		k = &fieldName__IAVLLeafNode_Version_serial
		v = itr.n.Version.Representation()
	case 3:
		k = &fieldName__IAVLLeafNode_Size_serial
		v = itr.n.Size.Representation()
	case 4:
		k = &fieldName__IAVLLeafNode_Height_serial
		v = itr.n.Height.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_IAVLLeafNode__ReprMapItr) Done() bool {
	return itr.idx >= 5
}
func (_IAVLLeafNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_IAVLLeafNode__Repr) Length() int64 {
	l := 5
	return int64(l)
}
func (_IAVLLeafNode__Repr) IsAbsent() bool {
	return false
}
func (_IAVLLeafNode__Repr) IsNull() bool {
	return false
}
func (_IAVLLeafNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode.Repr"}.AsBool()
}
func (_IAVLLeafNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode.Repr"}.AsInt()
}
func (_IAVLLeafNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode.Repr"}.AsFloat()
}
func (_IAVLLeafNode__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode.Repr"}.AsString()
}
func (_IAVLLeafNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode.Repr"}.AsBytes()
}
func (_IAVLLeafNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.IAVLLeafNode.Repr"}.AsLink()
}
func (_IAVLLeafNode__Repr) Prototype() ipld.NodePrototype {
	return _IAVLLeafNode__ReprPrototype{}
}

type _IAVLLeafNode__ReprPrototype struct{}

func (_IAVLLeafNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _IAVLLeafNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _IAVLLeafNode__ReprBuilder struct {
	_IAVLLeafNode__ReprAssembler
}

func (nb *_IAVLLeafNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_IAVLLeafNode__ReprBuilder) Reset() {
	var w _IAVLLeafNode
	var m schema.Maybe
	*nb = _IAVLLeafNode__ReprBuilder{_IAVLLeafNode__ReprAssembler{w: &w, m: &m}}
}

type _IAVLLeafNode__ReprAssembler struct {
	w     *_IAVLLeafNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm         schema.Maybe
	ca_Key     _Bytes__ReprAssembler
	ca_Value   _Bytes__ReprAssembler
	ca_Version _Int__ReprAssembler
	ca_Size    _Int__ReprAssembler
	ca_Height  _Int__ReprAssembler
}

func (na *_IAVLLeafNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Key.reset()
	na.ca_Value.reset()
	na.ca_Version.reset()
	na.ca_Size.reset()
	na.ca_Height.reset()
}
func (na *_IAVLLeafNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_IAVLLeafNode{}
	}
	return na, nil
}
func (_IAVLLeafNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode.Repr"}.BeginList(0)
}
func (na *_IAVLLeafNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.IAVLLeafNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_IAVLLeafNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode.Repr"}.AssignBool(false)
}
func (_IAVLLeafNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode.Repr"}.AssignInt(0)
}
func (_IAVLLeafNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode.Repr"}.AssignFloat(0)
}
func (_IAVLLeafNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode.Repr"}.AssignString("")
}
func (_IAVLLeafNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode.Repr"}.AssignBytes(nil)
}
func (_IAVLLeafNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.IAVLLeafNode.Repr"}.AssignLink(nil)
}
func (na *_IAVLLeafNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_IAVLLeafNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.IAVLLeafNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_IAVLLeafNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _IAVLLeafNode__ReprPrototype{}
}
func (ma *_IAVLLeafNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_IAVLLeafNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Key":
		if ma.s&fieldBit__IAVLLeafNode_Key != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Key_serial}
		}
		ma.s += fieldBit__IAVLLeafNode_Key
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Key.w = &ma.w.Key
		ma.ca_Key.m = &ma.cm
		return &ma.ca_Key, nil
	case "Value":
		if ma.s&fieldBit__IAVLLeafNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Value_serial}
		}
		ma.s += fieldBit__IAVLLeafNode_Value
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	case "Version":
		if ma.s&fieldBit__IAVLLeafNode_Version != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Version_serial}
		}
		ma.s += fieldBit__IAVLLeafNode_Version
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version, nil
	case "Size":
		if ma.s&fieldBit__IAVLLeafNode_Size != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Size_serial}
		}
		ma.s += fieldBit__IAVLLeafNode_Size
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size, nil
	case "Height":
		if ma.s&fieldBit__IAVLLeafNode_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Height_serial}
		}
		ma.s += fieldBit__IAVLLeafNode_Height
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLLeafNode.Repr", Key: &_String{k}}
}
func (ma *_IAVLLeafNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_IAVLLeafNode__ReprKeyAssembler)(ma)
}
func (ma *_IAVLLeafNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Key.w = &ma.w.Key
		ma.ca_Key.m = &ma.cm
		return &ma.ca_Key
	case 1:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	case 2:
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version
	case 3:
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size
	case 4:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	default:
		panic("unreachable")
	}
}
func (ma *_IAVLLeafNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__IAVLLeafNode_sufficient != fieldBits__IAVLLeafNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__IAVLLeafNode_Key == 0 {
			err.Missing = append(err.Missing, "Key")
		}
		if ma.s&fieldBit__IAVLLeafNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		if ma.s&fieldBit__IAVLLeafNode_Version == 0 {
			err.Missing = append(err.Missing, "Version")
		}
		if ma.s&fieldBit__IAVLLeafNode_Size == 0 {
			err.Missing = append(err.Missing, "Size")
		}
		if ma.s&fieldBit__IAVLLeafNode_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_IAVLLeafNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_IAVLLeafNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _IAVLLeafNode__ReprKeyAssembler _IAVLLeafNode__ReprAssembler

func (_IAVLLeafNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_IAVLLeafNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_IAVLLeafNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.Repr.KeyAssembler"}.AssignNull()
}
func (_IAVLLeafNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_IAVLLeafNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_IAVLLeafNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_IAVLLeafNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Key":
		if ka.s&fieldBit__IAVLLeafNode_Key != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Key_serial}
		}
		ka.s += fieldBit__IAVLLeafNode_Key
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Value":
		if ka.s&fieldBit__IAVLLeafNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Value_serial}
		}
		ka.s += fieldBit__IAVLLeafNode_Value
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Version":
		if ka.s&fieldBit__IAVLLeafNode_Version != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Version_serial}
		}
		ka.s += fieldBit__IAVLLeafNode_Version
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Size":
		if ka.s&fieldBit__IAVLLeafNode_Size != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Size_serial}
		}
		ka.s += fieldBit__IAVLLeafNode_Size
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Height":
		if ka.s&fieldBit__IAVLLeafNode_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__IAVLLeafNode_Height_serial}
		}
		ka.s += fieldBit__IAVLLeafNode_Height
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLLeafNode.Repr", Key: &_String{k}}
}
func (_IAVLLeafNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_IAVLLeafNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.IAVLLeafNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_IAVLLeafNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_IAVLLeafNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _IAVLNode) AsInterface() _IAVLNode__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	default:
		panic("invalid union state; how did you create this object?")
	}
}

type _IAVLNode__Maybe struct {
	m schema.Maybe
	v IAVLNode
}
type MaybeIAVLNode = *_IAVLNode__Maybe

func (m MaybeIAVLNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeIAVLNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeIAVLNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeIAVLNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeIAVLNode) Must() IAVLNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	memberName__IAVLNode_IAVLInnerNode = _String{"IAVLInnerNode"}
	memberName__IAVLNode_IAVLLeafNode  = _String{"IAVLLeafNode"}
)
var _ ipld.Node = (IAVLNode)(&_IAVLNode{})
var _ schema.TypedNode = (IAVLNode)(&_IAVLNode{})

func (IAVLNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n IAVLNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "IAVLInnerNode":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "IAVLLeafNode":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n IAVLNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (IAVLNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.IAVLNode"}.LookupByIndex(0)
}
func (n IAVLNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n IAVLNode) MapIterator() ipld.MapIterator {
	return &_IAVLNode__MapItr{n, false}
}

type _IAVLNode__MapItr struct {
	n    IAVLNode
	done bool
}

func (itr *_IAVLNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__IAVLNode_IAVLInnerNode, &itr.n.x1
	case 2:
		k, v = &memberName__IAVLNode_IAVLLeafNode, &itr.n.x2
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_IAVLNode__MapItr) Done() bool {
	return itr.done
}

func (IAVLNode) ListIterator() ipld.ListIterator {
	return nil
}
func (IAVLNode) Length() int64 {
	return 1
}
func (IAVLNode) IsAbsent() bool {
	return false
}
func (IAVLNode) IsNull() bool {
	return false
}
func (IAVLNode) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.IAVLNode"}.AsBool()
}
func (IAVLNode) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.IAVLNode"}.AsInt()
}
func (IAVLNode) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.IAVLNode"}.AsFloat()
}
func (IAVLNode) AsString() (string, error) {
	return mixins.Map{"dagcosmos.IAVLNode"}.AsString()
}
func (IAVLNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.IAVLNode"}.AsBytes()
}
func (IAVLNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.IAVLNode"}.AsLink()
}
func (IAVLNode) Prototype() ipld.NodePrototype {
	return _IAVLNode__Prototype{}
}

type _IAVLNode__Prototype struct{}

func (_IAVLNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _IAVLNode__Builder
	nb.Reset()
	return &nb
}

type _IAVLNode__Builder struct {
	_IAVLNode__Assembler
}

func (nb *_IAVLNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_IAVLNode__Builder) Reset() {
	var w _IAVLNode
	var m schema.Maybe
	*nb = _IAVLNode__Builder{_IAVLNode__Assembler{w: &w, m: &m}}
}

type _IAVLNode__Assembler struct {
	w     *_IAVLNode
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _IAVLInnerNode__Assembler

	ca2 _IAVLLeafNode__Assembler
	ca  uint
}

func (na *_IAVLNode__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_IAVLNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_IAVLNode{}
	}
	return na, nil
}
func (_IAVLNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.IAVLNode"}.BeginList(0)
}
func (na *_IAVLNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.IAVLNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_IAVLNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode"}.AssignBool(false)
}
func (_IAVLNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode"}.AssignInt(0)
}
func (_IAVLNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode"}.AssignFloat(0)
}
func (_IAVLNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode"}.AssignString("")
}
func (_IAVLNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode"}.AssignBytes(nil)
}
func (_IAVLNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode"}.AssignLink(nil)
}
func (na *_IAVLNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_IAVLNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.IAVLNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_IAVLNode__Assembler) Prototype() ipld.NodePrototype {
	return _IAVLNode__Prototype{}
}
func (ma *_IAVLNode__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_IAVLNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.IAVLNode", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "IAVLInnerNode":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "IAVLLeafNode":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLNode", Key: &_String{k}}
}
func (ma *_IAVLNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_IAVLNode__KeyAssembler)(ma)
}
func (ma *_IAVLNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_IAVLNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.IAVLNode", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_IAVLNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_IAVLNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "IAVLInnerNode":
		return _IAVLInnerNode__Prototype{}
	case "IAVLLeafNode":
		return _IAVLLeafNode__Prototype{}
	default:
		return nil
	}
}

type _IAVLNode__KeyAssembler _IAVLNode__Assembler

func (_IAVLNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.KeyAssembler"}.BeginMap(0)
}
func (_IAVLNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.KeyAssembler"}.BeginList(0)
}
func (na *_IAVLNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.KeyAssembler"}.AssignNull()
}
func (_IAVLNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.KeyAssembler"}.AssignBool(false)
}
func (_IAVLNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.KeyAssembler"}.AssignInt(0)
}
func (_IAVLNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_IAVLNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.IAVLNode", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "IAVLInnerNode":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "IAVLLeafNode":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLNode", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_IAVLNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.KeyAssembler"}.AssignBytes(nil)
}
func (_IAVLNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_IAVLNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_IAVLNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (IAVLNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n IAVLNode) Representation() ipld.Node {
	return (*_IAVLNode__Repr)(n)
}

type _IAVLNode__Repr _IAVLNode

var (
	memberName__IAVLNode_IAVLInnerNode_serial = _String{"inner"}
	memberName__IAVLNode_IAVLLeafNode_serial  = _String{"leaf"}
)
var _ ipld.Node = &_IAVLNode__Repr{}

func (_IAVLNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_IAVLNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "inner":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "leaf":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_IAVLNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_IAVLNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.IAVLNode.Repr"}.LookupByIndex(0)
}
func (n _IAVLNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_IAVLNode__Repr) MapIterator() ipld.MapIterator {
	return &_IAVLNode__ReprMapItr{n, false}
}

type _IAVLNode__ReprMapItr struct {
	n    *_IAVLNode__Repr
	done bool
}

func (itr *_IAVLNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__IAVLNode_IAVLInnerNode_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__IAVLNode_IAVLLeafNode_serial, itr.n.x2.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_IAVLNode__ReprMapItr) Done() bool {
	return itr.done
}

func (_IAVLNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_IAVLNode__Repr) Length() int64 {
	return 1
}
func (_IAVLNode__Repr) IsAbsent() bool {
	return false
}
func (_IAVLNode__Repr) IsNull() bool {
	return false
}
func (_IAVLNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.IAVLNode.Repr"}.AsBool()
}
func (_IAVLNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.IAVLNode.Repr"}.AsInt()
}
func (_IAVLNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.IAVLNode.Repr"}.AsFloat()
}
func (_IAVLNode__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.IAVLNode.Repr"}.AsString()
}
func (_IAVLNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.IAVLNode.Repr"}.AsBytes()
}
func (_IAVLNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.IAVLNode.Repr"}.AsLink()
}
func (_IAVLNode__Repr) Prototype() ipld.NodePrototype {
	return _IAVLNode__ReprPrototype{}
}

type _IAVLNode__ReprPrototype struct{}

func (_IAVLNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _IAVLNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _IAVLNode__ReprBuilder struct {
	_IAVLNode__ReprAssembler
}

func (nb *_IAVLNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_IAVLNode__ReprBuilder) Reset() {
	var w _IAVLNode
	var m schema.Maybe
	*nb = _IAVLNode__ReprBuilder{_IAVLNode__ReprAssembler{w: &w, m: &m}}
}

type _IAVLNode__ReprAssembler struct {
	w     *_IAVLNode
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _IAVLInnerNode__ReprAssembler

	ca2 _IAVLLeafNode__ReprAssembler
	ca  uint
}

func (na *_IAVLNode__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_IAVLNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_IAVLNode{}
	}
	return na, nil
}
func (_IAVLNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.IAVLNode.Repr"}.BeginList(0)
}
func (na *_IAVLNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.IAVLNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_IAVLNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode.Repr"}.AssignBool(false)
}
func (_IAVLNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode.Repr"}.AssignInt(0)
}
func (_IAVLNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode.Repr"}.AssignFloat(0)
}
func (_IAVLNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode.Repr"}.AssignString("")
}
func (_IAVLNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode.Repr"}.AssignBytes(nil)
}
func (_IAVLNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.IAVLNode.Repr"}.AssignLink(nil)
}
func (na *_IAVLNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_IAVLNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.IAVLNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_IAVLNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _IAVLNode__ReprPrototype{}
}
func (ma *_IAVLNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_IAVLNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.IAVLNode.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "inner":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "leaf":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLNode.Repr", Key: &_String{k}}
}
func (ma *_IAVLNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_IAVLNode__ReprKeyAssembler)(ma)
}
func (ma *_IAVLNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_IAVLNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.IAVLNode.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_IAVLNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_IAVLNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "IAVLInnerNode":
		return _IAVLInnerNode__ReprPrototype{}
	case "IAVLLeafNode":
		return _IAVLLeafNode__ReprPrototype{}
	default:
		return nil
	}
}

type _IAVLNode__ReprKeyAssembler _IAVLNode__ReprAssembler

func (_IAVLNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_IAVLNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_IAVLNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.Repr.KeyAssembler"}.AssignNull()
}
func (_IAVLNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_IAVLNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_IAVLNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_IAVLNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.IAVLNode.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "inner":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "leaf":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.IAVLNode.Repr", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_IAVLNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_IAVLNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.IAVLNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_IAVLNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_IAVLNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Int) Int() int64 {
	return n.x
}
func (_Int__Prototype) FromInt(v int64) (Int, error) {
	n := _Int{v}
	return &n, nil
}

type _Int__Maybe struct {
	m schema.Maybe
	v Int
}
type MaybeInt = *_Int__Maybe

func (m MaybeInt) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeInt) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeInt) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeInt) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeInt) Must() Int {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Int)(&_Int{})
var _ schema.TypedNode = (Int)(&_Int{})

func (Int) Kind() ipld.Kind {
	return ipld.Kind_Int
}
func (Int) LookupByString(string) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.Int"}.LookupByString("")
}
func (Int) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.Int"}.LookupByNode(nil)
}
func (Int) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.Int"}.LookupByIndex(0)
}
func (Int) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.Int"}.LookupBySegment(seg)
}
func (Int) MapIterator() ipld.MapIterator {
	return nil
}
func (Int) ListIterator() ipld.ListIterator {
	return nil
}
func (Int) Length() int64 {
	return -1
}
func (Int) IsAbsent() bool {
	return false
}
func (Int) IsNull() bool {
	return false
}
func (Int) AsBool() (bool, error) {
	return mixins.Int{"dagcosmos.Int"}.AsBool()
}
func (n Int) AsInt() (int64, error) {
	return n.x, nil
}
func (Int) AsFloat() (float64, error) {
	return mixins.Int{"dagcosmos.Int"}.AsFloat()
}
func (Int) AsString() (string, error) {
	return mixins.Int{"dagcosmos.Int"}.AsString()
}
func (Int) AsBytes() ([]byte, error) {
	return mixins.Int{"dagcosmos.Int"}.AsBytes()
}
func (Int) AsLink() (ipld.Link, error) {
	return mixins.Int{"dagcosmos.Int"}.AsLink()
}
func (Int) Prototype() ipld.NodePrototype {
	return _Int__Prototype{}
}

type _Int__Prototype struct{}

func (_Int__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Int__Builder
	nb.Reset()
	return &nb
}

type _Int__Builder struct {
	_Int__Assembler
}

func (nb *_Int__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Int__Builder) Reset() {
	var w _Int
	var m schema.Maybe
	*nb = _Int__Builder{_Int__Assembler{w: &w, m: &m}}
}

type _Int__Assembler struct {
	w *_Int
	m *schema.Maybe
}

func (na *_Int__Assembler) reset() {}
func (_Int__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.Int"}.BeginMap(0)
}
func (_Int__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.Int"}.BeginList(0)
}
func (na *_Int__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.IntAssembler{"dagcosmos.Int"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Int__Assembler) AssignBool(bool) error {
	return mixins.IntAssembler{"dagcosmos.Int"}.AssignBool(false)
}
func (na *_Int__Assembler) AssignInt(v int64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Int{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Int__Assembler) AssignFloat(float64) error {
	return mixins.IntAssembler{"dagcosmos.Int"}.AssignFloat(0)
}
func (_Int__Assembler) AssignString(string) error {
	return mixins.IntAssembler{"dagcosmos.Int"}.AssignString("")
}
func (_Int__Assembler) AssignBytes([]byte) error {
	return mixins.IntAssembler{"dagcosmos.Int"}.AssignBytes(nil)
}
func (_Int__Assembler) AssignLink(ipld.Link) error {
	return mixins.IntAssembler{"dagcosmos.Int"}.AssignLink(nil)
}
func (na *_Int__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Int); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsInt(); err != nil {
		return err
	} else {
		return na.AssignInt(v2)
	}
}
func (_Int__Assembler) Prototype() ipld.NodePrototype {
	return _Int__Prototype{}
}
func (Int) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Int) Representation() ipld.Node {
	return (*_Int__Repr)(n)
}

type _Int__Repr = _Int

var _ ipld.Node = &_Int__Repr{}

type _Int__ReprPrototype = _Int__Prototype
type _Int__ReprAssembler = _Int__Assembler

func (n _LightBlock) FieldSignedHeader() SignedHeader {
	return &n.SignedHeader
}
func (n _LightBlock) FieldValidatorSet() ValidatorSet {
	return &n.ValidatorSet
}

type _LightBlock__Maybe struct {
	m schema.Maybe
	v LightBlock
}
type MaybeLightBlock = *_LightBlock__Maybe

func (m MaybeLightBlock) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLightBlock) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLightBlock) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLightBlock) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLightBlock) Must() LightBlock {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__LightBlock_SignedHeader = _String{"SignedHeader"}
	fieldName__LightBlock_ValidatorSet = _String{"ValidatorSet"}
)
var _ ipld.Node = (LightBlock)(&_LightBlock{})
var _ schema.TypedNode = (LightBlock)(&_LightBlock{})

func (LightBlock) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n LightBlock) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "SignedHeader":
		return &n.SignedHeader, nil
	case "ValidatorSet":
		return &n.ValidatorSet, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n LightBlock) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (LightBlock) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.LookupByIndex(0)
}
func (n LightBlock) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n LightBlock) MapIterator() ipld.MapIterator {
	return &_LightBlock__MapItr{n, 0}
}

type _LightBlock__MapItr struct {
	n   LightBlock
	idx int
}

func (itr *_LightBlock__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__LightBlock_SignedHeader
		v = &itr.n.SignedHeader
	case 1:
		k = &fieldName__LightBlock_ValidatorSet
		v = &itr.n.ValidatorSet
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_LightBlock__MapItr) Done() bool {
	return itr.idx >= 2
}

func (LightBlock) ListIterator() ipld.ListIterator {
	return nil
}
func (LightBlock) Length() int64 {
	return 2
}
func (LightBlock) IsAbsent() bool {
	return false
}
func (LightBlock) IsNull() bool {
	return false
}
func (LightBlock) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsBool()
}
func (LightBlock) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsInt()
}
func (LightBlock) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsFloat()
}
func (LightBlock) AsString() (string, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsString()
}
func (LightBlock) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsBytes()
}
func (LightBlock) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsLink()
}
func (LightBlock) Prototype() ipld.NodePrototype {
	return _LightBlock__Prototype{}
}

type _LightBlock__Prototype struct{}

func (_LightBlock__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _LightBlock__Builder
	nb.Reset()
	return &nb
}

type _LightBlock__Builder struct {
	_LightBlock__Assembler
}

func (nb *_LightBlock__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_LightBlock__Builder) Reset() {
	var w _LightBlock
	var m schema.Maybe
	*nb = _LightBlock__Builder{_LightBlock__Assembler{w: &w, m: &m}}
}

type _LightBlock__Assembler struct {
	w     *_LightBlock
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_SignedHeader _SignedHeader__Assembler
	ca_ValidatorSet _ValidatorSet__Assembler
}

func (na *_LightBlock__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_SignedHeader.reset()
	na.ca_ValidatorSet.reset()
}

var (
	fieldBit__LightBlock_SignedHeader = 1 << 0
	fieldBit__LightBlock_ValidatorSet = 1 << 1
	fieldBits__LightBlock_sufficient  = 0 + 1<<0 + 1<<1
)

func (na *_LightBlock__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_LightBlock{}
	}
	return na, nil
}
func (_LightBlock__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.BeginList(0)
}
func (na *_LightBlock__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_LightBlock__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignBool(false)
}
func (_LightBlock__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignInt(0)
}
func (_LightBlock__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignFloat(0)
}
func (_LightBlock__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignString("")
}
func (_LightBlock__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignBytes(nil)
}
func (_LightBlock__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignLink(nil)
}
func (na *_LightBlock__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_LightBlock); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.LightBlock", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_LightBlock__Assembler) Prototype() ipld.NodePrototype {
	return _LightBlock__Prototype{}
}
func (ma *_LightBlock__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_SignedHeader.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorSet.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_LightBlock__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "SignedHeader":
		if ma.s&fieldBit__LightBlock_SignedHeader != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_SignedHeader}
		}
		ma.s += fieldBit__LightBlock_SignedHeader
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_SignedHeader.w = &ma.w.SignedHeader
		ma.ca_SignedHeader.m = &ma.cm
		return &ma.ca_SignedHeader, nil
	case "ValidatorSet":
		if ma.s&fieldBit__LightBlock_ValidatorSet != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_ValidatorSet}
		}
		ma.s += fieldBit__LightBlock_ValidatorSet
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ValidatorSet.w = &ma.w.ValidatorSet
		ma.ca_ValidatorSet.m = &ma.cm
		return &ma.ca_ValidatorSet, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.LightBlock", Key: &_String{k}}
}
func (ma *_LightBlock__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_LightBlock__KeyAssembler)(ma)
}
func (ma *_LightBlock__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_SignedHeader.w = &ma.w.SignedHeader
		ma.ca_SignedHeader.m = &ma.cm
		return &ma.ca_SignedHeader
	case 1:
		ma.ca_ValidatorSet.w = &ma.w.ValidatorSet
		ma.ca_ValidatorSet.m = &ma.cm
		return &ma.ca_ValidatorSet
	default:
		panic("unreachable")
	}
}
func (ma *_LightBlock__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__LightBlock_sufficient != fieldBits__LightBlock_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__LightBlock_SignedHeader == 0 {
			err.Missing = append(err.Missing, "SignedHeader")
		}
		if ma.s&fieldBit__LightBlock_ValidatorSet == 0 {
			err.Missing = append(err.Missing, "ValidatorSet")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_LightBlock__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_LightBlock__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _LightBlock__KeyAssembler _LightBlock__Assembler

func (_LightBlock__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.BeginMap(0)
}
func (_LightBlock__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.BeginList(0)
}
func (na *_LightBlock__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignNull()
}
func (_LightBlock__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignBool(false)
}
func (_LightBlock__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignInt(0)
}
func (_LightBlock__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignFloat(0)
}
func (ka *_LightBlock__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "SignedHeader":
		if ka.s&fieldBit__LightBlock_SignedHeader != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_SignedHeader}
		}
		ka.s += fieldBit__LightBlock_SignedHeader
		ka.state = maState_expectValue
		ka.f = 0
	case "ValidatorSet":
		if ka.s&fieldBit__LightBlock_ValidatorSet != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_ValidatorSet}
		}
		ka.s += fieldBit__LightBlock_ValidatorSet
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.LightBlock", Key: &_String{k}}
	}
	return nil
}
func (_LightBlock__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignBytes(nil)
}
func (_LightBlock__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignLink(nil)
}
func (ka *_LightBlock__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_LightBlock__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (LightBlock) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n LightBlock) Representation() ipld.Node {
	return (*_LightBlock__Repr)(n)
}

type _LightBlock__Repr _LightBlock

var (
	fieldName__LightBlock_SignedHeader_serial = _String{"SignedHeader"}
	fieldName__LightBlock_ValidatorSet_serial = _String{"ValidatorSet"}
)
var _ ipld.Node = &_LightBlock__Repr{}

func (_LightBlock__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_LightBlock__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "SignedHeader":
		return n.SignedHeader.Representation(), nil
	case "ValidatorSet":
		return n.ValidatorSet.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_LightBlock__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_LightBlock__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.LookupByIndex(0)
}
func (n _LightBlock__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_LightBlock__Repr) MapIterator() ipld.MapIterator {
	return &_LightBlock__ReprMapItr{n, 0}
}

type _LightBlock__ReprMapItr struct {
	n   *_LightBlock__Repr
	idx int
}

func (itr *_LightBlock__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__LightBlock_SignedHeader_serial
		v = itr.n.SignedHeader.Representation()
	case 1:
		k = &fieldName__LightBlock_ValidatorSet_serial
		v = itr.n.ValidatorSet.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_LightBlock__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_LightBlock__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_LightBlock__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_LightBlock__Repr) IsAbsent() bool {
	return false
}
func (_LightBlock__Repr) IsNull() bool {
	return false
}
func (_LightBlock__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsBool()
}
func (_LightBlock__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsInt()
}
func (_LightBlock__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsFloat()
}
func (_LightBlock__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsString()
}
func (_LightBlock__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsBytes()
}
func (_LightBlock__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsLink()
}
func (_LightBlock__Repr) Prototype() ipld.NodePrototype {
	return _LightBlock__ReprPrototype{}
}

type _LightBlock__ReprPrototype struct{}

func (_LightBlock__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _LightBlock__ReprBuilder
	nb.Reset()
	return &nb
}

type _LightBlock__ReprBuilder struct {
	_LightBlock__ReprAssembler
}

func (nb *_LightBlock__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_LightBlock__ReprBuilder) Reset() {
	var w _LightBlock
	var m schema.Maybe
	*nb = _LightBlock__ReprBuilder{_LightBlock__ReprAssembler{w: &w, m: &m}}
}

type _LightBlock__ReprAssembler struct {
	w     *_LightBlock
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_SignedHeader _SignedHeader__ReprAssembler
	ca_ValidatorSet _ValidatorSet__ReprAssembler
}

func (na *_LightBlock__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_SignedHeader.reset()
	na.ca_ValidatorSet.reset()
}
func (na *_LightBlock__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_LightBlock{}
	}
	return na, nil
}
func (_LightBlock__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.BeginList(0)
}
func (na *_LightBlock__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.LightBlock.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_LightBlock__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignBool(false)
}
func (_LightBlock__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignInt(0)
}
func (_LightBlock__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignFloat(0)
}
func (_LightBlock__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignString("")
}
func (_LightBlock__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignBytes(nil)
}
func (_LightBlock__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignLink(nil)
}
func (na *_LightBlock__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_LightBlock); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.LightBlock.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_LightBlock__ReprAssembler) Prototype() ipld.NodePrototype {
	return _LightBlock__ReprPrototype{}
}
func (ma *_LightBlock__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_LightBlock__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "SignedHeader":
		if ma.s&fieldBit__LightBlock_SignedHeader != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_SignedHeader_serial}
		}
		ma.s += fieldBit__LightBlock_SignedHeader
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_SignedHeader.w = &ma.w.SignedHeader
		ma.ca_SignedHeader.m = &ma.cm
		return &ma.ca_SignedHeader, nil
	case "ValidatorSet":
		if ma.s&fieldBit__LightBlock_ValidatorSet != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_ValidatorSet_serial}
		}
		ma.s += fieldBit__LightBlock_ValidatorSet
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ValidatorSet.w = &ma.w.ValidatorSet
		ma.ca_ValidatorSet.m = &ma.cm
		return &ma.ca_ValidatorSet, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.LightBlock.Repr", Key: &_String{k}}
}
func (ma *_LightBlock__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_LightBlock__ReprKeyAssembler)(ma)
}
func (ma *_LightBlock__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_SignedHeader.w = &ma.w.SignedHeader
		ma.ca_SignedHeader.m = &ma.cm
		return &ma.ca_SignedHeader
	case 1:
		ma.ca_ValidatorSet.w = &ma.w.ValidatorSet
		ma.ca_ValidatorSet.m = &ma.cm
		return &ma.ca_ValidatorSet
	default:
		panic("unreachable")
	}
}
func (ma *_LightBlock__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__LightBlock_sufficient != fieldBits__LightBlock_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__LightBlock_SignedHeader == 0 {
			err.Missing = append(err.Missing, "SignedHeader")
		}
		if ma.s&fieldBit__LightBlock_ValidatorSet == 0 {
			err.Missing = append(err.Missing, "ValidatorSet")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_LightBlock__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_LightBlock__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _LightBlock__ReprKeyAssembler _LightBlock__ReprAssembler

func (_LightBlock__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.BeginMap(0)
}
func (_LightBlock__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_LightBlock__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignNull()
}
func (_LightBlock__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignBool(false)
}
func (_LightBlock__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignInt(0)
}
func (_LightBlock__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_LightBlock__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "SignedHeader":
		if ka.s&fieldBit__LightBlock_SignedHeader != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_SignedHeader_serial}
		}
		ka.s += fieldBit__LightBlock_SignedHeader
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "ValidatorSet":
		if ka.s&fieldBit__LightBlock_ValidatorSet != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_ValidatorSet_serial}
		}
		ka.s += fieldBit__LightBlock_ValidatorSet
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.LightBlock.Repr", Key: &_String{k}}
}
func (_LightBlock__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_LightBlock__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_LightBlock__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_LightBlock__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _LightClientAttackEvidence) FieldConflictingBlock() LightBlock {
	return &n.ConflictingBlock
}
func (n _LightClientAttackEvidence) FieldCommonHeight() Int {
	return &n.CommonHeight
}
func (n _LightClientAttackEvidence) FieldByzantineValidators() Validators {
	return &n.ByzantineValidators
}
func (n _LightClientAttackEvidence) FieldTotalVotingPower() Int {
	return &n.TotalVotingPower
}
func (n _LightClientAttackEvidence) FieldTimestamp() Time {
	return &n.Timestamp
}

type _LightClientAttackEvidence__Maybe struct {
	m schema.Maybe
	v LightClientAttackEvidence
}
type MaybeLightClientAttackEvidence = *_LightClientAttackEvidence__Maybe

func (m MaybeLightClientAttackEvidence) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLightClientAttackEvidence) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLightClientAttackEvidence) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLightClientAttackEvidence) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLightClientAttackEvidence) Must() LightClientAttackEvidence {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__LightClientAttackEvidence_ConflictingBlock    = _String{"ConflictingBlock"}
	fieldName__LightClientAttackEvidence_CommonHeight        = _String{"CommonHeight"}
	fieldName__LightClientAttackEvidence_ByzantineValidators = _String{"ByzantineValidators"}
	fieldName__LightClientAttackEvidence_TotalVotingPower    = _String{"TotalVotingPower"}
	fieldName__LightClientAttackEvidence_Timestamp           = _String{"Timestamp"}
)
var _ ipld.Node = (LightClientAttackEvidence)(&_LightClientAttackEvidence{})
var _ schema.TypedNode = (LightClientAttackEvidence)(&_LightClientAttackEvidence{})

func (LightClientAttackEvidence) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n LightClientAttackEvidence) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "ConflictingBlock":
		return &n.ConflictingBlock, nil
	case "CommonHeight":
		return &n.CommonHeight, nil
	case "ByzantineValidators":
		return &n.ByzantineValidators, nil
	case "TotalVotingPower":
		return &n.TotalVotingPower, nil
	case "Timestamp":
		return &n.Timestamp, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n LightClientAttackEvidence) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (LightClientAttackEvidence) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.LookupByIndex(0)
}
func (n LightClientAttackEvidence) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n LightClientAttackEvidence) MapIterator() ipld.MapIterator {
	return &_LightClientAttackEvidence__MapItr{n, 0}
}

type _LightClientAttackEvidence__MapItr struct {
	n   LightClientAttackEvidence
	idx int
}

func (itr *_LightClientAttackEvidence__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__LightClientAttackEvidence_ConflictingBlock
		v = &itr.n.ConflictingBlock
	case 1:
		k = &fieldName__LightClientAttackEvidence_CommonHeight
		v = &itr.n.CommonHeight
	case 2:
		k = &fieldName__LightClientAttackEvidence_ByzantineValidators
		v = &itr.n.ByzantineValidators
	case 3:
		k = &fieldName__LightClientAttackEvidence_TotalVotingPower
		v = &itr.n.TotalVotingPower
	case 4:
		k = &fieldName__LightClientAttackEvidence_Timestamp
		v = &itr.n.Timestamp
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_LightClientAttackEvidence__MapItr) Done() bool {
	return itr.idx >= 5
}

func (LightClientAttackEvidence) ListIterator() ipld.ListIterator {
	return nil
}
func (LightClientAttackEvidence) Length() int64 {
	return 5
}
func (LightClientAttackEvidence) IsAbsent() bool {
	return false
}
func (LightClientAttackEvidence) IsNull() bool {
	return false
}
func (LightClientAttackEvidence) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsBool()
}
func (LightClientAttackEvidence) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsInt()
}
func (LightClientAttackEvidence) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsFloat()
}
func (LightClientAttackEvidence) AsString() (string, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsString()
}
func (LightClientAttackEvidence) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsBytes()
}
func (LightClientAttackEvidence) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsLink()
}
func (LightClientAttackEvidence) Prototype() ipld.NodePrototype {
	return _LightClientAttackEvidence__Prototype{}
}

type _LightClientAttackEvidence__Prototype struct{}

func (_LightClientAttackEvidence__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _LightClientAttackEvidence__Builder
	nb.Reset()
	return &nb
}

type _LightClientAttackEvidence__Builder struct {
	_LightClientAttackEvidence__Assembler
}

func (nb *_LightClientAttackEvidence__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_LightClientAttackEvidence__Builder) Reset() {
	var w _LightClientAttackEvidence
	var m schema.Maybe
	*nb = _LightClientAttackEvidence__Builder{_LightClientAttackEvidence__Assembler{w: &w, m: &m}}
}

type _LightClientAttackEvidence__Assembler struct {
	w     *_LightClientAttackEvidence
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                     schema.Maybe
	ca_ConflictingBlock    _LightBlock__Assembler
	ca_CommonHeight        _Int__Assembler
	ca_ByzantineValidators _Validators__Assembler
	ca_TotalVotingPower    _Int__Assembler
	ca_Timestamp           _Time__Assembler
}

func (na *_LightClientAttackEvidence__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_ConflictingBlock.reset()
	na.ca_CommonHeight.reset()
	na.ca_ByzantineValidators.reset()
	na.ca_TotalVotingPower.reset()
	na.ca_Timestamp.reset()
}

var (
	fieldBit__LightClientAttackEvidence_ConflictingBlock    = 1 << 0
	fieldBit__LightClientAttackEvidence_CommonHeight        = 1 << 1
	fieldBit__LightClientAttackEvidence_ByzantineValidators = 1 << 2
	fieldBit__LightClientAttackEvidence_TotalVotingPower    = 1 << 3
	fieldBit__LightClientAttackEvidence_Timestamp           = 1 << 4
	fieldBits__LightClientAttackEvidence_sufficient         = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4
)

func (na *_LightClientAttackEvidence__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_LightClientAttackEvidence{}
	}
	return na, nil
}
func (_LightClientAttackEvidence__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.BeginList(0)
}
func (na *_LightClientAttackEvidence__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_LightClientAttackEvidence__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignBool(false)
}
func (_LightClientAttackEvidence__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignInt(0)
}
func (_LightClientAttackEvidence__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignFloat(0)
}
func (_LightClientAttackEvidence__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignString("")
}
func (_LightClientAttackEvidence__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignBytes(nil)
}
func (_LightClientAttackEvidence__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignLink(nil)
}
func (na *_LightClientAttackEvidence__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_LightClientAttackEvidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.LightClientAttackEvidence", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_LightClientAttackEvidence__Assembler) Prototype() ipld.NodePrototype {
	return _LightClientAttackEvidence__Prototype{}
}
func (ma *_LightClientAttackEvidence__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ConflictingBlock.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_CommonHeight.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ByzantineValidators.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_TotalVotingPower.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Timestamp.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_LightClientAttackEvidence__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "ConflictingBlock":
		if ma.s&fieldBit__LightClientAttackEvidence_ConflictingBlock != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ConflictingBlock}
		}
		ma.s += fieldBit__LightClientAttackEvidence_ConflictingBlock
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_ConflictingBlock.w = &ma.w.ConflictingBlock
		ma.ca_ConflictingBlock.m = &ma.cm
		return &ma.ca_ConflictingBlock, nil
	case "CommonHeight":
		if ma.s&fieldBit__LightClientAttackEvidence_CommonHeight != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_CommonHeight}
		}
		ma.s += fieldBit__LightClientAttackEvidence_CommonHeight
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_CommonHeight.w = &ma.w.CommonHeight
		ma.ca_CommonHeight.m = &ma.cm
		return &ma.ca_CommonHeight, nil
	case "ByzantineValidators":
		if ma.s&fieldBit__LightClientAttackEvidence_ByzantineValidators != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ByzantineValidators}
		}
		ma.s += fieldBit__LightClientAttackEvidence_ByzantineValidators
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_ByzantineValidators.w = &ma.w.ByzantineValidators
		ma.ca_ByzantineValidators.m = &ma.cm
		return &ma.ca_ByzantineValidators, nil
	case "TotalVotingPower":
		if ma.s&fieldBit__LightClientAttackEvidence_TotalVotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_TotalVotingPower}
		}
		ma.s += fieldBit__LightClientAttackEvidence_TotalVotingPower
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower, nil
	case "Timestamp":
		if ma.s&fieldBit__LightClientAttackEvidence_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_Timestamp}
		}
		ma.s += fieldBit__LightClientAttackEvidence_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.LightClientAttackEvidence", Key: &_String{k}}
}
func (ma *_LightClientAttackEvidence__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_LightClientAttackEvidence__KeyAssembler)(ma)
}
func (ma *_LightClientAttackEvidence__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_ConflictingBlock.w = &ma.w.ConflictingBlock
		ma.ca_ConflictingBlock.m = &ma.cm
		return &ma.ca_ConflictingBlock
	case 1:
		ma.ca_CommonHeight.w = &ma.w.CommonHeight
		ma.ca_CommonHeight.m = &ma.cm
		return &ma.ca_CommonHeight
	case 2:
		ma.ca_ByzantineValidators.w = &ma.w.ByzantineValidators
		ma.ca_ByzantineValidators.m = &ma.cm
		return &ma.ca_ByzantineValidators
	case 3:
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	default:
		panic("unreachable")
	}
}
func (ma *_LightClientAttackEvidence__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__LightClientAttackEvidence_sufficient != fieldBits__LightClientAttackEvidence_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__LightClientAttackEvidence_ConflictingBlock == 0 {
			err.Missing = append(err.Missing, "ConflictingBlock")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_CommonHeight == 0 {
			err.Missing = append(err.Missing, "CommonHeight")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_ByzantineValidators == 0 {
			err.Missing = append(err.Missing, "ByzantineValidators")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_TotalVotingPower == 0 {
			err.Missing = append(err.Missing, "TotalVotingPower")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_LightClientAttackEvidence__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_LightClientAttackEvidence__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _LightClientAttackEvidence__KeyAssembler _LightClientAttackEvidence__Assembler

func (_LightClientAttackEvidence__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.BeginMap(0)
}
func (_LightClientAttackEvidence__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.BeginList(0)
}
func (na *_LightClientAttackEvidence__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignNull()
}
func (_LightClientAttackEvidence__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignBool(false)
}
func (_LightClientAttackEvidence__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignInt(0)
}
func (_LightClientAttackEvidence__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignFloat(0)
}
func (ka *_LightClientAttackEvidence__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "ConflictingBlock":
		if ka.s&fieldBit__LightClientAttackEvidence_ConflictingBlock != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ConflictingBlock}
		}
		ka.s += fieldBit__LightClientAttackEvidence_ConflictingBlock
		ka.state = maState_expectValue
		ka.f = 0
	case "CommonHeight":
		if ka.s&fieldBit__LightClientAttackEvidence_CommonHeight != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_CommonHeight}
		}
		ka.s += fieldBit__LightClientAttackEvidence_CommonHeight
		ka.state = maState_expectValue
		ka.f = 1
	case "ByzantineValidators":
		if ka.s&fieldBit__LightClientAttackEvidence_ByzantineValidators != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ByzantineValidators}
		}
		ka.s += fieldBit__LightClientAttackEvidence_ByzantineValidators
		ka.state = maState_expectValue
		ka.f = 2
	case "TotalVotingPower":
		if ka.s&fieldBit__LightClientAttackEvidence_TotalVotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_TotalVotingPower}
		}
		ka.s += fieldBit__LightClientAttackEvidence_TotalVotingPower
		ka.state = maState_expectValue
		ka.f = 3
	case "Timestamp":
		if ka.s&fieldBit__LightClientAttackEvidence_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_Timestamp}
		}
		ka.s += fieldBit__LightClientAttackEvidence_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.LightClientAttackEvidence", Key: &_String{k}}
	}
	return nil
}
func (_LightClientAttackEvidence__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignBytes(nil)
}
func (_LightClientAttackEvidence__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignLink(nil)
}
func (ka *_LightClientAttackEvidence__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_LightClientAttackEvidence__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (LightClientAttackEvidence) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n LightClientAttackEvidence) Representation() ipld.Node {
	return (*_LightClientAttackEvidence__Repr)(n)
}

type _LightClientAttackEvidence__Repr _LightClientAttackEvidence

var (
	fieldName__LightClientAttackEvidence_ConflictingBlock_serial    = _String{"ConflictingBlock"}
	fieldName__LightClientAttackEvidence_CommonHeight_serial        = _String{"CommonHeight"}
	fieldName__LightClientAttackEvidence_ByzantineValidators_serial = _String{"ByzantineValidators"}
	fieldName__LightClientAttackEvidence_TotalVotingPower_serial    = _String{"TotalVotingPower"}
	fieldName__LightClientAttackEvidence_Timestamp_serial           = _String{"Timestamp"}
)
var _ ipld.Node = &_LightClientAttackEvidence__Repr{}

func (_LightClientAttackEvidence__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_LightClientAttackEvidence__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "ConflictingBlock":
		return n.ConflictingBlock.Representation(), nil
	case "CommonHeight":
		return n.CommonHeight.Representation(), nil
	case "ByzantineValidators":
		return n.ByzantineValidators.Representation(), nil
	case "TotalVotingPower":
		return n.TotalVotingPower.Representation(), nil
	case "Timestamp":
		return n.Timestamp.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_LightClientAttackEvidence__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_LightClientAttackEvidence__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.LookupByIndex(0)
}
func (n _LightClientAttackEvidence__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_LightClientAttackEvidence__Repr) MapIterator() ipld.MapIterator {
	return &_LightClientAttackEvidence__ReprMapItr{n, 0}
}

type _LightClientAttackEvidence__ReprMapItr struct {
	n   *_LightClientAttackEvidence__Repr
	idx int
}

func (itr *_LightClientAttackEvidence__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__LightClientAttackEvidence_ConflictingBlock_serial
		v = itr.n.ConflictingBlock.Representation()
	case 1:
		k = &fieldName__LightClientAttackEvidence_CommonHeight_serial
		v = itr.n.CommonHeight.Representation()
	case 2:
		k = &fieldName__LightClientAttackEvidence_ByzantineValidators_serial
		v = itr.n.ByzantineValidators.Representation()
	case 3:
		k = &fieldName__LightClientAttackEvidence_TotalVotingPower_serial
		v = itr.n.TotalVotingPower.Representation()
	case 4:
		k = &fieldName__LightClientAttackEvidence_Timestamp_serial
		v = itr.n.Timestamp.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_LightClientAttackEvidence__ReprMapItr) Done() bool {
	return itr.idx >= 5
}
func (_LightClientAttackEvidence__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_LightClientAttackEvidence__Repr) Length() int64 {
	l := 5
	return int64(l)
}
func (_LightClientAttackEvidence__Repr) IsAbsent() bool {
	return false
}
func (_LightClientAttackEvidence__Repr) IsNull() bool {
	return false
}
func (_LightClientAttackEvidence__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsBool()
}
func (_LightClientAttackEvidence__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsInt()
}
func (_LightClientAttackEvidence__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsFloat()
}
func (_LightClientAttackEvidence__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsString()
}
func (_LightClientAttackEvidence__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsBytes()
}
func (_LightClientAttackEvidence__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsLink()
}
func (_LightClientAttackEvidence__Repr) Prototype() ipld.NodePrototype {
	return _LightClientAttackEvidence__ReprPrototype{}
}

type _LightClientAttackEvidence__ReprPrototype struct{}

func (_LightClientAttackEvidence__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _LightClientAttackEvidence__ReprBuilder
	nb.Reset()
	return &nb
}

type _LightClientAttackEvidence__ReprBuilder struct {
	_LightClientAttackEvidence__ReprAssembler
}

func (nb *_LightClientAttackEvidence__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_LightClientAttackEvidence__ReprBuilder) Reset() {
	var w _LightClientAttackEvidence
	var m schema.Maybe
	*nb = _LightClientAttackEvidence__ReprBuilder{_LightClientAttackEvidence__ReprAssembler{w: &w, m: &m}}
}

type _LightClientAttackEvidence__ReprAssembler struct {
	w     *_LightClientAttackEvidence
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                     schema.Maybe
	ca_ConflictingBlock    _LightBlock__ReprAssembler
	ca_CommonHeight        _Int__ReprAssembler
	ca_ByzantineValidators _Validators__ReprAssembler
	ca_TotalVotingPower    _Int__ReprAssembler
	ca_Timestamp           _Time__ReprAssembler
}

func (na *_LightClientAttackEvidence__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_ConflictingBlock.reset()
	na.ca_CommonHeight.reset()
	na.ca_ByzantineValidators.reset()
	na.ca_TotalVotingPower.reset()
	na.ca_Timestamp.reset()
}
func (na *_LightClientAttackEvidence__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_LightClientAttackEvidence{}
	}
	return na, nil
}
func (_LightClientAttackEvidence__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.BeginList(0)
}
func (na *_LightClientAttackEvidence__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_LightClientAttackEvidence__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignBool(false)
}
func (_LightClientAttackEvidence__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignInt(0)
}
func (_LightClientAttackEvidence__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignFloat(0)
}
func (_LightClientAttackEvidence__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignString("")
}
func (_LightClientAttackEvidence__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignBytes(nil)
}
func (_LightClientAttackEvidence__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignLink(nil)
}
func (na *_LightClientAttackEvidence__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_LightClientAttackEvidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.LightClientAttackEvidence.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_LightClientAttackEvidence__ReprAssembler) Prototype() ipld.NodePrototype {
	return _LightClientAttackEvidence__ReprPrototype{}
}
func (ma *_LightClientAttackEvidence__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_LightClientAttackEvidence__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "ConflictingBlock":
		if ma.s&fieldBit__LightClientAttackEvidence_ConflictingBlock != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ConflictingBlock_serial}
		}
		ma.s += fieldBit__LightClientAttackEvidence_ConflictingBlock
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_ConflictingBlock.w = &ma.w.ConflictingBlock
		ma.ca_ConflictingBlock.m = &ma.cm
		return &ma.ca_ConflictingBlock, nil
	case "CommonHeight":
		if ma.s&fieldBit__LightClientAttackEvidence_CommonHeight != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_CommonHeight_serial}
		}
		ma.s += fieldBit__LightClientAttackEvidence_CommonHeight
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_CommonHeight.w = &ma.w.CommonHeight
		ma.ca_CommonHeight.m = &ma.cm
		return &ma.ca_CommonHeight, nil
	case "ByzantineValidators":
		if ma.s&fieldBit__LightClientAttackEvidence_ByzantineValidators != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ByzantineValidators_serial}
		}
		ma.s += fieldBit__LightClientAttackEvidence_ByzantineValidators
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_ByzantineValidators.w = &ma.w.ByzantineValidators
		ma.ca_ByzantineValidators.m = &ma.cm
		return &ma.ca_ByzantineValidators, nil
	case "TotalVotingPower":
		if ma.s&fieldBit__LightClientAttackEvidence_TotalVotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_TotalVotingPower_serial}
		}
		ma.s += fieldBit__LightClientAttackEvidence_TotalVotingPower
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower, nil
	case "Timestamp":
		if ma.s&fieldBit__LightClientAttackEvidence_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_Timestamp_serial}
		}
		ma.s += fieldBit__LightClientAttackEvidence_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.LightClientAttackEvidence.Repr", Key: &_String{k}}
}
func (ma *_LightClientAttackEvidence__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_LightClientAttackEvidence__ReprKeyAssembler)(ma)
}
func (ma *_LightClientAttackEvidence__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_ConflictingBlock.w = &ma.w.ConflictingBlock
		ma.ca_ConflictingBlock.m = &ma.cm
		return &ma.ca_ConflictingBlock
	case 1:
		ma.ca_CommonHeight.w = &ma.w.CommonHeight
		ma.ca_CommonHeight.m = &ma.cm
		return &ma.ca_CommonHeight
	case 2:
		ma.ca_ByzantineValidators.w = &ma.w.ByzantineValidators
		ma.ca_ByzantineValidators.m = &ma.cm
		return &ma.ca_ByzantineValidators
	case 3:
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	default:
		panic("unreachable")
	}
}
func (ma *_LightClientAttackEvidence__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__LightClientAttackEvidence_sufficient != fieldBits__LightClientAttackEvidence_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__LightClientAttackEvidence_ConflictingBlock == 0 {
			err.Missing = append(err.Missing, "ConflictingBlock")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_CommonHeight == 0 {
			err.Missing = append(err.Missing, "CommonHeight")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_ByzantineValidators == 0 {
			err.Missing = append(err.Missing, "ByzantineValidators")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_TotalVotingPower == 0 {
			err.Missing = append(err.Missing, "TotalVotingPower")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_LightClientAttackEvidence__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_LightClientAttackEvidence__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _LightClientAttackEvidence__ReprKeyAssembler _LightClientAttackEvidence__ReprAssembler

func (_LightClientAttackEvidence__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.BeginMap(0)
}
func (_LightClientAttackEvidence__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_LightClientAttackEvidence__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignNull()
}
func (_LightClientAttackEvidence__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignBool(false)
}
func (_LightClientAttackEvidence__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignInt(0)
}
func (_LightClientAttackEvidence__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_LightClientAttackEvidence__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "ConflictingBlock":
		if ka.s&fieldBit__LightClientAttackEvidence_ConflictingBlock != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ConflictingBlock_serial}
		}
		ka.s += fieldBit__LightClientAttackEvidence_ConflictingBlock
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "CommonHeight":
		if ka.s&fieldBit__LightClientAttackEvidence_CommonHeight != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_CommonHeight_serial}
		}
		ka.s += fieldBit__LightClientAttackEvidence_CommonHeight
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "ByzantineValidators":
		if ka.s&fieldBit__LightClientAttackEvidence_ByzantineValidators != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ByzantineValidators_serial}
		}
		ka.s += fieldBit__LightClientAttackEvidence_ByzantineValidators
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "TotalVotingPower":
		if ka.s&fieldBit__LightClientAttackEvidence_TotalVotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_TotalVotingPower_serial}
		}
		ka.s += fieldBit__LightClientAttackEvidence_TotalVotingPower
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Timestamp":
		if ka.s&fieldBit__LightClientAttackEvidence_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_Timestamp_serial}
		}
		ka.s += fieldBit__LightClientAttackEvidence_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.LightClientAttackEvidence.Repr", Key: &_String{k}}
}
func (_LightClientAttackEvidence__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_LightClientAttackEvidence__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_LightClientAttackEvidence__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_LightClientAttackEvidence__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Link) Link() ipld.Link {
	return n.x
}
func (_Link__Prototype) FromLink(v ipld.Link) (Link, error) {
	n := _Link{v}
	return &n, nil
}

type _Link__Maybe struct {
	m schema.Maybe
	v Link
}
type MaybeLink = *_Link__Maybe

func (m MaybeLink) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLink) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLink) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLink) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLink) Must() Link {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Link)(&_Link{})
var _ schema.TypedNode = (Link)(&_Link{})

func (Link) Kind() ipld.Kind {
	return ipld.Kind_Link
}
func (Link) LookupByString(string) (ipld.Node, error) {
	return mixins.Link{"dagcosmos.Link"}.LookupByString("")
}
func (Link) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Link{"dagcosmos.Link"}.LookupByNode(nil)
}
func (Link) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Link{"dagcosmos.Link"}.LookupByIndex(0)
}
func (Link) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Link{"dagcosmos.Link"}.LookupBySegment(seg)
}
func (Link) MapIterator() ipld.MapIterator {
	return nil
}
func (Link) ListIterator() ipld.ListIterator {
	return nil
}
func (Link) Length() int64 {
	return -1
}
func (Link) IsAbsent() bool {
	return false
}
func (Link) IsNull() bool {
	return false
}
func (Link) AsBool() (bool, error) {
	return mixins.Link{"dagcosmos.Link"}.AsBool()
}
func (Link) AsInt() (int64, error) {
	return mixins.Link{"dagcosmos.Link"}.AsInt()
}
func (Link) AsFloat() (float64, error) {
	return mixins.Link{"dagcosmos.Link"}.AsFloat()
}
func (Link) AsString() (string, error) {
	return mixins.Link{"dagcosmos.Link"}.AsString()
}
func (Link) AsBytes() ([]byte, error) {
	return mixins.Link{"dagcosmos.Link"}.AsBytes()
}
func (n Link) AsLink() (ipld.Link, error) {
	return n.x, nil
}
func (Link) Prototype() ipld.NodePrototype {
	return _Link__Prototype{}
}

type _Link__Prototype struct{}

func (_Link__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Link__Builder
	nb.Reset()
	return &nb
}

type _Link__Builder struct {
	_Link__Assembler
}

func (nb *_Link__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Link__Builder) Reset() {
	var w _Link
	var m schema.Maybe
	*nb = _Link__Builder{_Link__Assembler{w: &w, m: &m}}
}

type _Link__Assembler struct {
	w *_Link
	m *schema.Maybe
}

func (na *_Link__Assembler) reset() {}
func (_Link__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.LinkAssembler{"dagcosmos.Link"}.BeginMap(0)
}
func (_Link__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.LinkAssembler{"dagcosmos.Link"}.BeginList(0)
}
func (na *_Link__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.LinkAssembler{"dagcosmos.Link"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Link__Assembler) AssignBool(bool) error {
	return mixins.LinkAssembler{"dagcosmos.Link"}.AssignBool(false)
}
func (_Link__Assembler) AssignInt(int64) error {
	return mixins.LinkAssembler{"dagcosmos.Link"}.AssignInt(0)
}
func (_Link__Assembler) AssignFloat(float64) error {
	return mixins.LinkAssembler{"dagcosmos.Link"}.AssignFloat(0)
}
func (_Link__Assembler) AssignString(string) error {
	return mixins.LinkAssembler{"dagcosmos.Link"}.AssignString("")
}
func (_Link__Assembler) AssignBytes([]byte) error {
	return mixins.LinkAssembler{"dagcosmos.Link"}.AssignBytes(nil)
}
func (na *_Link__Assembler) AssignLink(v ipld.Link) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Link{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (na *_Link__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Link); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsLink(); err != nil {
		return err
	} else {
		return na.AssignLink(v2)
	}
}
func (_Link__Assembler) Prototype() ipld.NodePrototype {
	return _Link__Prototype{}
}
func (Link) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Link) Representation() ipld.Node {
	return (*_Link__Repr)(n)
}

type _Link__Repr = _Link

var _ ipld.Node = &_Link__Repr{}

type _Link__ReprPrototype = _Link__Prototype
type _Link__ReprAssembler = _Link__Assembler

func (n _MerkleTreeInnerNode) FieldLeft() MaybeLink {
	return &n.Left
}
func (n _MerkleTreeInnerNode) FieldRight() MaybeLink {
	return &n.Right
}

type _MerkleTreeInnerNode__Maybe struct {
	m schema.Maybe
	v MerkleTreeInnerNode
}
type MaybeMerkleTreeInnerNode = *_MerkleTreeInnerNode__Maybe

func (m MaybeMerkleTreeInnerNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMerkleTreeInnerNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMerkleTreeInnerNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMerkleTreeInnerNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeMerkleTreeInnerNode) Must() MerkleTreeInnerNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__MerkleTreeInnerNode_Left  = _String{"Left"}
	fieldName__MerkleTreeInnerNode_Right = _String{"Right"}
)
var _ ipld.Node = (MerkleTreeInnerNode)(&_MerkleTreeInnerNode{})
var _ schema.TypedNode = (MerkleTreeInnerNode)(&_MerkleTreeInnerNode{})

func (MerkleTreeInnerNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n MerkleTreeInnerNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Left":
		if n.Left.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Left.v, nil
	case "Right":
		if n.Right.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Right.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n MerkleTreeInnerNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (MerkleTreeInnerNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode"}.LookupByIndex(0)
}
func (n MerkleTreeInnerNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n MerkleTreeInnerNode) MapIterator() ipld.MapIterator {
	return &_MerkleTreeInnerNode__MapItr{n, 0}
}

type _MerkleTreeInnerNode__MapItr struct {
	n   MerkleTreeInnerNode
	idx int
}

func (itr *_MerkleTreeInnerNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__MerkleTreeInnerNode_Left
		if itr.n.Left.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Left.v
	case 1:
		k = &fieldName__MerkleTreeInnerNode_Right
		if itr.n.Right.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Right.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_MerkleTreeInnerNode__MapItr) Done() bool {
	return itr.idx >= 2
}

func (MerkleTreeInnerNode) ListIterator() ipld.ListIterator {
	return nil
}
func (MerkleTreeInnerNode) Length() int64 {
	return 2
}
func (MerkleTreeInnerNode) IsAbsent() bool {
	return false
}
func (MerkleTreeInnerNode) IsNull() bool {
	return false
}
func (MerkleTreeInnerNode) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode"}.AsBool()
}
func (MerkleTreeInnerNode) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode"}.AsInt()
}
func (MerkleTreeInnerNode) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode"}.AsFloat()
}
func (MerkleTreeInnerNode) AsString() (string, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode"}.AsString()
}
func (MerkleTreeInnerNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode"}.AsBytes()
}
func (MerkleTreeInnerNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode"}.AsLink()
}
func (MerkleTreeInnerNode) Prototype() ipld.NodePrototype {
	return _MerkleTreeInnerNode__Prototype{}
}

type _MerkleTreeInnerNode__Prototype struct{}

func (_MerkleTreeInnerNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _MerkleTreeInnerNode__Builder
	nb.Reset()
	return &nb
}

type _MerkleTreeInnerNode__Builder struct {
	_MerkleTreeInnerNode__Assembler
}

func (nb *_MerkleTreeInnerNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MerkleTreeInnerNode__Builder) Reset() {
	var w _MerkleTreeInnerNode
	var m schema.Maybe
	*nb = _MerkleTreeInnerNode__Builder{_MerkleTreeInnerNode__Assembler{w: &w, m: &m}}
}

type _MerkleTreeInnerNode__Assembler struct {
	w     *_MerkleTreeInnerNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Left  _Link__Assembler
	ca_Right _Link__Assembler
}

func (na *_MerkleTreeInnerNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Left.reset()
	na.ca_Right.reset()
}

var (
	fieldBit__MerkleTreeInnerNode_Left        = 1 << 0
	fieldBit__MerkleTreeInnerNode_Right       = 1 << 1
	fieldBits__MerkleTreeInnerNode_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_MerkleTreeInnerNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MerkleTreeInnerNode{}
	}
	return na, nil
}
func (_MerkleTreeInnerNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode"}.BeginList(0)
}
func (na *_MerkleTreeInnerNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MerkleTreeInnerNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode"}.AssignBool(false)
}
func (_MerkleTreeInnerNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode"}.AssignInt(0)
}
func (_MerkleTreeInnerNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode"}.AssignFloat(0)
}
func (_MerkleTreeInnerNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode"}.AssignString("")
}
func (_MerkleTreeInnerNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode"}.AssignBytes(nil)
}
func (_MerkleTreeInnerNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode"}.AssignLink(nil)
}
func (na *_MerkleTreeInnerNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MerkleTreeInnerNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.MerkleTreeInnerNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MerkleTreeInnerNode__Assembler) Prototype() ipld.NodePrototype {
	return _MerkleTreeInnerNode__Prototype{}
}
func (ma *_MerkleTreeInnerNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Left.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Left.v = ma.ca_Left.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.Right.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Right.v = ma.ca_Right.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_MerkleTreeInnerNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Left":
		if ma.s&fieldBit__MerkleTreeInnerNode_Left != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeInnerNode_Left}
		}
		ma.s += fieldBit__MerkleTreeInnerNode_Left
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left, nil
	case "Right":
		if ma.s&fieldBit__MerkleTreeInnerNode_Right != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeInnerNode_Right}
		}
		ma.s += fieldBit__MerkleTreeInnerNode_Right
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeInnerNode", Key: &_String{k}}
}
func (ma *_MerkleTreeInnerNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MerkleTreeInnerNode__KeyAssembler)(ma)
}
func (ma *_MerkleTreeInnerNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left
	case 1:
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right
	default:
		panic("unreachable")
	}
}
func (ma *_MerkleTreeInnerNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__MerkleTreeInnerNode_sufficient != fieldBits__MerkleTreeInnerNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MerkleTreeInnerNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MerkleTreeInnerNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _MerkleTreeInnerNode__KeyAssembler _MerkleTreeInnerNode__Assembler

func (_MerkleTreeInnerNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.KeyAssembler"}.BeginMap(0)
}
func (_MerkleTreeInnerNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.KeyAssembler"}.BeginList(0)
}
func (na *_MerkleTreeInnerNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.KeyAssembler"}.AssignNull()
}
func (_MerkleTreeInnerNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.KeyAssembler"}.AssignBool(false)
}
func (_MerkleTreeInnerNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.KeyAssembler"}.AssignInt(0)
}
func (_MerkleTreeInnerNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MerkleTreeInnerNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Left":
		if ka.s&fieldBit__MerkleTreeInnerNode_Left != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeInnerNode_Left}
		}
		ka.s += fieldBit__MerkleTreeInnerNode_Left
		ka.state = maState_expectValue
		ka.f = 0
	case "Right":
		if ka.s&fieldBit__MerkleTreeInnerNode_Right != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeInnerNode_Right}
		}
		ka.s += fieldBit__MerkleTreeInnerNode_Right
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeInnerNode", Key: &_String{k}}
	}
	return nil
}
func (_MerkleTreeInnerNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.KeyAssembler"}.AssignBytes(nil)
}
func (_MerkleTreeInnerNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MerkleTreeInnerNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MerkleTreeInnerNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (MerkleTreeInnerNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n MerkleTreeInnerNode) Representation() ipld.Node {
	return (*_MerkleTreeInnerNode__Repr)(n)
}

type _MerkleTreeInnerNode__Repr _MerkleTreeInnerNode

var (
	fieldName__MerkleTreeInnerNode_Left_serial  = _String{"Left"}
	fieldName__MerkleTreeInnerNode_Right_serial = _String{"Right"}
)
var _ ipld.Node = &_MerkleTreeInnerNode__Repr{}

func (_MerkleTreeInnerNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_MerkleTreeInnerNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Left":
		if n.Left.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Left.v.Representation(), nil
	case "Right":
		if n.Right.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Right.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_MerkleTreeInnerNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_MerkleTreeInnerNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode.Repr"}.LookupByIndex(0)
}
func (n _MerkleTreeInnerNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_MerkleTreeInnerNode__Repr) MapIterator() ipld.MapIterator {
	return &_MerkleTreeInnerNode__ReprMapItr{n, 0}
}

type _MerkleTreeInnerNode__ReprMapItr struct {
	n   *_MerkleTreeInnerNode__Repr
	idx int
}

func (itr *_MerkleTreeInnerNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__MerkleTreeInnerNode_Left_serial
		if itr.n.Left.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Left.v.Representation()
	case 1:
		k = &fieldName__MerkleTreeInnerNode_Right_serial
		if itr.n.Right.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Right.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_MerkleTreeInnerNode__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_MerkleTreeInnerNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_MerkleTreeInnerNode__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_MerkleTreeInnerNode__Repr) IsAbsent() bool {
	return false
}
func (_MerkleTreeInnerNode__Repr) IsNull() bool {
	return false
}
func (_MerkleTreeInnerNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode.Repr"}.AsBool()
}
func (_MerkleTreeInnerNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode.Repr"}.AsInt()
}
func (_MerkleTreeInnerNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode.Repr"}.AsFloat()
}
func (_MerkleTreeInnerNode__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode.Repr"}.AsString()
}
func (_MerkleTreeInnerNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode.Repr"}.AsBytes()
}
func (_MerkleTreeInnerNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.MerkleTreeInnerNode.Repr"}.AsLink()
}
func (_MerkleTreeInnerNode__Repr) Prototype() ipld.NodePrototype {
	return _MerkleTreeInnerNode__ReprPrototype{}
}

type _MerkleTreeInnerNode__ReprPrototype struct{}

func (_MerkleTreeInnerNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _MerkleTreeInnerNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _MerkleTreeInnerNode__ReprBuilder struct {
	_MerkleTreeInnerNode__ReprAssembler
}

func (nb *_MerkleTreeInnerNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MerkleTreeInnerNode__ReprBuilder) Reset() {
	var w _MerkleTreeInnerNode
	var m schema.Maybe
	*nb = _MerkleTreeInnerNode__ReprBuilder{_MerkleTreeInnerNode__ReprAssembler{w: &w, m: &m}}
}

type _MerkleTreeInnerNode__ReprAssembler struct {
	w     *_MerkleTreeInnerNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Left  _Link__ReprAssembler
	ca_Right _Link__ReprAssembler
}

func (na *_MerkleTreeInnerNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Left.reset()
	na.ca_Right.reset()
}
func (na *_MerkleTreeInnerNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MerkleTreeInnerNode{}
	}
	return na, nil
}
func (_MerkleTreeInnerNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode.Repr"}.BeginList(0)
}
func (na *_MerkleTreeInnerNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MerkleTreeInnerNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode.Repr"}.AssignBool(false)
}
func (_MerkleTreeInnerNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode.Repr"}.AssignInt(0)
}
func (_MerkleTreeInnerNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode.Repr"}.AssignFloat(0)
}
func (_MerkleTreeInnerNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode.Repr"}.AssignString("")
}
func (_MerkleTreeInnerNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode.Repr"}.AssignBytes(nil)
}
func (_MerkleTreeInnerNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeInnerNode.Repr"}.AssignLink(nil)
}
func (na *_MerkleTreeInnerNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MerkleTreeInnerNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.MerkleTreeInnerNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MerkleTreeInnerNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _MerkleTreeInnerNode__ReprPrototype{}
}
func (ma *_MerkleTreeInnerNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Left.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Left.v = ma.ca_Left.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.Right.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Right.v = ma.ca_Right.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_MerkleTreeInnerNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Left":
		if ma.s&fieldBit__MerkleTreeInnerNode_Left != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeInnerNode_Left_serial}
		}
		ma.s += fieldBit__MerkleTreeInnerNode_Left
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left, nil
	case "Right":
		if ma.s&fieldBit__MerkleTreeInnerNode_Right != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeInnerNode_Right_serial}
		}
		ma.s += fieldBit__MerkleTreeInnerNode_Right
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeInnerNode.Repr", Key: &_String{k}}
}
func (ma *_MerkleTreeInnerNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MerkleTreeInnerNode__ReprKeyAssembler)(ma)
}
func (ma *_MerkleTreeInnerNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left
	case 1:
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right
	default:
		panic("unreachable")
	}
}
func (ma *_MerkleTreeInnerNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__MerkleTreeInnerNode_sufficient != fieldBits__MerkleTreeInnerNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MerkleTreeInnerNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MerkleTreeInnerNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _MerkleTreeInnerNode__ReprKeyAssembler _MerkleTreeInnerNode__ReprAssembler

func (_MerkleTreeInnerNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_MerkleTreeInnerNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_MerkleTreeInnerNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.Repr.KeyAssembler"}.AssignNull()
}
func (_MerkleTreeInnerNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_MerkleTreeInnerNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_MerkleTreeInnerNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MerkleTreeInnerNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Left":
		if ka.s&fieldBit__MerkleTreeInnerNode_Left != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeInnerNode_Left_serial}
		}
		ka.s += fieldBit__MerkleTreeInnerNode_Left
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Right":
		if ka.s&fieldBit__MerkleTreeInnerNode_Right != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeInnerNode_Right_serial}
		}
		ka.s += fieldBit__MerkleTreeInnerNode_Right
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeInnerNode.Repr", Key: &_String{k}}
}
func (_MerkleTreeInnerNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_MerkleTreeInnerNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeInnerNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MerkleTreeInnerNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MerkleTreeInnerNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _MerkleTreeLeafNode) FieldValue() Value {
	return &n.Value
}

type _MerkleTreeLeafNode__Maybe struct {
	m schema.Maybe
	v MerkleTreeLeafNode
}
type MaybeMerkleTreeLeafNode = *_MerkleTreeLeafNode__Maybe

func (m MaybeMerkleTreeLeafNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMerkleTreeLeafNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMerkleTreeLeafNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMerkleTreeLeafNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeMerkleTreeLeafNode) Must() MerkleTreeLeafNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__MerkleTreeLeafNode_Value = _String{"Value"}
)
var _ ipld.Node = (MerkleTreeLeafNode)(&_MerkleTreeLeafNode{})
var _ schema.TypedNode = (MerkleTreeLeafNode)(&_MerkleTreeLeafNode{})

func (MerkleTreeLeafNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n MerkleTreeLeafNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Value":
		return &n.Value, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n MerkleTreeLeafNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (MerkleTreeLeafNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode"}.LookupByIndex(0)
}
func (n MerkleTreeLeafNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n MerkleTreeLeafNode) MapIterator() ipld.MapIterator {
	return &_MerkleTreeLeafNode__MapItr{n, 0}
}

type _MerkleTreeLeafNode__MapItr struct {
	n   MerkleTreeLeafNode
	idx int
}

func (itr *_MerkleTreeLeafNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__MerkleTreeLeafNode_Value
		v = &itr.n.Value
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_MerkleTreeLeafNode__MapItr) Done() bool {
	return itr.idx >= 1
}

func (MerkleTreeLeafNode) ListIterator() ipld.ListIterator {
	return nil
}
func (MerkleTreeLeafNode) Length() int64 {
	return 1
}
func (MerkleTreeLeafNode) IsAbsent() bool {
	return false
}
func (MerkleTreeLeafNode) IsNull() bool {
	return false
}
func (MerkleTreeLeafNode) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode"}.AsBool()
}
func (MerkleTreeLeafNode) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode"}.AsInt()
}
func (MerkleTreeLeafNode) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode"}.AsFloat()
}
func (MerkleTreeLeafNode) AsString() (string, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode"}.AsString()
}
func (MerkleTreeLeafNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode"}.AsBytes()
}
func (MerkleTreeLeafNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode"}.AsLink()
}
func (MerkleTreeLeafNode) Prototype() ipld.NodePrototype {
	return _MerkleTreeLeafNode__Prototype{}
}

type _MerkleTreeLeafNode__Prototype struct{}

func (_MerkleTreeLeafNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _MerkleTreeLeafNode__Builder
	nb.Reset()
	return &nb
}

type _MerkleTreeLeafNode__Builder struct {
	_MerkleTreeLeafNode__Assembler
}

func (nb *_MerkleTreeLeafNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MerkleTreeLeafNode__Builder) Reset() {
	var w _MerkleTreeLeafNode
	var m schema.Maybe
	*nb = _MerkleTreeLeafNode__Builder{_MerkleTreeLeafNode__Assembler{w: &w, m: &m}}
}

type _MerkleTreeLeafNode__Assembler struct {
	w     *_MerkleTreeLeafNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Value _Value__Assembler
}

func (na *_MerkleTreeLeafNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Value.reset()
}

var (
	fieldBit__MerkleTreeLeafNode_Value       = 1 << 0
	fieldBits__MerkleTreeLeafNode_sufficient = 0 + 1<<0
)

func (na *_MerkleTreeLeafNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MerkleTreeLeafNode{}
	}
	return na, nil
}
func (_MerkleTreeLeafNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode"}.BeginList(0)
}
func (na *_MerkleTreeLeafNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MerkleTreeLeafNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode"}.AssignBool(false)
}
func (_MerkleTreeLeafNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode"}.AssignInt(0)
}
func (_MerkleTreeLeafNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode"}.AssignFloat(0)
}
func (_MerkleTreeLeafNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode"}.AssignString("")
}
func (_MerkleTreeLeafNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode"}.AssignBytes(nil)
}
func (_MerkleTreeLeafNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode"}.AssignLink(nil)
}
func (na *_MerkleTreeLeafNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MerkleTreeLeafNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.MerkleTreeLeafNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MerkleTreeLeafNode__Assembler) Prototype() ipld.NodePrototype {
	return _MerkleTreeLeafNode__Prototype{}
}
func (ma *_MerkleTreeLeafNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Value.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_MerkleTreeLeafNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Value":
		if ma.s&fieldBit__MerkleTreeLeafNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeLeafNode_Value}
		}
		ma.s += fieldBit__MerkleTreeLeafNode_Value
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeLeafNode", Key: &_String{k}}
}
func (ma *_MerkleTreeLeafNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MerkleTreeLeafNode__KeyAssembler)(ma)
}
func (ma *_MerkleTreeLeafNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_MerkleTreeLeafNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__MerkleTreeLeafNode_sufficient != fieldBits__MerkleTreeLeafNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__MerkleTreeLeafNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MerkleTreeLeafNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MerkleTreeLeafNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _MerkleTreeLeafNode__KeyAssembler _MerkleTreeLeafNode__Assembler

func (_MerkleTreeLeafNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.KeyAssembler"}.BeginMap(0)
}
func (_MerkleTreeLeafNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.KeyAssembler"}.BeginList(0)
}
func (na *_MerkleTreeLeafNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.KeyAssembler"}.AssignNull()
}
func (_MerkleTreeLeafNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.KeyAssembler"}.AssignBool(false)
}
func (_MerkleTreeLeafNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.KeyAssembler"}.AssignInt(0)
}
func (_MerkleTreeLeafNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MerkleTreeLeafNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Value":
		if ka.s&fieldBit__MerkleTreeLeafNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeLeafNode_Value}
		}
		ka.s += fieldBit__MerkleTreeLeafNode_Value
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeLeafNode", Key: &_String{k}}
	}
	return nil
}
func (_MerkleTreeLeafNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.KeyAssembler"}.AssignBytes(nil)
}
func (_MerkleTreeLeafNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MerkleTreeLeafNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MerkleTreeLeafNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (MerkleTreeLeafNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n MerkleTreeLeafNode) Representation() ipld.Node {
	return (*_MerkleTreeLeafNode__Repr)(n)
}

type _MerkleTreeLeafNode__Repr _MerkleTreeLeafNode

var (
	fieldName__MerkleTreeLeafNode_Value_serial = _String{"Value"}
)
var _ ipld.Node = &_MerkleTreeLeafNode__Repr{}

func (_MerkleTreeLeafNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_MerkleTreeLeafNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Value":
		return n.Value.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_MerkleTreeLeafNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_MerkleTreeLeafNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode.Repr"}.LookupByIndex(0)
}
func (n _MerkleTreeLeafNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_MerkleTreeLeafNode__Repr) MapIterator() ipld.MapIterator {
	return &_MerkleTreeLeafNode__ReprMapItr{n, 0}
}

type _MerkleTreeLeafNode__ReprMapItr struct {
	n   *_MerkleTreeLeafNode__Repr
	idx int
}

func (itr *_MerkleTreeLeafNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__MerkleTreeLeafNode_Value_serial
		v = itr.n.Value.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_MerkleTreeLeafNode__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_MerkleTreeLeafNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_MerkleTreeLeafNode__Repr) Length() int64 {
	l := 1
	return int64(l)
}
func (_MerkleTreeLeafNode__Repr) IsAbsent() bool {
	return false
}
func (_MerkleTreeLeafNode__Repr) IsNull() bool {
	return false
}
func (_MerkleTreeLeafNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode.Repr"}.AsBool()
}
func (_MerkleTreeLeafNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode.Repr"}.AsInt()
}
func (_MerkleTreeLeafNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode.Repr"}.AsFloat()
}
func (_MerkleTreeLeafNode__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode.Repr"}.AsString()
}
func (_MerkleTreeLeafNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode.Repr"}.AsBytes()
}
func (_MerkleTreeLeafNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.MerkleTreeLeafNode.Repr"}.AsLink()
}
func (_MerkleTreeLeafNode__Repr) Prototype() ipld.NodePrototype {
	return _MerkleTreeLeafNode__ReprPrototype{}
}

type _MerkleTreeLeafNode__ReprPrototype struct{}

func (_MerkleTreeLeafNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _MerkleTreeLeafNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _MerkleTreeLeafNode__ReprBuilder struct {
	_MerkleTreeLeafNode__ReprAssembler
}

func (nb *_MerkleTreeLeafNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MerkleTreeLeafNode__ReprBuilder) Reset() {
	var w _MerkleTreeLeafNode
	var m schema.Maybe
	*nb = _MerkleTreeLeafNode__ReprBuilder{_MerkleTreeLeafNode__ReprAssembler{w: &w, m: &m}}
}

type _MerkleTreeLeafNode__ReprAssembler struct {
	w     *_MerkleTreeLeafNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Value _Value__ReprAssembler
}

func (na *_MerkleTreeLeafNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Value.reset()
}
func (na *_MerkleTreeLeafNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MerkleTreeLeafNode{}
	}
	return na, nil
}
func (_MerkleTreeLeafNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode.Repr"}.BeginList(0)
}
func (na *_MerkleTreeLeafNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MerkleTreeLeafNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode.Repr"}.AssignBool(false)
}
func (_MerkleTreeLeafNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode.Repr"}.AssignInt(0)
}
func (_MerkleTreeLeafNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode.Repr"}.AssignFloat(0)
}
func (_MerkleTreeLeafNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode.Repr"}.AssignString("")
}
func (_MerkleTreeLeafNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode.Repr"}.AssignBytes(nil)
}
func (_MerkleTreeLeafNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeLeafNode.Repr"}.AssignLink(nil)
}
func (na *_MerkleTreeLeafNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MerkleTreeLeafNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.MerkleTreeLeafNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MerkleTreeLeafNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _MerkleTreeLeafNode__ReprPrototype{}
}
func (ma *_MerkleTreeLeafNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_MerkleTreeLeafNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Value":
		if ma.s&fieldBit__MerkleTreeLeafNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeLeafNode_Value_serial}
		}
		ma.s += fieldBit__MerkleTreeLeafNode_Value
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeLeafNode.Repr", Key: &_String{k}}
}
func (ma *_MerkleTreeLeafNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MerkleTreeLeafNode__ReprKeyAssembler)(ma)
}
func (ma *_MerkleTreeLeafNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_MerkleTreeLeafNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__MerkleTreeLeafNode_sufficient != fieldBits__MerkleTreeLeafNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__MerkleTreeLeafNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MerkleTreeLeafNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MerkleTreeLeafNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _MerkleTreeLeafNode__ReprKeyAssembler _MerkleTreeLeafNode__ReprAssembler

func (_MerkleTreeLeafNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_MerkleTreeLeafNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_MerkleTreeLeafNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.Repr.KeyAssembler"}.AssignNull()
}
func (_MerkleTreeLeafNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_MerkleTreeLeafNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_MerkleTreeLeafNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MerkleTreeLeafNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Value":
		if ka.s&fieldBit__MerkleTreeLeafNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__MerkleTreeLeafNode_Value_serial}
		}
		ka.s += fieldBit__MerkleTreeLeafNode_Value
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeLeafNode.Repr", Key: &_String{k}}
}
func (_MerkleTreeLeafNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_MerkleTreeLeafNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeLeafNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MerkleTreeLeafNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MerkleTreeLeafNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _MerkleTreeNode) AsInterface() _MerkleTreeNode__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	default:
		panic("invalid union state; how did you create this object?")
	}
}

type _MerkleTreeNode__Maybe struct {
	m schema.Maybe
	v MerkleTreeNode
}
type MaybeMerkleTreeNode = *_MerkleTreeNode__Maybe

func (m MaybeMerkleTreeNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMerkleTreeNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMerkleTreeNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMerkleTreeNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeMerkleTreeNode) Must() MerkleTreeNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	memberName__MerkleTreeNode_MerkleTreeInnerNode = _String{"MerkleTreeInnerNode"}
	memberName__MerkleTreeNode_MerkleTreeLeafNode  = _String{"MerkleTreeLeafNode"}
)
var _ ipld.Node = (MerkleTreeNode)(&_MerkleTreeNode{})
var _ schema.TypedNode = (MerkleTreeNode)(&_MerkleTreeNode{})

func (MerkleTreeNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n MerkleTreeNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "MerkleTreeInnerNode":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "MerkleTreeLeafNode":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n MerkleTreeNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (MerkleTreeNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode"}.LookupByIndex(0)
}
func (n MerkleTreeNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n MerkleTreeNode) MapIterator() ipld.MapIterator {
	return &_MerkleTreeNode__MapItr{n, false}
}

type _MerkleTreeNode__MapItr struct {
	n    MerkleTreeNode
	done bool
}

func (itr *_MerkleTreeNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__MerkleTreeNode_MerkleTreeInnerNode, &itr.n.x1
	case 2:
		k, v = &memberName__MerkleTreeNode_MerkleTreeLeafNode, &itr.n.x2
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_MerkleTreeNode__MapItr) Done() bool {
	return itr.done
}

func (MerkleTreeNode) ListIterator() ipld.ListIterator {
	return nil
}
func (MerkleTreeNode) Length() int64 {
	return 1
}
func (MerkleTreeNode) IsAbsent() bool {
	return false
}
func (MerkleTreeNode) IsNull() bool {
	return false
}
func (MerkleTreeNode) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode"}.AsBool()
}
func (MerkleTreeNode) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode"}.AsInt()
}
func (MerkleTreeNode) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode"}.AsFloat()
}
func (MerkleTreeNode) AsString() (string, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode"}.AsString()
}
func (MerkleTreeNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode"}.AsBytes()
}
func (MerkleTreeNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode"}.AsLink()
}
func (MerkleTreeNode) Prototype() ipld.NodePrototype {
	return _MerkleTreeNode__Prototype{}
}

type _MerkleTreeNode__Prototype struct{}

func (_MerkleTreeNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _MerkleTreeNode__Builder
	nb.Reset()
	return &nb
}

type _MerkleTreeNode__Builder struct {
	_MerkleTreeNode__Assembler
}

func (nb *_MerkleTreeNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MerkleTreeNode__Builder) Reset() {
	var w _MerkleTreeNode
	var m schema.Maybe
	*nb = _MerkleTreeNode__Builder{_MerkleTreeNode__Assembler{w: &w, m: &m}}
}

type _MerkleTreeNode__Assembler struct {
	w     *_MerkleTreeNode
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _MerkleTreeInnerNode__Assembler

	ca2 _MerkleTreeLeafNode__Assembler
	ca  uint
}

func (na *_MerkleTreeNode__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_MerkleTreeNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MerkleTreeNode{}
	}
	return na, nil
}
func (_MerkleTreeNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode"}.BeginList(0)
}
func (na *_MerkleTreeNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.MerkleTreeNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MerkleTreeNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode"}.AssignBool(false)
}
func (_MerkleTreeNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode"}.AssignInt(0)
}
func (_MerkleTreeNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode"}.AssignFloat(0)
}
func (_MerkleTreeNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode"}.AssignString("")
}
func (_MerkleTreeNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode"}.AssignBytes(nil)
}
func (_MerkleTreeNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode"}.AssignLink(nil)
}
func (na *_MerkleTreeNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MerkleTreeNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.MerkleTreeNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MerkleTreeNode__Assembler) Prototype() ipld.NodePrototype {
	return _MerkleTreeNode__Prototype{}
}
func (ma *_MerkleTreeNode__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_MerkleTreeNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.MerkleTreeNode", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "MerkleTreeInnerNode":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "MerkleTreeLeafNode":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeNode", Key: &_String{k}}
}
func (ma *_MerkleTreeNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MerkleTreeNode__KeyAssembler)(ma)
}
func (ma *_MerkleTreeNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_MerkleTreeNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.MerkleTreeNode", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MerkleTreeNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MerkleTreeNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "MerkleTreeInnerNode":
		return _MerkleTreeInnerNode__Prototype{}
	case "MerkleTreeLeafNode":
		return _MerkleTreeLeafNode__Prototype{}
	default:
		return nil
	}
}

type _MerkleTreeNode__KeyAssembler _MerkleTreeNode__Assembler

func (_MerkleTreeNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.KeyAssembler"}.BeginMap(0)
}
func (_MerkleTreeNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.KeyAssembler"}.BeginList(0)
}
func (na *_MerkleTreeNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.KeyAssembler"}.AssignNull()
}
func (_MerkleTreeNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.KeyAssembler"}.AssignBool(false)
}
func (_MerkleTreeNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.KeyAssembler"}.AssignInt(0)
}
func (_MerkleTreeNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MerkleTreeNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.MerkleTreeNode", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "MerkleTreeInnerNode":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "MerkleTreeLeafNode":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeNode", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_MerkleTreeNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.KeyAssembler"}.AssignBytes(nil)
}
func (_MerkleTreeNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MerkleTreeNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MerkleTreeNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (MerkleTreeNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n MerkleTreeNode) Representation() ipld.Node {
	return (*_MerkleTreeNode__Repr)(n)
}

type _MerkleTreeNode__Repr _MerkleTreeNode

var (
	memberName__MerkleTreeNode_MerkleTreeInnerNode_serial = _String{"inner"}
	memberName__MerkleTreeNode_MerkleTreeLeafNode_serial  = _String{"leaf"}
)
var _ ipld.Node = &_MerkleTreeNode__Repr{}

func (_MerkleTreeNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_MerkleTreeNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "inner":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "leaf":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_MerkleTreeNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_MerkleTreeNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode.Repr"}.LookupByIndex(0)
}
func (n _MerkleTreeNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_MerkleTreeNode__Repr) MapIterator() ipld.MapIterator {
	return &_MerkleTreeNode__ReprMapItr{n, false}
}

type _MerkleTreeNode__ReprMapItr struct {
	n    *_MerkleTreeNode__Repr
	done bool
}

func (itr *_MerkleTreeNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__MerkleTreeNode_MerkleTreeInnerNode_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__MerkleTreeNode_MerkleTreeLeafNode_serial, itr.n.x2.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_MerkleTreeNode__ReprMapItr) Done() bool {
	return itr.done
}

func (_MerkleTreeNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_MerkleTreeNode__Repr) Length() int64 {
	return 1
}
func (_MerkleTreeNode__Repr) IsAbsent() bool {
	return false
}
func (_MerkleTreeNode__Repr) IsNull() bool {
	return false
}
func (_MerkleTreeNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode.Repr"}.AsBool()
}
func (_MerkleTreeNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode.Repr"}.AsInt()
}
func (_MerkleTreeNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode.Repr"}.AsFloat()
}
func (_MerkleTreeNode__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode.Repr"}.AsString()
}
func (_MerkleTreeNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode.Repr"}.AsBytes()
}
func (_MerkleTreeNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.MerkleTreeNode.Repr"}.AsLink()
}
func (_MerkleTreeNode__Repr) Prototype() ipld.NodePrototype {
	return _MerkleTreeNode__ReprPrototype{}
}

type _MerkleTreeNode__ReprPrototype struct{}

func (_MerkleTreeNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _MerkleTreeNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _MerkleTreeNode__ReprBuilder struct {
	_MerkleTreeNode__ReprAssembler
}

func (nb *_MerkleTreeNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_MerkleTreeNode__ReprBuilder) Reset() {
	var w _MerkleTreeNode
	var m schema.Maybe
	*nb = _MerkleTreeNode__ReprBuilder{_MerkleTreeNode__ReprAssembler{w: &w, m: &m}}
}

type _MerkleTreeNode__ReprAssembler struct {
	w     *_MerkleTreeNode
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _MerkleTreeInnerNode__ReprAssembler

	ca2 _MerkleTreeLeafNode__ReprAssembler
	ca  uint
}

func (na *_MerkleTreeNode__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_MerkleTreeNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_MerkleTreeNode{}
	}
	return na, nil
}
func (_MerkleTreeNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode.Repr"}.BeginList(0)
}
func (na *_MerkleTreeNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.MerkleTreeNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_MerkleTreeNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode.Repr"}.AssignBool(false)
}
func (_MerkleTreeNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode.Repr"}.AssignInt(0)
}
func (_MerkleTreeNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode.Repr"}.AssignFloat(0)
}
func (_MerkleTreeNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode.Repr"}.AssignString("")
}
func (_MerkleTreeNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode.Repr"}.AssignBytes(nil)
}
func (_MerkleTreeNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.MerkleTreeNode.Repr"}.AssignLink(nil)
}
func (na *_MerkleTreeNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_MerkleTreeNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.MerkleTreeNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_MerkleTreeNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _MerkleTreeNode__ReprPrototype{}
}
func (ma *_MerkleTreeNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_MerkleTreeNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.MerkleTreeNode.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "inner":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "leaf":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeNode.Repr", Key: &_String{k}}
}
func (ma *_MerkleTreeNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_MerkleTreeNode__ReprKeyAssembler)(ma)
}
func (ma *_MerkleTreeNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_MerkleTreeNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.MerkleTreeNode.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_MerkleTreeNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_MerkleTreeNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "MerkleTreeInnerNode":
		return _MerkleTreeInnerNode__ReprPrototype{}
	case "MerkleTreeLeafNode":
		return _MerkleTreeLeafNode__ReprPrototype{}
	default:
		return nil
	}
}

type _MerkleTreeNode__ReprKeyAssembler _MerkleTreeNode__ReprAssembler

func (_MerkleTreeNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_MerkleTreeNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_MerkleTreeNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.Repr.KeyAssembler"}.AssignNull()
}
func (_MerkleTreeNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_MerkleTreeNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_MerkleTreeNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_MerkleTreeNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.MerkleTreeNode.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "inner":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "leaf":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.MerkleTreeNode.Repr", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_MerkleTreeNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_MerkleTreeNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.MerkleTreeNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_MerkleTreeNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_MerkleTreeNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _Part) FieldIndex() Uint {
	return &n.Index
}
func (n _Part) FieldBytes() HexBytes {
	return &n.Bytes
}
func (n _Part) FieldProof() Proof {
	return &n.Proof
}

type _Part__Maybe struct {
	m schema.Maybe
	v Part
}
type MaybePart = *_Part__Maybe

func (m MaybePart) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePart) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePart) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePart) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybePart) Must() Part {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Part_Index = _String{"Index"}
	fieldName__Part_Bytes = _String{"Bytes"}
	fieldName__Part_Proof = _String{"Proof"}
)
var _ ipld.Node = (Part)(&_Part{})
var _ schema.TypedNode = (Part)(&_Part{})

func (Part) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Part) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Index":
		return &n.Index, nil
	case "Bytes":
		return &n.Bytes, nil
	case "Proof":
		return &n.Proof, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Part) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Part) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Part"}.LookupByIndex(0)
}
func (n Part) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Part) MapIterator() ipld.MapIterator {
	return &_Part__MapItr{n, 0}
}

type _Part__MapItr struct {
	n   Part
	idx int
}

func (itr *_Part__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Part_Index
		v = &itr.n.Index
	case 1:
		k = &fieldName__Part_Bytes
		v = &itr.n.Bytes
	case 2:
		k = &fieldName__Part_Proof
		v = &itr.n.Proof
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Part__MapItr) Done() bool {
	return itr.idx >= 3
}

func (Part) ListIterator() ipld.ListIterator {
	return nil
}
func (Part) Length() int64 {
	return 3
}
func (Part) IsAbsent() bool {
	return false
}
func (Part) IsNull() bool {
	return false
}
func (Part) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Part"}.AsBool()
}
func (Part) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Part"}.AsInt()
}
func (Part) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Part"}.AsFloat()
}
func (Part) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Part"}.AsString()
}
func (Part) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Part"}.AsBytes()
}
func (Part) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Part"}.AsLink()
}
func (Part) Prototype() ipld.NodePrototype {
	return _Part__Prototype{}
}

type _Part__Prototype struct{}

func (_Part__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Part__Builder
	nb.Reset()
	return &nb
}

type _Part__Builder struct {
	_Part__Assembler
}

func (nb *_Part__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Part__Builder) Reset() {
	var w _Part
	var m schema.Maybe
	*nb = _Part__Builder{_Part__Assembler{w: &w, m: &m}}
}

type _Part__Assembler struct {
	w     *_Part
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Index _Uint__Assembler
	ca_Bytes _HexBytes__Assembler
	ca_Proof _Proof__Assembler
}

func (na *_Part__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Index.reset()
	na.ca_Bytes.reset()
	na.ca_Proof.reset()
}

var (
	fieldBit__Part_Index       = 1 << 0
	fieldBit__Part_Bytes       = 1 << 1
	fieldBit__Part_Proof       = 1 << 2
	fieldBits__Part_sufficient = 0 + 1<<0 + 1<<1 + 1<<2
)

func (na *_Part__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Part{}
	}
	return na, nil
}
func (_Part__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Part"}.BeginList(0)
}
func (na *_Part__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Part"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Part__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignBool(false)
}
func (_Part__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignInt(0)
}
func (_Part__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignFloat(0)
}
func (_Part__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignString("")
}
func (_Part__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignBytes(nil)
}
func (_Part__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignLink(nil)
}
func (na *_Part__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Part); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Part", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Part__Assembler) Prototype() ipld.NodePrototype {
	return _Part__Prototype{}
}
func (ma *_Part__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Index.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Bytes.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Proof.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Part__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Index":
		if ma.s&fieldBit__Part_Index != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Index}
		}
		ma.s += fieldBit__Part_Index
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index, nil
	case "Bytes":
		if ma.s&fieldBit__Part_Bytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Bytes}
		}
		ma.s += fieldBit__Part_Bytes
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Bytes.w = &ma.w.Bytes
		ma.ca_Bytes.m = &ma.cm
		return &ma.ca_Bytes, nil
	case "Proof":
		if ma.s&fieldBit__Part_Proof != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Proof}
		}
		ma.s += fieldBit__Part_Proof
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Proof.w = &ma.w.Proof
		ma.ca_Proof.m = &ma.cm
		return &ma.ca_Proof, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Part", Key: &_String{k}}
}
func (ma *_Part__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Part__KeyAssembler)(ma)
}
func (ma *_Part__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index
	case 1:
		ma.ca_Bytes.w = &ma.w.Bytes
		ma.ca_Bytes.m = &ma.cm
		return &ma.ca_Bytes
	case 2:
		ma.ca_Proof.w = &ma.w.Proof
		ma.ca_Proof.m = &ma.cm
		return &ma.ca_Proof
	default:
		panic("unreachable")
	}
}
func (ma *_Part__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Part_sufficient != fieldBits__Part_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Part_Index == 0 {
			err.Missing = append(err.Missing, "Index")
		}
		if ma.s&fieldBit__Part_Bytes == 0 {
			err.Missing = append(err.Missing, "Bytes")
		}
		if ma.s&fieldBit__Part_Proof == 0 {
			err.Missing = append(err.Missing, "Proof")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Part__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Part__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Part__KeyAssembler _Part__Assembler

func (_Part__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.BeginMap(0)
}
func (_Part__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.BeginList(0)
}
func (na *_Part__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignNull()
}
func (_Part__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignBool(false)
}
func (_Part__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignInt(0)
}
func (_Part__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Part__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Index":
		if ka.s&fieldBit__Part_Index != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Index}
		}
		ka.s += fieldBit__Part_Index
		ka.state = maState_expectValue
		ka.f = 0
	case "Bytes":
		if ka.s&fieldBit__Part_Bytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Bytes}
		}
		ka.s += fieldBit__Part_Bytes
		ka.state = maState_expectValue
		ka.f = 1
	case "Proof":
		if ka.s&fieldBit__Part_Proof != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Proof}
		}
		ka.s += fieldBit__Part_Proof
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Part", Key: &_String{k}}
	}
	return nil
}
func (_Part__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignBytes(nil)
}
func (_Part__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Part__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Part__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Part) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Part) Representation() ipld.Node {
	return (*_Part__Repr)(n)
}

type _Part__Repr _Part

var (
	fieldName__Part_Index_serial = _String{"Index"}
	fieldName__Part_Bytes_serial = _String{"Bytes"}
	fieldName__Part_Proof_serial = _String{"Proof"}
)
var _ ipld.Node = &_Part__Repr{}

func (_Part__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Part__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Index":
		return n.Index.Representation(), nil
	case "Bytes":
		return n.Bytes.Representation(), nil
	case "Proof":
		return n.Proof.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Part__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Part__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.LookupByIndex(0)
}
func (n _Part__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Part__Repr) MapIterator() ipld.MapIterator {
	return &_Part__ReprMapItr{n, 0}
}

type _Part__ReprMapItr struct {
	n   *_Part__Repr
	idx int
}

func (itr *_Part__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Part_Index_serial
		v = itr.n.Index.Representation()
	case 1:
		k = &fieldName__Part_Bytes_serial
		v = itr.n.Bytes.Representation()
	case 2:
		k = &fieldName__Part_Proof_serial
		v = itr.n.Proof.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Part__ReprMapItr) Done() bool {
	return itr.idx >= 3
}
func (_Part__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Part__Repr) Length() int64 {
	l := 3
	return int64(l)
}
func (_Part__Repr) IsAbsent() bool {
	return false
}
func (_Part__Repr) IsNull() bool {
	return false
}
func (_Part__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsBool()
}
func (_Part__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsInt()
}
func (_Part__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsFloat()
}
func (_Part__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsString()
}
func (_Part__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsBytes()
}
func (_Part__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsLink()
}
func (_Part__Repr) Prototype() ipld.NodePrototype {
	return _Part__ReprPrototype{}
}

type _Part__ReprPrototype struct{}

func (_Part__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Part__ReprBuilder
	nb.Reset()
	return &nb
}

type _Part__ReprBuilder struct {
	_Part__ReprAssembler
}

func (nb *_Part__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Part__ReprBuilder) Reset() {
	var w _Part
	var m schema.Maybe
	*nb = _Part__ReprBuilder{_Part__ReprAssembler{w: &w, m: &m}}
}

type _Part__ReprAssembler struct {
	w     *_Part
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Index _Uint__ReprAssembler
	ca_Bytes _HexBytes__ReprAssembler
	ca_Proof _Proof__ReprAssembler
}

func (na *_Part__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Index.reset()
	na.ca_Bytes.reset()
	na.ca_Proof.reset()
}
func (na *_Part__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Part{}
	}
	return na, nil
}
func (_Part__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.BeginList(0)
}
func (na *_Part__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Part.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Part__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignBool(false)
}
func (_Part__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignInt(0)
}
func (_Part__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignFloat(0)
}
func (_Part__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignString("")
}
func (_Part__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignBytes(nil)
}
func (_Part__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignLink(nil)
}
func (na *_Part__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Part); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Part.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Part__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Part__ReprPrototype{}
}
func (ma *_Part__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Part__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Index":
		if ma.s&fieldBit__Part_Index != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Index_serial}
		}
		ma.s += fieldBit__Part_Index
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index, nil
	case "Bytes":
		if ma.s&fieldBit__Part_Bytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Bytes_serial}
		}
		ma.s += fieldBit__Part_Bytes
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Bytes.w = &ma.w.Bytes
		ma.ca_Bytes.m = &ma.cm
		return &ma.ca_Bytes, nil
	case "Proof":
		if ma.s&fieldBit__Part_Proof != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Proof_serial}
		}
		ma.s += fieldBit__Part_Proof
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Proof.w = &ma.w.Proof
		ma.ca_Proof.m = &ma.cm
		return &ma.ca_Proof, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Part.Repr", Key: &_String{k}}
}
func (ma *_Part__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Part__ReprKeyAssembler)(ma)
}
func (ma *_Part__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index
	case 1:
		ma.ca_Bytes.w = &ma.w.Bytes
		ma.ca_Bytes.m = &ma.cm
		return &ma.ca_Bytes
	case 2:
		ma.ca_Proof.w = &ma.w.Proof
		ma.ca_Proof.m = &ma.cm
		return &ma.ca_Proof
	default:
		panic("unreachable")
	}
}
func (ma *_Part__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Part_sufficient != fieldBits__Part_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Part_Index == 0 {
			err.Missing = append(err.Missing, "Index")
		}
		if ma.s&fieldBit__Part_Bytes == 0 {
			err.Missing = append(err.Missing, "Bytes")
		}
		if ma.s&fieldBit__Part_Proof == 0 {
			err.Missing = append(err.Missing, "Proof")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Part__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Part__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Part__ReprKeyAssembler _Part__ReprAssembler

func (_Part__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Part__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Part__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignNull()
}
func (_Part__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Part__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Part__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Part__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Index":
		if ka.s&fieldBit__Part_Index != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Index_serial}
		}
		ka.s += fieldBit__Part_Index
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Bytes":
		if ka.s&fieldBit__Part_Bytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Bytes_serial}
		}
		ka.s += fieldBit__Part_Bytes
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Proof":
		if ka.s&fieldBit__Part_Proof != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Proof_serial}
		}
		ka.s += fieldBit__Part_Proof
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Part.Repr", Key: &_String{k}}
}
func (_Part__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Part__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Part__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Part__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_PartSet) Lookup(idx int64) Part {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_PartSet) LookupMaybe(idx int64) MaybePart {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Part__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _PartSet__valueAbsent = _Part__Maybe{m: schema.Maybe_Absent}

func (n PartSet) Iterator() *PartSet__Itr {
	return &PartSet__Itr{n, 0}
}

type PartSet__Itr struct {
	n   PartSet
	idx int
}

func (itr *PartSet__Itr) Next() (idx int64, v Part) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *PartSet__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _PartSet__Maybe struct {
	m schema.Maybe
	v PartSet
}
type MaybePartSet = *_PartSet__Maybe

func (m MaybePartSet) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePartSet) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePartSet) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePartSet) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybePartSet) Must() PartSet {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (PartSet)(&_PartSet{})
var _ schema.TypedNode = (PartSet)(&_PartSet{})

func (PartSet) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (PartSet) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.PartSet"}.LookupByString("")
}
func (n PartSet) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n PartSet) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n PartSet) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.PartSet", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (PartSet) MapIterator() ipld.MapIterator {
	return nil
}
func (n PartSet) ListIterator() ipld.ListIterator {
	return &_PartSet__ListItr{n, 0}
}

type _PartSet__ListItr struct {
	n   PartSet
	idx int
}

func (itr *_PartSet__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_PartSet__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n PartSet) Length() int64 {
	return int64(len(n.x))
}
func (PartSet) IsAbsent() bool {
	return false
}
func (PartSet) IsNull() bool {
	return false
}
func (PartSet) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsBool()
}
func (PartSet) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsInt()
}
func (PartSet) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsFloat()
}
func (PartSet) AsString() (string, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsString()
}
func (PartSet) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsBytes()
}
func (PartSet) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsLink()
}
func (PartSet) Prototype() ipld.NodePrototype {
	return _PartSet__Prototype{}
}

type _PartSet__Prototype struct{}

func (_PartSet__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _PartSet__Builder
	nb.Reset()
	return &nb
}

type _PartSet__Builder struct {
	_PartSet__Assembler
}

func (nb *_PartSet__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PartSet__Builder) Reset() {
	var w _PartSet
	var m schema.Maybe
	*nb = _PartSet__Builder{_PartSet__Assembler{w: &w, m: &m}}
}

type _PartSet__Assembler struct {
	w     *_PartSet
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Part__Assembler
}

func (na *_PartSet__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_PartSet__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.BeginMap(0)
}
func (na *_PartSet__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_PartSet{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Part, 0, sizeHint)
	}
	return na, nil
}
func (na *_PartSet__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PartSet__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignBool(false)
}
func (_PartSet__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignInt(0)
}
func (_PartSet__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignFloat(0)
}
func (_PartSet__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignString("")
}
func (_PartSet__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignBytes(nil)
}
func (_PartSet__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignLink(nil)
}
func (na *_PartSet__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PartSet); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.PartSet", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PartSet__Assembler) Prototype() ipld.NodePrototype {
	return _PartSet__Prototype{}
}
func (la *_PartSet__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_PartSet__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Part{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_PartSet__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_PartSet__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Part__Prototype{}
}
func (PartSet) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n PartSet) Representation() ipld.Node {
	return (*_PartSet__Repr)(n)
}

type _PartSet__Repr _PartSet

var _ ipld.Node = &_PartSet__Repr{}

func (_PartSet__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_PartSet__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.LookupByString("")
}
func (nr *_PartSet__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (PartSet)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Part).Representation(), nil
}
func (nr *_PartSet__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (PartSet)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Part).Representation(), nil
}
func (n _PartSet__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.PartSet.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_PartSet__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_PartSet__Repr) ListIterator() ipld.ListIterator {
	return &_PartSet__ReprListItr{(PartSet)(nr), 0}
}

type _PartSet__ReprListItr _PartSet__ListItr

func (itr *_PartSet__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_PartSet__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Part).Representation(), nil
}
func (itr *_PartSet__ReprListItr) Done() bool {
	return (*_PartSet__ListItr)(itr).Done()
}

func (rn *_PartSet__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_PartSet__Repr) IsAbsent() bool {
	return false
}
func (_PartSet__Repr) IsNull() bool {
	return false
}
func (_PartSet__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsBool()
}
func (_PartSet__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsInt()
}
func (_PartSet__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsFloat()
}
func (_PartSet__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsString()
}
func (_PartSet__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsBytes()
}
func (_PartSet__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsLink()
}
func (_PartSet__Repr) Prototype() ipld.NodePrototype {
	return _PartSet__ReprPrototype{}
}

type _PartSet__ReprPrototype struct{}

func (_PartSet__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _PartSet__ReprBuilder
	nb.Reset()
	return &nb
}

type _PartSet__ReprBuilder struct {
	_PartSet__ReprAssembler
}

func (nb *_PartSet__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PartSet__ReprBuilder) Reset() {
	var w _PartSet
	var m schema.Maybe
	*nb = _PartSet__ReprBuilder{_PartSet__ReprAssembler{w: &w, m: &m}}
}

type _PartSet__ReprAssembler struct {
	w     *_PartSet
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Part__ReprAssembler
}

func (na *_PartSet__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_PartSet__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.BeginMap(0)
}
func (na *_PartSet__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_PartSet{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Part, 0, sizeHint)
	}
	return na, nil
}
func (na *_PartSet__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.PartSet.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PartSet__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignBool(false)
}
func (_PartSet__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignInt(0)
}
func (_PartSet__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignFloat(0)
}
func (_PartSet__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignString("")
}
func (_PartSet__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignBytes(nil)
}
func (_PartSet__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignLink(nil)
}
func (na *_PartSet__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PartSet); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.PartSet.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PartSet__ReprAssembler) Prototype() ipld.NodePrototype {
	return _PartSet__ReprPrototype{}
}
func (la *_PartSet__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_PartSet__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Part{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_PartSet__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_PartSet__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Part__ReprPrototype{}
}

func (n _PartSetHeader) FieldTotal() Uint {
	return &n.Total
}
func (n _PartSetHeader) FieldHash() Link {
	return &n.Hash
}

type _PartSetHeader__Maybe struct {
	m schema.Maybe
	v PartSetHeader
}
type MaybePartSetHeader = *_PartSetHeader__Maybe

func (m MaybePartSetHeader) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePartSetHeader) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePartSetHeader) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePartSetHeader) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybePartSetHeader) Must() PartSetHeader {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__PartSetHeader_Total = _String{"Total"}
	fieldName__PartSetHeader_Hash  = _String{"Hash"}
)
var _ ipld.Node = (PartSetHeader)(&_PartSetHeader{})
var _ schema.TypedNode = (PartSetHeader)(&_PartSetHeader{})

func (PartSetHeader) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n PartSetHeader) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Total":
		return &n.Total, nil
	case "Hash":
		return &n.Hash, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n PartSetHeader) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (PartSetHeader) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.LookupByIndex(0)
}
func (n PartSetHeader) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n PartSetHeader) MapIterator() ipld.MapIterator {
	return &_PartSetHeader__MapItr{n, 0}
}

type _PartSetHeader__MapItr struct {
	n   PartSetHeader
	idx int
}

func (itr *_PartSetHeader__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__PartSetHeader_Total
		v = &itr.n.Total
	case 1:
		k = &fieldName__PartSetHeader_Hash
		v = &itr.n.Hash
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_PartSetHeader__MapItr) Done() bool {
	return itr.idx >= 2
}

func (PartSetHeader) ListIterator() ipld.ListIterator {
	return nil
}
func (PartSetHeader) Length() int64 {
	return 2
}
func (PartSetHeader) IsAbsent() bool {
	return false
}
func (PartSetHeader) IsNull() bool {
	return false
}
func (PartSetHeader) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsBool()
}
func (PartSetHeader) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsInt()
}
func (PartSetHeader) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsFloat()
}
func (PartSetHeader) AsString() (string, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsString()
}
func (PartSetHeader) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsBytes()
}
func (PartSetHeader) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsLink()
}
func (PartSetHeader) Prototype() ipld.NodePrototype {
	return _PartSetHeader__Prototype{}
}

type _PartSetHeader__Prototype struct{}

func (_PartSetHeader__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _PartSetHeader__Builder
	nb.Reset()
	return &nb
}

type _PartSetHeader__Builder struct {
	_PartSetHeader__Assembler
}

func (nb *_PartSetHeader__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PartSetHeader__Builder) Reset() {
	var w _PartSetHeader
	var m schema.Maybe
	*nb = _PartSetHeader__Builder{_PartSetHeader__Assembler{w: &w, m: &m}}
}

type _PartSetHeader__Assembler struct {
	w     *_PartSetHeader
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Total _Uint__Assembler
	ca_Hash  _Link__Assembler
}

func (na *_PartSetHeader__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Total.reset()
	na.ca_Hash.reset()
}

var (
	fieldBit__PartSetHeader_Total       = 1 << 0
	fieldBit__PartSetHeader_Hash        = 1 << 1
	fieldBits__PartSetHeader_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_PartSetHeader__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_PartSetHeader{}
	}
	return na, nil
}
func (_PartSetHeader__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.BeginList(0)
}
func (na *_PartSetHeader__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PartSetHeader__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignBool(false)
}
func (_PartSetHeader__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignInt(0)
}
func (_PartSetHeader__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignFloat(0)
}
func (_PartSetHeader__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignString("")
}
func (_PartSetHeader__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignBytes(nil)
}
func (_PartSetHeader__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignLink(nil)
}
func (na *_PartSetHeader__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PartSetHeader); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.PartSetHeader", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PartSetHeader__Assembler) Prototype() ipld.NodePrototype {
	return _PartSetHeader__Prototype{}
}
func (ma *_PartSetHeader__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Total.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Hash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_PartSetHeader__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Total":
		if ma.s&fieldBit__PartSetHeader_Total != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Total}
		}
		ma.s += fieldBit__PartSetHeader_Total
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total, nil
	case "Hash":
		if ma.s&fieldBit__PartSetHeader_Hash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Hash}
		}
		ma.s += fieldBit__PartSetHeader_Hash
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.PartSetHeader", Key: &_String{k}}
}
func (ma *_PartSetHeader__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_PartSetHeader__KeyAssembler)(ma)
}
func (ma *_PartSetHeader__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total
	case 1:
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash
	default:
		panic("unreachable")
	}
}
func (ma *_PartSetHeader__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__PartSetHeader_sufficient != fieldBits__PartSetHeader_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__PartSetHeader_Total == 0 {
			err.Missing = append(err.Missing, "Total")
		}
		if ma.s&fieldBit__PartSetHeader_Hash == 0 {
			err.Missing = append(err.Missing, "Hash")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_PartSetHeader__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_PartSetHeader__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _PartSetHeader__KeyAssembler _PartSetHeader__Assembler

func (_PartSetHeader__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.BeginMap(0)
}
func (_PartSetHeader__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.BeginList(0)
}
func (na *_PartSetHeader__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignNull()
}
func (_PartSetHeader__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignBool(false)
}
func (_PartSetHeader__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignInt(0)
}
func (_PartSetHeader__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignFloat(0)
}
func (ka *_PartSetHeader__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Total":
		if ka.s&fieldBit__PartSetHeader_Total != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Total}
		}
		ka.s += fieldBit__PartSetHeader_Total
		ka.state = maState_expectValue
		ka.f = 0
	case "Hash":
		if ka.s&fieldBit__PartSetHeader_Hash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Hash}
		}
		ka.s += fieldBit__PartSetHeader_Hash
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.PartSetHeader", Key: &_String{k}}
	}
	return nil
}
func (_PartSetHeader__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignBytes(nil)
}
func (_PartSetHeader__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignLink(nil)
}
func (ka *_PartSetHeader__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_PartSetHeader__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (PartSetHeader) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n PartSetHeader) Representation() ipld.Node {
	return (*_PartSetHeader__Repr)(n)
}

type _PartSetHeader__Repr _PartSetHeader

var (
	fieldName__PartSetHeader_Total_serial = _String{"Total"}
	fieldName__PartSetHeader_Hash_serial  = _String{"Hash"}
)
var _ ipld.Node = &_PartSetHeader__Repr{}

func (_PartSetHeader__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_PartSetHeader__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Total":
		return n.Total.Representation(), nil
	case "Hash":
		return n.Hash.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_PartSetHeader__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_PartSetHeader__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.LookupByIndex(0)
}
func (n _PartSetHeader__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_PartSetHeader__Repr) MapIterator() ipld.MapIterator {
	return &_PartSetHeader__ReprMapItr{n, 0}
}

type _PartSetHeader__ReprMapItr struct {
	n   *_PartSetHeader__Repr
	idx int
}

func (itr *_PartSetHeader__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__PartSetHeader_Total_serial
		v = itr.n.Total.Representation()
	case 1:
		k = &fieldName__PartSetHeader_Hash_serial
		v = itr.n.Hash.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_PartSetHeader__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_PartSetHeader__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_PartSetHeader__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_PartSetHeader__Repr) IsAbsent() bool {
	return false
}
func (_PartSetHeader__Repr) IsNull() bool {
	return false
}
func (_PartSetHeader__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsBool()
}
func (_PartSetHeader__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsInt()
}
func (_PartSetHeader__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsFloat()
}
func (_PartSetHeader__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsString()
}
func (_PartSetHeader__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsBytes()
}
func (_PartSetHeader__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsLink()
}
func (_PartSetHeader__Repr) Prototype() ipld.NodePrototype {
	return _PartSetHeader__ReprPrototype{}
}

type _PartSetHeader__ReprPrototype struct{}

func (_PartSetHeader__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _PartSetHeader__ReprBuilder
	nb.Reset()
	return &nb
}

type _PartSetHeader__ReprBuilder struct {
	_PartSetHeader__ReprAssembler
}

func (nb *_PartSetHeader__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PartSetHeader__ReprBuilder) Reset() {
	var w _PartSetHeader
	var m schema.Maybe
	*nb = _PartSetHeader__ReprBuilder{_PartSetHeader__ReprAssembler{w: &w, m: &m}}
}

type _PartSetHeader__ReprAssembler struct {
	w     *_PartSetHeader
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Total _Uint__ReprAssembler
	ca_Hash  _Link__ReprAssembler
}

func (na *_PartSetHeader__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Total.reset()
	na.ca_Hash.reset()
}
func (na *_PartSetHeader__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_PartSetHeader{}
	}
	return na, nil
}
func (_PartSetHeader__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.BeginList(0)
}
func (na *_PartSetHeader__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PartSetHeader__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignBool(false)
}
func (_PartSetHeader__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignInt(0)
}
func (_PartSetHeader__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignFloat(0)
}
func (_PartSetHeader__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignString("")
}
func (_PartSetHeader__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignBytes(nil)
}
func (_PartSetHeader__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignLink(nil)
}
func (na *_PartSetHeader__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PartSetHeader); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.PartSetHeader.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PartSetHeader__ReprAssembler) Prototype() ipld.NodePrototype {
	return _PartSetHeader__ReprPrototype{}
}
func (ma *_PartSetHeader__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_PartSetHeader__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Total":
		if ma.s&fieldBit__PartSetHeader_Total != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Total_serial}
		}
		ma.s += fieldBit__PartSetHeader_Total
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total, nil
	case "Hash":
		if ma.s&fieldBit__PartSetHeader_Hash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Hash_serial}
		}
		ma.s += fieldBit__PartSetHeader_Hash
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.PartSetHeader.Repr", Key: &_String{k}}
}
func (ma *_PartSetHeader__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_PartSetHeader__ReprKeyAssembler)(ma)
}
func (ma *_PartSetHeader__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total
	case 1:
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash
	default:
		panic("unreachable")
	}
}
func (ma *_PartSetHeader__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__PartSetHeader_sufficient != fieldBits__PartSetHeader_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__PartSetHeader_Total == 0 {
			err.Missing = append(err.Missing, "Total")
		}
		if ma.s&fieldBit__PartSetHeader_Hash == 0 {
			err.Missing = append(err.Missing, "Hash")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_PartSetHeader__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_PartSetHeader__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _PartSetHeader__ReprKeyAssembler _PartSetHeader__ReprAssembler

func (_PartSetHeader__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.BeginMap(0)
}
func (_PartSetHeader__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_PartSetHeader__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignNull()
}
func (_PartSetHeader__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignBool(false)
}
func (_PartSetHeader__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignInt(0)
}
func (_PartSetHeader__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_PartSetHeader__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Total":
		if ka.s&fieldBit__PartSetHeader_Total != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Total_serial}
		}
		ka.s += fieldBit__PartSetHeader_Total
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Hash":
		if ka.s&fieldBit__PartSetHeader_Hash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Hash_serial}
		}
		ka.s += fieldBit__PartSetHeader_Hash
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.PartSetHeader.Repr", Key: &_String{k}}
}
func (_PartSetHeader__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_PartSetHeader__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_PartSetHeader__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_PartSetHeader__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n PrivKey) Bytes() []byte {
	return n.x
}
func (_PrivKey__Prototype) FromBytes(v []byte) (PrivKey, error) {
	n := _PrivKey{v}
	return &n, nil
}

type _PrivKey__Maybe struct {
	m schema.Maybe
	v PrivKey
}
type MaybePrivKey = *_PrivKey__Maybe

func (m MaybePrivKey) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePrivKey) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePrivKey) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePrivKey) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybePrivKey) Must() PrivKey {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (PrivKey)(&_PrivKey{})
var _ schema.TypedNode = (PrivKey)(&_PrivKey{})

func (PrivKey) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (PrivKey) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.LookupByString("")
}
func (PrivKey) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.LookupByNode(nil)
}
func (PrivKey) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.LookupByIndex(0)
}
func (PrivKey) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.LookupBySegment(seg)
}
func (PrivKey) MapIterator() ipld.MapIterator {
	return nil
}
func (PrivKey) ListIterator() ipld.ListIterator {
	return nil
}
func (PrivKey) Length() int64 {
	return -1
}
func (PrivKey) IsAbsent() bool {
	return false
}
func (PrivKey) IsNull() bool {
	return false
}
func (PrivKey) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.AsBool()
}
func (PrivKey) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.AsInt()
}
func (PrivKey) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.AsFloat()
}
func (PrivKey) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.AsString()
}
func (n PrivKey) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (PrivKey) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.AsLink()
}
func (PrivKey) Prototype() ipld.NodePrototype {
	return _PrivKey__Prototype{}
}

type _PrivKey__Prototype struct{}

func (_PrivKey__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _PrivKey__Builder
	nb.Reset()
	return &nb
}

type _PrivKey__Builder struct {
	_PrivKey__Assembler
}

func (nb *_PrivKey__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PrivKey__Builder) Reset() {
	var w _PrivKey
	var m schema.Maybe
	*nb = _PrivKey__Builder{_PrivKey__Assembler{w: &w, m: &m}}
}

type _PrivKey__Assembler struct {
	w *_PrivKey
	m *schema.Maybe
}

func (na *_PrivKey__Assembler) reset() {}
func (_PrivKey__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.BeginMap(0)
}
func (_PrivKey__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.BeginList(0)
}
func (na *_PrivKey__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_PrivKey__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignBool(false)
}
func (_PrivKey__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignInt(0)
}
func (_PrivKey__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignFloat(0)
}
func (_PrivKey__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignString("")
}
func (na *_PrivKey__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_PrivKey{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_PrivKey__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignLink(nil)
}
func (na *_PrivKey__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PrivKey); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_PrivKey__Assembler) Prototype() ipld.NodePrototype {
	return _PrivKey__Prototype{}
}
func (PrivKey) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n PrivKey) Representation() ipld.Node {
	return (*_PrivKey__Repr)(n)
}

type _PrivKey__Repr = _PrivKey

var _ ipld.Node = &_PrivKey__Repr{}

type _PrivKey__ReprPrototype = _PrivKey__Prototype
type _PrivKey__ReprAssembler = _PrivKey__Assembler

func (n _Proof) FieldTotal() Int {
	return &n.Total
}
func (n _Proof) FieldIndex() Int {
	return &n.Index
}
func (n _Proof) FieldLeafHash() Hash {
	return &n.LeafHash
}
func (n _Proof) FieldAunts() Aunts {
	return &n.Aunts
}

type _Proof__Maybe struct {
	m schema.Maybe
	v Proof
}
type MaybeProof = *_Proof__Maybe

func (m MaybeProof) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeProof) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeProof) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeProof) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeProof) Must() Proof {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Proof_Total    = _String{"Total"}
	fieldName__Proof_Index    = _String{"Index"}
	fieldName__Proof_LeafHash = _String{"LeafHash"}
	fieldName__Proof_Aunts    = _String{"Aunts"}
)
var _ ipld.Node = (Proof)(&_Proof{})
var _ schema.TypedNode = (Proof)(&_Proof{})

func (Proof) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Proof) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Total":
		return &n.Total, nil
	case "Index":
		return &n.Index, nil
	case "LeafHash":
		return &n.LeafHash, nil
	case "Aunts":
		return &n.Aunts, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Proof) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Proof) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Proof"}.LookupByIndex(0)
}
func (n Proof) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Proof) MapIterator() ipld.MapIterator {
	return &_Proof__MapItr{n, 0}
}

type _Proof__MapItr struct {
	n   Proof
	idx int
}

func (itr *_Proof__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Proof_Total
		v = &itr.n.Total
	case 1:
		k = &fieldName__Proof_Index
		v = &itr.n.Index
	case 2:
		k = &fieldName__Proof_LeafHash
		v = &itr.n.LeafHash
	case 3:
		k = &fieldName__Proof_Aunts
		v = &itr.n.Aunts
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Proof__MapItr) Done() bool {
	return itr.idx >= 4
}

func (Proof) ListIterator() ipld.ListIterator {
	return nil
}
func (Proof) Length() int64 {
	return 4
}
func (Proof) IsAbsent() bool {
	return false
}
func (Proof) IsNull() bool {
	return false
}
func (Proof) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsBool()
}
func (Proof) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsInt()
}
func (Proof) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsFloat()
}
func (Proof) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsString()
}
func (Proof) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsBytes()
}
func (Proof) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsLink()
}
func (Proof) Prototype() ipld.NodePrototype {
	return _Proof__Prototype{}
}

type _Proof__Prototype struct{}

func (_Proof__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Proof__Builder
	nb.Reset()
	return &nb
}

type _Proof__Builder struct {
	_Proof__Assembler
}

func (nb *_Proof__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Proof__Builder) Reset() {
	var w _Proof
	var m schema.Maybe
	*nb = _Proof__Builder{_Proof__Assembler{w: &w, m: &m}}
}

type _Proof__Assembler struct {
	w     *_Proof
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm          schema.Maybe
	ca_Total    _Int__Assembler
	ca_Index    _Int__Assembler
	ca_LeafHash _Hash__Assembler
	ca_Aunts    _Aunts__Assembler
}

func (na *_Proof__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Total.reset()
	na.ca_Index.reset()
	na.ca_LeafHash.reset()
	na.ca_Aunts.reset()
}

var (
	fieldBit__Proof_Total       = 1 << 0
	fieldBit__Proof_Index       = 1 << 1
	fieldBit__Proof_LeafHash    = 1 << 2
	fieldBit__Proof_Aunts       = 1 << 3
	fieldBits__Proof_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_Proof__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Proof{}
	}
	return na, nil
}
func (_Proof__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Proof"}.BeginList(0)
}
func (na *_Proof__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Proof"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Proof__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignBool(false)
}
func (_Proof__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignInt(0)
}
func (_Proof__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignFloat(0)
}
func (_Proof__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignString("")
}
func (_Proof__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignBytes(nil)
}
func (_Proof__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignLink(nil)
}
func (na *_Proof__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Proof); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Proof", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Proof__Assembler) Prototype() ipld.NodePrototype {
	return _Proof__Prototype{}
}
func (ma *_Proof__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Total.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Index.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_LeafHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Aunts.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Proof__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Total":
		if ma.s&fieldBit__Proof_Total != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Total}
		}
		ma.s += fieldBit__Proof_Total
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total, nil
	case "Index":
		if ma.s&fieldBit__Proof_Index != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Index}
		}
		ma.s += fieldBit__Proof_Index
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index, nil
	case "LeafHash":
		if ma.s&fieldBit__Proof_LeafHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_LeafHash}
		}
		ma.s += fieldBit__Proof_LeafHash
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_LeafHash.w = &ma.w.LeafHash
		ma.ca_LeafHash.m = &ma.cm
		return &ma.ca_LeafHash, nil
	case "Aunts":
		if ma.s&fieldBit__Proof_Aunts != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Aunts}
		}
		ma.s += fieldBit__Proof_Aunts
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Aunts.w = &ma.w.Aunts
		ma.ca_Aunts.m = &ma.cm
		return &ma.ca_Aunts, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Proof", Key: &_String{k}}
}
func (ma *_Proof__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Proof__KeyAssembler)(ma)
}
func (ma *_Proof__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total
	case 1:
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index
	case 2:
		ma.ca_LeafHash.w = &ma.w.LeafHash
		ma.ca_LeafHash.m = &ma.cm
		return &ma.ca_LeafHash
	case 3:
		ma.ca_Aunts.w = &ma.w.Aunts
		ma.ca_Aunts.m = &ma.cm
		return &ma.ca_Aunts
	default:
		panic("unreachable")
	}
}
func (ma *_Proof__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Proof_sufficient != fieldBits__Proof_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Proof_Total == 0 {
			err.Missing = append(err.Missing, "Total")
		}
		if ma.s&fieldBit__Proof_Index == 0 {
			err.Missing = append(err.Missing, "Index")
		}
		if ma.s&fieldBit__Proof_LeafHash == 0 {
			err.Missing = append(err.Missing, "LeafHash")
		}
		if ma.s&fieldBit__Proof_Aunts == 0 {
			err.Missing = append(err.Missing, "Aunts")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Proof__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Proof__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Proof__KeyAssembler _Proof__Assembler

func (_Proof__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.BeginMap(0)
}
func (_Proof__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.BeginList(0)
}
func (na *_Proof__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignNull()
}
func (_Proof__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignBool(false)
}
func (_Proof__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignInt(0)
}
func (_Proof__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Proof__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Total":
		if ka.s&fieldBit__Proof_Total != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Total}
		}
		ka.s += fieldBit__Proof_Total
		ka.state = maState_expectValue
		ka.f = 0
	case "Index":
		if ka.s&fieldBit__Proof_Index != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Index}
		}
		ka.s += fieldBit__Proof_Index
		ka.state = maState_expectValue
		ka.f = 1
	case "LeafHash":
		if ka.s&fieldBit__Proof_LeafHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_LeafHash}
		}
		ka.s += fieldBit__Proof_LeafHash
		ka.state = maState_expectValue
		ka.f = 2
	case "Aunts":
		if ka.s&fieldBit__Proof_Aunts != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Aunts}
		}
		ka.s += fieldBit__Proof_Aunts
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Proof", Key: &_String{k}}
	}
	return nil
}
func (_Proof__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignBytes(nil)
}
func (_Proof__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Proof__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Proof__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Proof) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Proof) Representation() ipld.Node {
	return (*_Proof__Repr)(n)
}

type _Proof__Repr _Proof

var (
	fieldName__Proof_Total_serial    = _String{"Total"}
	fieldName__Proof_Index_serial    = _String{"Index"}
	fieldName__Proof_LeafHash_serial = _String{"LeafHash"}
	fieldName__Proof_Aunts_serial    = _String{"Aunts"}
)
var _ ipld.Node = &_Proof__Repr{}

func (_Proof__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Proof__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Total":
		return n.Total.Representation(), nil
	case "Index":
		return n.Index.Representation(), nil
	case "LeafHash":
		return n.LeafHash.Representation(), nil
	case "Aunts":
		return n.Aunts.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Proof__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Proof__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.LookupByIndex(0)
}
func (n _Proof__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Proof__Repr) MapIterator() ipld.MapIterator {
	return &_Proof__ReprMapItr{n, 0}
}

type _Proof__ReprMapItr struct {
	n   *_Proof__Repr
	idx int
}

func (itr *_Proof__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Proof_Total_serial
		v = itr.n.Total.Representation()
	case 1:
		k = &fieldName__Proof_Index_serial
		v = itr.n.Index.Representation()
	case 2:
		k = &fieldName__Proof_LeafHash_serial
		v = itr.n.LeafHash.Representation()
	case 3:
		k = &fieldName__Proof_Aunts_serial
		v = itr.n.Aunts.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Proof__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_Proof__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Proof__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_Proof__Repr) IsAbsent() bool {
	return false
}
func (_Proof__Repr) IsNull() bool {
	return false
}
func (_Proof__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsBool()
}
func (_Proof__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsInt()
}
func (_Proof__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsFloat()
}
func (_Proof__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsString()
}
func (_Proof__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsBytes()
}
func (_Proof__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsLink()
}
func (_Proof__Repr) Prototype() ipld.NodePrototype {
	return _Proof__ReprPrototype{}
}

type _Proof__ReprPrototype struct{}

func (_Proof__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Proof__ReprBuilder
	nb.Reset()
	return &nb
}

type _Proof__ReprBuilder struct {
	_Proof__ReprAssembler
}

func (nb *_Proof__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Proof__ReprBuilder) Reset() {
	var w _Proof
	var m schema.Maybe
	*nb = _Proof__ReprBuilder{_Proof__ReprAssembler{w: &w, m: &m}}
}

type _Proof__ReprAssembler struct {
	w     *_Proof
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm          schema.Maybe
	ca_Total    _Int__ReprAssembler
	ca_Index    _Int__ReprAssembler
	ca_LeafHash _Hash__ReprAssembler
	ca_Aunts    _Aunts__ReprAssembler
}

func (na *_Proof__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Total.reset()
	na.ca_Index.reset()
	na.ca_LeafHash.reset()
	na.ca_Aunts.reset()
}
func (na *_Proof__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Proof{}
	}
	return na, nil
}
func (_Proof__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.BeginList(0)
}
func (na *_Proof__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Proof.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Proof__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignBool(false)
}
func (_Proof__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignInt(0)
}
func (_Proof__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignFloat(0)
}
func (_Proof__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignString("")
}
func (_Proof__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignBytes(nil)
}
func (_Proof__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignLink(nil)
}
func (na *_Proof__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Proof); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Proof.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Proof__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Proof__ReprPrototype{}
}
func (ma *_Proof__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Proof__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Total":
		if ma.s&fieldBit__Proof_Total != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Total_serial}
		}
		ma.s += fieldBit__Proof_Total
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total, nil
	case "Index":
		if ma.s&fieldBit__Proof_Index != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Index_serial}
		}
		ma.s += fieldBit__Proof_Index
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index, nil
	case "LeafHash":
		if ma.s&fieldBit__Proof_LeafHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_LeafHash_serial}
		}
		ma.s += fieldBit__Proof_LeafHash
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_LeafHash.w = &ma.w.LeafHash
		ma.ca_LeafHash.m = &ma.cm
		return &ma.ca_LeafHash, nil
	case "Aunts":
		if ma.s&fieldBit__Proof_Aunts != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Aunts_serial}
		}
		ma.s += fieldBit__Proof_Aunts
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Aunts.w = &ma.w.Aunts
		ma.ca_Aunts.m = &ma.cm
		return &ma.ca_Aunts, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Proof.Repr", Key: &_String{k}}
}
func (ma *_Proof__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Proof__ReprKeyAssembler)(ma)
}
func (ma *_Proof__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total
	case 1:
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index
	case 2:
		ma.ca_LeafHash.w = &ma.w.LeafHash
		ma.ca_LeafHash.m = &ma.cm
		return &ma.ca_LeafHash
	case 3:
		ma.ca_Aunts.w = &ma.w.Aunts
		ma.ca_Aunts.m = &ma.cm
		return &ma.ca_Aunts
	default:
		panic("unreachable")
	}
}
func (ma *_Proof__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Proof_sufficient != fieldBits__Proof_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Proof_Total == 0 {
			err.Missing = append(err.Missing, "Total")
		}
		if ma.s&fieldBit__Proof_Index == 0 {
			err.Missing = append(err.Missing, "Index")
		}
		if ma.s&fieldBit__Proof_LeafHash == 0 {
			err.Missing = append(err.Missing, "LeafHash")
		}
		if ma.s&fieldBit__Proof_Aunts == 0 {
			err.Missing = append(err.Missing, "Aunts")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Proof__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Proof__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Proof__ReprKeyAssembler _Proof__ReprAssembler

func (_Proof__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Proof__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Proof__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignNull()
}
func (_Proof__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Proof__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Proof__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Proof__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Total":
		if ka.s&fieldBit__Proof_Total != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Total_serial}
		}
		ka.s += fieldBit__Proof_Total
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Index":
		if ka.s&fieldBit__Proof_Index != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Index_serial}
		}
		ka.s += fieldBit__Proof_Index
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "LeafHash":
		if ka.s&fieldBit__Proof_LeafHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_LeafHash_serial}
		}
		ka.s += fieldBit__Proof_LeafHash
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Aunts":
		if ka.s&fieldBit__Proof_Aunts != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Aunts_serial}
		}
		ka.s += fieldBit__Proof_Aunts
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Proof.Repr", Key: &_String{k}}
}
func (_Proof__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Proof__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Proof__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Proof__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _Proposal) FieldSMType() SignedMsgType {
	return &n.SMType
}
func (n _Proposal) FieldHeight() Int {
	return &n.Height
}
func (n _Proposal) FieldRound() Int {
	return &n.Round
}
func (n _Proposal) FieldPOLRound() Int {
	return &n.POLRound
}
func (n _Proposal) FieldBlockID() BlockID {
	return &n.BlockID
}
func (n _Proposal) FieldTimestamp() Time {
	return &n.Timestamp
}
func (n _Proposal) FieldChainID() String {
	return &n.ChainID
}

type _Proposal__Maybe struct {
	m schema.Maybe
	v Proposal
}
type MaybeProposal = *_Proposal__Maybe

func (m MaybeProposal) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeProposal) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeProposal) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeProposal) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeProposal) Must() Proposal {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Proposal_SMType    = _String{"SMType"}
	fieldName__Proposal_Height    = _String{"Height"}
	fieldName__Proposal_Round     = _String{"Round"}
	fieldName__Proposal_POLRound  = _String{"POLRound"}
	fieldName__Proposal_BlockID   = _String{"BlockID"}
	fieldName__Proposal_Timestamp = _String{"Timestamp"}
	fieldName__Proposal_ChainID   = _String{"ChainID"}
)
var _ ipld.Node = (Proposal)(&_Proposal{})
var _ schema.TypedNode = (Proposal)(&_Proposal{})

func (Proposal) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Proposal) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "SMType":
		return &n.SMType, nil
	case "Height":
		return &n.Height, nil
	case "Round":
		return &n.Round, nil
	case "POLRound":
		return &n.POLRound, nil
	case "BlockID":
		return &n.BlockID, nil
	case "Timestamp":
		return &n.Timestamp, nil
	case "ChainID":
		return &n.ChainID, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Proposal) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Proposal) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Proposal"}.LookupByIndex(0)
}
func (n Proposal) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Proposal) MapIterator() ipld.MapIterator {
	return &_Proposal__MapItr{n, 0}
}

type _Proposal__MapItr struct {
	n   Proposal
	idx int
}

func (itr *_Proposal__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 7 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Proposal_SMType
		v = &itr.n.SMType
	case 1:
		k = &fieldName__Proposal_Height
		v = &itr.n.Height
	case 2:
		k = &fieldName__Proposal_Round
		v = &itr.n.Round
	case 3:
		k = &fieldName__Proposal_POLRound
		v = &itr.n.POLRound
	case 4:
		k = &fieldName__Proposal_BlockID
		v = &itr.n.BlockID
	case 5:
		k = &fieldName__Proposal_Timestamp
		v = &itr.n.Timestamp
	case 6:
		k = &fieldName__Proposal_ChainID
		v = &itr.n.ChainID
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Proposal__MapItr) Done() bool {
	return itr.idx >= 7
}

func (Proposal) ListIterator() ipld.ListIterator {
	return nil
}
func (Proposal) Length() int64 {
	return 7
}
func (Proposal) IsAbsent() bool {
	return false
}
func (Proposal) IsNull() bool {
	return false
}
func (Proposal) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsBool()
}
func (Proposal) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsInt()
}
func (Proposal) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsFloat()
}
func (Proposal) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsString()
}
func (Proposal) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsBytes()
}
func (Proposal) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsLink()
}
func (Proposal) Prototype() ipld.NodePrototype {
	return _Proposal__Prototype{}
}

type _Proposal__Prototype struct{}

func (_Proposal__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Proposal__Builder
	nb.Reset()
	return &nb
}

type _Proposal__Builder struct {
	_Proposal__Assembler
}

func (nb *_Proposal__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Proposal__Builder) Reset() {
	var w _Proposal
	var m schema.Maybe
	*nb = _Proposal__Builder{_Proposal__Assembler{w: &w, m: &m}}
}

type _Proposal__Assembler struct {
	w     *_Proposal
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm           schema.Maybe
	ca_SMType    _SignedMsgType__Assembler
	ca_Height    _Int__Assembler
	ca_Round     _Int__Assembler
	ca_POLRound  _Int__Assembler
	ca_BlockID   _BlockID__Assembler
	ca_Timestamp _Time__Assembler
	ca_ChainID   _String__Assembler
}

func (na *_Proposal__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_SMType.reset()
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_POLRound.reset()
	na.ca_BlockID.reset()
	na.ca_Timestamp.reset()
	na.ca_ChainID.reset()
}

var (
	fieldBit__Proposal_SMType      = 1 << 0
	fieldBit__Proposal_Height      = 1 << 1
	fieldBit__Proposal_Round       = 1 << 2
	fieldBit__Proposal_POLRound    = 1 << 3
	fieldBit__Proposal_BlockID     = 1 << 4
	fieldBit__Proposal_Timestamp   = 1 << 5
	fieldBit__Proposal_ChainID     = 1 << 6
	fieldBits__Proposal_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6
)

func (na *_Proposal__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Proposal{}
	}
	return na, nil
}
func (_Proposal__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.BeginList(0)
}
func (na *_Proposal__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Proposal__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignBool(false)
}
func (_Proposal__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignInt(0)
}
func (_Proposal__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignFloat(0)
}
func (_Proposal__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignString("")
}
func (_Proposal__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignBytes(nil)
}
func (_Proposal__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignLink(nil)
}
func (na *_Proposal__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Proposal); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Proposal", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Proposal__Assembler) Prototype() ipld.NodePrototype {
	return _Proposal__Prototype{}
}
func (ma *_Proposal__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_SMType.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Height.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Round.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_POLRound.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Timestamp.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ChainID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Proposal__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "SMType":
		if ma.s&fieldBit__Proposal_SMType != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_SMType}
		}
		ma.s += fieldBit__Proposal_SMType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_SMType.w = &ma.w.SMType
		ma.ca_SMType.m = &ma.cm
		return &ma.ca_SMType, nil
	case "Height":
		if ma.s&fieldBit__Proposal_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Height}
		}
		ma.s += fieldBit__Proposal_Height
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Proposal_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Round}
		}
		ma.s += fieldBit__Proposal_Round
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "POLRound":
		if ma.s&fieldBit__Proposal_POLRound != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_POLRound}
		}
		ma.s += fieldBit__Proposal_POLRound
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_POLRound.w = &ma.w.POLRound
		ma.ca_POLRound.m = &ma.cm
		return &ma.ca_POLRound, nil
	case "BlockID":
		if ma.s&fieldBit__Proposal_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_BlockID}
		}
		ma.s += fieldBit__Proposal_BlockID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Timestamp":
		if ma.s&fieldBit__Proposal_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Timestamp}
		}
		ma.s += fieldBit__Proposal_Timestamp
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "ChainID":
		if ma.s&fieldBit__Proposal_ChainID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_ChainID}
		}
		ma.s += fieldBit__Proposal_ChainID
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Proposal", Key: &_String{k}}
}
func (ma *_Proposal__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Proposal__KeyAssembler)(ma)
}
func (ma *_Proposal__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_SMType.w = &ma.w.SMType
		ma.ca_SMType.m = &ma.cm
		return &ma.ca_SMType
	case 1:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 2:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 3:
		ma.ca_POLRound.w = &ma.w.POLRound
		ma.ca_POLRound.m = &ma.cm
		return &ma.ca_POLRound
	case 4:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 5:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 6:
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID
	default:
		panic("unreachable")
	}
}
func (ma *_Proposal__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Proposal_sufficient != fieldBits__Proposal_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Proposal_SMType == 0 {
			err.Missing = append(err.Missing, "SMType")
		}
		if ma.s&fieldBit__Proposal_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Proposal_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Proposal_POLRound == 0 {
			err.Missing = append(err.Missing, "POLRound")
		}
		if ma.s&fieldBit__Proposal_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Proposal_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__Proposal_ChainID == 0 {
			err.Missing = append(err.Missing, "ChainID")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Proposal__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Proposal__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Proposal__KeyAssembler _Proposal__Assembler

func (_Proposal__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.BeginMap(0)
}
func (_Proposal__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.BeginList(0)
}
func (na *_Proposal__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignNull()
}
func (_Proposal__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignBool(false)
}
func (_Proposal__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignInt(0)
}
func (_Proposal__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Proposal__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "SMType":
		if ka.s&fieldBit__Proposal_SMType != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_SMType}
		}
		ka.s += fieldBit__Proposal_SMType
		ka.state = maState_expectValue
		ka.f = 0
	case "Height":
		if ka.s&fieldBit__Proposal_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Height}
		}
		ka.s += fieldBit__Proposal_Height
		ka.state = maState_expectValue
		ka.f = 1
	case "Round":
		if ka.s&fieldBit__Proposal_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Round}
		}
		ka.s += fieldBit__Proposal_Round
		ka.state = maState_expectValue
		ka.f = 2
	case "POLRound":
		if ka.s&fieldBit__Proposal_POLRound != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_POLRound}
		}
		ka.s += fieldBit__Proposal_POLRound
		ka.state = maState_expectValue
		ka.f = 3
	case "BlockID":
		if ka.s&fieldBit__Proposal_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_BlockID}
		}
		ka.s += fieldBit__Proposal_BlockID
		ka.state = maState_expectValue
		ka.f = 4
	case "Timestamp":
		if ka.s&fieldBit__Proposal_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Timestamp}
		}
		ka.s += fieldBit__Proposal_Timestamp
		ka.state = maState_expectValue
		ka.f = 5
	case "ChainID":
		if ka.s&fieldBit__Proposal_ChainID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_ChainID}
		}
		ka.s += fieldBit__Proposal_ChainID
		ka.state = maState_expectValue
		ka.f = 6
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Proposal", Key: &_String{k}}
	}
	return nil
}
func (_Proposal__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignBytes(nil)
}
func (_Proposal__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Proposal__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Proposal__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Proposal) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Proposal) Representation() ipld.Node {
	return (*_Proposal__Repr)(n)
}

type _Proposal__Repr _Proposal

var (
	fieldName__Proposal_SMType_serial    = _String{"SMType"}
	fieldName__Proposal_Height_serial    = _String{"Height"}
	fieldName__Proposal_Round_serial     = _String{"Round"}
	fieldName__Proposal_POLRound_serial  = _String{"POLRound"}
	fieldName__Proposal_BlockID_serial   = _String{"BlockID"}
	fieldName__Proposal_Timestamp_serial = _String{"Timestamp"}
	fieldName__Proposal_ChainID_serial   = _String{"ChainID"}
)
var _ ipld.Node = &_Proposal__Repr{}

func (_Proposal__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Proposal__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "SMType":
		return n.SMType.Representation(), nil
	case "Height":
		return n.Height.Representation(), nil
	case "Round":
		return n.Round.Representation(), nil
	case "POLRound":
		return n.POLRound.Representation(), nil
	case "BlockID":
		return n.BlockID.Representation(), nil
	case "Timestamp":
		return n.Timestamp.Representation(), nil
	case "ChainID":
		return n.ChainID.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Proposal__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Proposal__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.LookupByIndex(0)
}
func (n _Proposal__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Proposal__Repr) MapIterator() ipld.MapIterator {
	return &_Proposal__ReprMapItr{n, 0}
}

type _Proposal__ReprMapItr struct {
	n   *_Proposal__Repr
	idx int
}

func (itr *_Proposal__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 7 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Proposal_SMType_serial
		v = itr.n.SMType.Representation()
	case 1:
		k = &fieldName__Proposal_Height_serial
		v = itr.n.Height.Representation()
	case 2:
		k = &fieldName__Proposal_Round_serial
		v = itr.n.Round.Representation()
	case 3:
		k = &fieldName__Proposal_POLRound_serial
		v = itr.n.POLRound.Representation()
	case 4:
		k = &fieldName__Proposal_BlockID_serial
		v = itr.n.BlockID.Representation()
	case 5:
		k = &fieldName__Proposal_Timestamp_serial
		v = itr.n.Timestamp.Representation()
	case 6:
		k = &fieldName__Proposal_ChainID_serial
		v = itr.n.ChainID.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Proposal__ReprMapItr) Done() bool {
	return itr.idx >= 7
}
func (_Proposal__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Proposal__Repr) Length() int64 {
	l := 7
	return int64(l)
}
func (_Proposal__Repr) IsAbsent() bool {
	return false
}
func (_Proposal__Repr) IsNull() bool {
	return false
}
func (_Proposal__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsBool()
}
func (_Proposal__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsInt()
}
func (_Proposal__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsFloat()
}
func (_Proposal__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsString()
}
func (_Proposal__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsBytes()
}
func (_Proposal__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsLink()
}
func (_Proposal__Repr) Prototype() ipld.NodePrototype {
	return _Proposal__ReprPrototype{}
}

type _Proposal__ReprPrototype struct{}

func (_Proposal__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Proposal__ReprBuilder
	nb.Reset()
	return &nb
}

type _Proposal__ReprBuilder struct {
	_Proposal__ReprAssembler
}

func (nb *_Proposal__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Proposal__ReprBuilder) Reset() {
	var w _Proposal
	var m schema.Maybe
	*nb = _Proposal__ReprBuilder{_Proposal__ReprAssembler{w: &w, m: &m}}
}

type _Proposal__ReprAssembler struct {
	w     *_Proposal
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm           schema.Maybe
	ca_SMType    _SignedMsgType__ReprAssembler
	ca_Height    _Int__ReprAssembler
	ca_Round     _Int__ReprAssembler
	ca_POLRound  _Int__ReprAssembler
	ca_BlockID   _BlockID__ReprAssembler
	ca_Timestamp _Time__ReprAssembler
	ca_ChainID   _String__ReprAssembler
}

func (na *_Proposal__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_SMType.reset()
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_POLRound.reset()
	na.ca_BlockID.reset()
	na.ca_Timestamp.reset()
	na.ca_ChainID.reset()
}
func (na *_Proposal__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Proposal{}
	}
	return na, nil
}
func (_Proposal__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.BeginList(0)
}
func (na *_Proposal__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Proposal.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Proposal__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignBool(false)
}
func (_Proposal__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignInt(0)
}
func (_Proposal__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignFloat(0)
}
func (_Proposal__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignString("")
}
func (_Proposal__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignBytes(nil)
}
func (_Proposal__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignLink(nil)
}
func (na *_Proposal__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Proposal); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Proposal.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Proposal__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Proposal__ReprPrototype{}
}
func (ma *_Proposal__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Proposal__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "SMType":
		if ma.s&fieldBit__Proposal_SMType != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_SMType_serial}
		}
		ma.s += fieldBit__Proposal_SMType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_SMType.w = &ma.w.SMType
		ma.ca_SMType.m = &ma.cm
		return &ma.ca_SMType, nil
	case "Height":
		if ma.s&fieldBit__Proposal_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Height_serial}
		}
		ma.s += fieldBit__Proposal_Height
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Proposal_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Round_serial}
		}
		ma.s += fieldBit__Proposal_Round
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "POLRound":
		if ma.s&fieldBit__Proposal_POLRound != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_POLRound_serial}
		}
		ma.s += fieldBit__Proposal_POLRound
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_POLRound.w = &ma.w.POLRound
		ma.ca_POLRound.m = &ma.cm
		return &ma.ca_POLRound, nil
	case "BlockID":
		if ma.s&fieldBit__Proposal_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_BlockID_serial}
		}
		ma.s += fieldBit__Proposal_BlockID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Timestamp":
		if ma.s&fieldBit__Proposal_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Timestamp_serial}
		}
		ma.s += fieldBit__Proposal_Timestamp
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "ChainID":
		if ma.s&fieldBit__Proposal_ChainID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_ChainID_serial}
		}
		ma.s += fieldBit__Proposal_ChainID
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Proposal.Repr", Key: &_String{k}}
}
func (ma *_Proposal__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Proposal__ReprKeyAssembler)(ma)
}
func (ma *_Proposal__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_SMType.w = &ma.w.SMType
		ma.ca_SMType.m = &ma.cm
		return &ma.ca_SMType
	case 1:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 2:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 3:
		ma.ca_POLRound.w = &ma.w.POLRound
		ma.ca_POLRound.m = &ma.cm
		return &ma.ca_POLRound
	case 4:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 5:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 6:
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID
	default:
		panic("unreachable")
	}
}
func (ma *_Proposal__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Proposal_sufficient != fieldBits__Proposal_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Proposal_SMType == 0 {
			err.Missing = append(err.Missing, "SMType")
		}
		if ma.s&fieldBit__Proposal_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Proposal_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Proposal_POLRound == 0 {
			err.Missing = append(err.Missing, "POLRound")
		}
		if ma.s&fieldBit__Proposal_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Proposal_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__Proposal_ChainID == 0 {
			err.Missing = append(err.Missing, "ChainID")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Proposal__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Proposal__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Proposal__ReprKeyAssembler _Proposal__ReprAssembler

func (_Proposal__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Proposal__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Proposal__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignNull()
}
func (_Proposal__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Proposal__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Proposal__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Proposal__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "SMType":
		if ka.s&fieldBit__Proposal_SMType != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_SMType_serial}
		}
		ka.s += fieldBit__Proposal_SMType
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Height":
		if ka.s&fieldBit__Proposal_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Height_serial}
		}
		ka.s += fieldBit__Proposal_Height
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Round":
		if ka.s&fieldBit__Proposal_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Round_serial}
		}
		ka.s += fieldBit__Proposal_Round
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "POLRound":
		if ka.s&fieldBit__Proposal_POLRound != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_POLRound_serial}
		}
		ka.s += fieldBit__Proposal_POLRound
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "BlockID":
		if ka.s&fieldBit__Proposal_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_BlockID_serial}
		}
		ka.s += fieldBit__Proposal_BlockID
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "Timestamp":
		if ka.s&fieldBit__Proposal_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Timestamp_serial}
		}
		ka.s += fieldBit__Proposal_Timestamp
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "ChainID":
		if ka.s&fieldBit__Proposal_ChainID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_ChainID_serial}
		}
		ka.s += fieldBit__Proposal_ChainID
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Proposal.Repr", Key: &_String{k}}
}
func (_Proposal__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Proposal__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Proposal__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Proposal__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n PubKey) Bytes() []byte {
	return n.x
}
func (_PubKey__Prototype) FromBytes(v []byte) (PubKey, error) {
	n := _PubKey{v}
	return &n, nil
}

type _PubKey__Maybe struct {
	m schema.Maybe
	v PubKey
}
type MaybePubKey = *_PubKey__Maybe

func (m MaybePubKey) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePubKey) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePubKey) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePubKey) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybePubKey) Must() PubKey {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (PubKey)(&_PubKey{})
var _ schema.TypedNode = (PubKey)(&_PubKey{})

func (PubKey) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (PubKey) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.LookupByString("")
}
func (PubKey) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.LookupByNode(nil)
}
func (PubKey) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.LookupByIndex(0)
}
func (PubKey) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.LookupBySegment(seg)
}
func (PubKey) MapIterator() ipld.MapIterator {
	return nil
}
func (PubKey) ListIterator() ipld.ListIterator {
	return nil
}
func (PubKey) Length() int64 {
	return -1
}
func (PubKey) IsAbsent() bool {
	return false
}
func (PubKey) IsNull() bool {
	return false
}
func (PubKey) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.AsBool()
}
func (PubKey) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.AsInt()
}
func (PubKey) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.AsFloat()
}
func (PubKey) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.AsString()
}
func (n PubKey) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (PubKey) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.AsLink()
}
func (PubKey) Prototype() ipld.NodePrototype {
	return _PubKey__Prototype{}
}

type _PubKey__Prototype struct{}

func (_PubKey__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _PubKey__Builder
	nb.Reset()
	return &nb
}

type _PubKey__Builder struct {
	_PubKey__Assembler
}

func (nb *_PubKey__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PubKey__Builder) Reset() {
	var w _PubKey
	var m schema.Maybe
	*nb = _PubKey__Builder{_PubKey__Assembler{w: &w, m: &m}}
}

type _PubKey__Assembler struct {
	w *_PubKey
	m *schema.Maybe
}

func (na *_PubKey__Assembler) reset() {}
func (_PubKey__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.BeginMap(0)
}
func (_PubKey__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.BeginList(0)
}
func (na *_PubKey__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_PubKey__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignBool(false)
}
func (_PubKey__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignInt(0)
}
func (_PubKey__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignFloat(0)
}
func (_PubKey__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignString("")
}
func (na *_PubKey__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_PubKey{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_PubKey__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignLink(nil)
}
func (na *_PubKey__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PubKey); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_PubKey__Assembler) Prototype() ipld.NodePrototype {
	return _PubKey__Prototype{}
}
func (PubKey) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n PubKey) Representation() ipld.Node {
	return (*_PubKey__Repr)(n)
}

type _PubKey__Repr = _PubKey

var _ ipld.Node = &_PubKey__Repr{}

type _PubKey__ReprPrototype = _PubKey__Prototype
type _PubKey__ReprAssembler = _PubKey__Assembler

func (n _ResponseDeliverTx) FieldCode() Uint {
	return &n.Code
}
func (n _ResponseDeliverTx) FieldData() Bytes {
	return &n.Data
}
func (n _ResponseDeliverTx) FieldGasWanted() Int {
	return &n.GasWanted
}
func (n _ResponseDeliverTx) FieldGasUsed() Int {
	return &n.GasUsed
}

type _ResponseDeliverTx__Maybe struct {
	m schema.Maybe
	v ResponseDeliverTx
}
type MaybeResponseDeliverTx = *_ResponseDeliverTx__Maybe

func (m MaybeResponseDeliverTx) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeResponseDeliverTx) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeResponseDeliverTx) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeResponseDeliverTx) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeResponseDeliverTx) Must() ResponseDeliverTx {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__ResponseDeliverTx_Code      = _String{"Code"}
	fieldName__ResponseDeliverTx_Data      = _String{"Data"}
	fieldName__ResponseDeliverTx_GasWanted = _String{"GasWanted"}
	fieldName__ResponseDeliverTx_GasUsed   = _String{"GasUsed"}
)
var _ ipld.Node = (ResponseDeliverTx)(&_ResponseDeliverTx{})
var _ schema.TypedNode = (ResponseDeliverTx)(&_ResponseDeliverTx{})

func (ResponseDeliverTx) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n ResponseDeliverTx) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Code":
		return &n.Code, nil
	case "Data":
		return &n.Data, nil
	case "GasWanted":
		return &n.GasWanted, nil
	case "GasUsed":
		return &n.GasUsed, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n ResponseDeliverTx) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (ResponseDeliverTx) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx"}.LookupByIndex(0)
}
func (n ResponseDeliverTx) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n ResponseDeliverTx) MapIterator() ipld.MapIterator {
	return &_ResponseDeliverTx__MapItr{n, 0}
}

type _ResponseDeliverTx__MapItr struct {
	n   ResponseDeliverTx
	idx int
}

func (itr *_ResponseDeliverTx__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__ResponseDeliverTx_Code
		v = &itr.n.Code
	case 1:
		k = &fieldName__ResponseDeliverTx_Data
		v = &itr.n.Data
	case 2:
		k = &fieldName__ResponseDeliverTx_GasWanted
		v = &itr.n.GasWanted
	case 3:
		k = &fieldName__ResponseDeliverTx_GasUsed
		v = &itr.n.GasUsed
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ResponseDeliverTx__MapItr) Done() bool {
	return itr.idx >= 4
}

func (ResponseDeliverTx) ListIterator() ipld.ListIterator {
	return nil
}
func (ResponseDeliverTx) Length() int64 {
	return 4
}
func (ResponseDeliverTx) IsAbsent() bool {
	return false
}
func (ResponseDeliverTx) IsNull() bool {
	return false
}
func (ResponseDeliverTx) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx"}.AsBool()
}
func (ResponseDeliverTx) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx"}.AsInt()
}
func (ResponseDeliverTx) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx"}.AsFloat()
}
func (ResponseDeliverTx) AsString() (string, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx"}.AsString()
}
func (ResponseDeliverTx) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx"}.AsBytes()
}
func (ResponseDeliverTx) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx"}.AsLink()
}
func (ResponseDeliverTx) Prototype() ipld.NodePrototype {
	return _ResponseDeliverTx__Prototype{}
}

type _ResponseDeliverTx__Prototype struct{}

func (_ResponseDeliverTx__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _ResponseDeliverTx__Builder
	nb.Reset()
	return &nb
}

type _ResponseDeliverTx__Builder struct {
	_ResponseDeliverTx__Assembler
}

func (nb *_ResponseDeliverTx__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ResponseDeliverTx__Builder) Reset() {
	var w _ResponseDeliverTx
	var m schema.Maybe
	*nb = _ResponseDeliverTx__Builder{_ResponseDeliverTx__Assembler{w: &w, m: &m}}
}

type _ResponseDeliverTx__Assembler struct {
	w     *_ResponseDeliverTx
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm           schema.Maybe
	ca_Code      _Uint__Assembler
	ca_Data      _Bytes__Assembler
	ca_GasWanted _Int__Assembler
	ca_GasUsed   _Int__Assembler
}

func (na *_ResponseDeliverTx__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Code.reset()
	na.ca_Data.reset()
	na.ca_GasWanted.reset()
	na.ca_GasUsed.reset()
}

var (
	fieldBit__ResponseDeliverTx_Code        = 1 << 0
	fieldBit__ResponseDeliverTx_Data        = 1 << 1
	fieldBit__ResponseDeliverTx_GasWanted   = 1 << 2
	fieldBit__ResponseDeliverTx_GasUsed     = 1 << 3
	fieldBits__ResponseDeliverTx_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_ResponseDeliverTx__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ResponseDeliverTx{}
	}
	return na, nil
}
func (_ResponseDeliverTx__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx"}.BeginList(0)
}
func (na *_ResponseDeliverTx__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ResponseDeliverTx__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx"}.AssignBool(false)
}
func (_ResponseDeliverTx__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx"}.AssignInt(0)
}
func (_ResponseDeliverTx__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx"}.AssignFloat(0)
}
func (_ResponseDeliverTx__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx"}.AssignString("")
}
func (_ResponseDeliverTx__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx"}.AssignBytes(nil)
}
func (_ResponseDeliverTx__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx"}.AssignLink(nil)
}
func (na *_ResponseDeliverTx__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ResponseDeliverTx); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.ResponseDeliverTx", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ResponseDeliverTx__Assembler) Prototype() ipld.NodePrototype {
	return _ResponseDeliverTx__Prototype{}
}
func (ma *_ResponseDeliverTx__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Code.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Data.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_GasWanted.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_GasUsed.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_ResponseDeliverTx__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Code":
		if ma.s&fieldBit__ResponseDeliverTx_Code != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_Code}
		}
		ma.s += fieldBit__ResponseDeliverTx_Code
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Code.w = &ma.w.Code
		ma.ca_Code.m = &ma.cm
		return &ma.ca_Code, nil
	case "Data":
		if ma.s&fieldBit__ResponseDeliverTx_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_Data}
		}
		ma.s += fieldBit__ResponseDeliverTx_Data
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	case "GasWanted":
		if ma.s&fieldBit__ResponseDeliverTx_GasWanted != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_GasWanted}
		}
		ma.s += fieldBit__ResponseDeliverTx_GasWanted
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_GasWanted.w = &ma.w.GasWanted
		ma.ca_GasWanted.m = &ma.cm
		return &ma.ca_GasWanted, nil
	case "GasUsed":
		if ma.s&fieldBit__ResponseDeliverTx_GasUsed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_GasUsed}
		}
		ma.s += fieldBit__ResponseDeliverTx_GasUsed
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.ResponseDeliverTx", Key: &_String{k}}
}
func (ma *_ResponseDeliverTx__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ResponseDeliverTx__KeyAssembler)(ma)
}
func (ma *_ResponseDeliverTx__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Code.w = &ma.w.Code
		ma.ca_Code.m = &ma.cm
		return &ma.ca_Code
	case 1:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	case 2:
		ma.ca_GasWanted.w = &ma.w.GasWanted
		ma.ca_GasWanted.m = &ma.cm
		return &ma.ca_GasWanted
	case 3:
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed
	default:
		panic("unreachable")
	}
}
func (ma *_ResponseDeliverTx__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__ResponseDeliverTx_sufficient != fieldBits__ResponseDeliverTx_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__ResponseDeliverTx_Code == 0 {
			err.Missing = append(err.Missing, "Code")
		}
		if ma.s&fieldBit__ResponseDeliverTx_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		if ma.s&fieldBit__ResponseDeliverTx_GasWanted == 0 {
			err.Missing = append(err.Missing, "GasWanted")
		}
		if ma.s&fieldBit__ResponseDeliverTx_GasUsed == 0 {
			err.Missing = append(err.Missing, "GasUsed")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ResponseDeliverTx__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ResponseDeliverTx__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _ResponseDeliverTx__KeyAssembler _ResponseDeliverTx__Assembler

func (_ResponseDeliverTx__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.KeyAssembler"}.BeginMap(0)
}
func (_ResponseDeliverTx__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.KeyAssembler"}.BeginList(0)
}
func (na *_ResponseDeliverTx__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.KeyAssembler"}.AssignNull()
}
func (_ResponseDeliverTx__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.KeyAssembler"}.AssignBool(false)
}
func (_ResponseDeliverTx__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.KeyAssembler"}.AssignInt(0)
}
func (_ResponseDeliverTx__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ResponseDeliverTx__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Code":
		if ka.s&fieldBit__ResponseDeliverTx_Code != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_Code}
		}
		ka.s += fieldBit__ResponseDeliverTx_Code
		ka.state = maState_expectValue
		ka.f = 0
	case "Data":
		if ka.s&fieldBit__ResponseDeliverTx_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_Data}
		}
		ka.s += fieldBit__ResponseDeliverTx_Data
		ka.state = maState_expectValue
		ka.f = 1
	case "GasWanted":
		if ka.s&fieldBit__ResponseDeliverTx_GasWanted != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_GasWanted}
		}
		ka.s += fieldBit__ResponseDeliverTx_GasWanted
		ka.state = maState_expectValue
		ka.f = 2
	case "GasUsed":
		if ka.s&fieldBit__ResponseDeliverTx_GasUsed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_GasUsed}
		}
		ka.s += fieldBit__ResponseDeliverTx_GasUsed
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.ResponseDeliverTx", Key: &_String{k}}
	}
	return nil
}
func (_ResponseDeliverTx__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.KeyAssembler"}.AssignBytes(nil)
}
func (_ResponseDeliverTx__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ResponseDeliverTx__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ResponseDeliverTx__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ResponseDeliverTx) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n ResponseDeliverTx) Representation() ipld.Node {
	return (*_ResponseDeliverTx__Repr)(n)
}

type _ResponseDeliverTx__Repr _ResponseDeliverTx

var (
	fieldName__ResponseDeliverTx_Code_serial      = _String{"Code"}
	fieldName__ResponseDeliverTx_Data_serial      = _String{"Data"}
	fieldName__ResponseDeliverTx_GasWanted_serial = _String{"GasWanted"}
	fieldName__ResponseDeliverTx_GasUsed_serial   = _String{"GasUsed"}
)
var _ ipld.Node = &_ResponseDeliverTx__Repr{}

func (_ResponseDeliverTx__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_ResponseDeliverTx__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Code":
		return n.Code.Representation(), nil
	case "Data":
		return n.Data.Representation(), nil
	case "GasWanted":
		return n.GasWanted.Representation(), nil
	case "GasUsed":
		return n.GasUsed.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_ResponseDeliverTx__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_ResponseDeliverTx__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx.Repr"}.LookupByIndex(0)
}
func (n _ResponseDeliverTx__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_ResponseDeliverTx__Repr) MapIterator() ipld.MapIterator {
	return &_ResponseDeliverTx__ReprMapItr{n, 0}
}

type _ResponseDeliverTx__ReprMapItr struct {
	n   *_ResponseDeliverTx__Repr
	idx int
}

func (itr *_ResponseDeliverTx__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__ResponseDeliverTx_Code_serial
		v = itr.n.Code.Representation()
	case 1:
		k = &fieldName__ResponseDeliverTx_Data_serial
		v = itr.n.Data.Representation()
	case 2:
		k = &fieldName__ResponseDeliverTx_GasWanted_serial
		v = itr.n.GasWanted.Representation()
	case 3:
		k = &fieldName__ResponseDeliverTx_GasUsed_serial
		v = itr.n.GasUsed.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ResponseDeliverTx__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_ResponseDeliverTx__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_ResponseDeliverTx__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_ResponseDeliverTx__Repr) IsAbsent() bool {
	return false
}
func (_ResponseDeliverTx__Repr) IsNull() bool {
	return false
}
func (_ResponseDeliverTx__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx.Repr"}.AsBool()
}
func (_ResponseDeliverTx__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx.Repr"}.AsInt()
}
func (_ResponseDeliverTx__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx.Repr"}.AsFloat()
}
func (_ResponseDeliverTx__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx.Repr"}.AsString()
}
func (_ResponseDeliverTx__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx.Repr"}.AsBytes()
}
func (_ResponseDeliverTx__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.ResponseDeliverTx.Repr"}.AsLink()
}
func (_ResponseDeliverTx__Repr) Prototype() ipld.NodePrototype {
	return _ResponseDeliverTx__ReprPrototype{}
}

type _ResponseDeliverTx__ReprPrototype struct{}

func (_ResponseDeliverTx__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _ResponseDeliverTx__ReprBuilder
	nb.Reset()
	return &nb
}

type _ResponseDeliverTx__ReprBuilder struct {
	_ResponseDeliverTx__ReprAssembler
}

func (nb *_ResponseDeliverTx__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ResponseDeliverTx__ReprBuilder) Reset() {
	var w _ResponseDeliverTx
	var m schema.Maybe
	*nb = _ResponseDeliverTx__ReprBuilder{_ResponseDeliverTx__ReprAssembler{w: &w, m: &m}}
}

type _ResponseDeliverTx__ReprAssembler struct {
	w     *_ResponseDeliverTx
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm           schema.Maybe
	ca_Code      _Uint__ReprAssembler
	ca_Data      _Bytes__ReprAssembler
	ca_GasWanted _Int__ReprAssembler
	ca_GasUsed   _Int__ReprAssembler
}

func (na *_ResponseDeliverTx__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Code.reset()
	na.ca_Data.reset()
	na.ca_GasWanted.reset()
	na.ca_GasUsed.reset()
}
func (na *_ResponseDeliverTx__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ResponseDeliverTx{}
	}
	return na, nil
}
func (_ResponseDeliverTx__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx.Repr"}.BeginList(0)
}
func (na *_ResponseDeliverTx__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ResponseDeliverTx__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx.Repr"}.AssignBool(false)
}
func (_ResponseDeliverTx__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx.Repr"}.AssignInt(0)
}
func (_ResponseDeliverTx__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx.Repr"}.AssignFloat(0)
}
func (_ResponseDeliverTx__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx.Repr"}.AssignString("")
}
func (_ResponseDeliverTx__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx.Repr"}.AssignBytes(nil)
}
func (_ResponseDeliverTx__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.ResponseDeliverTx.Repr"}.AssignLink(nil)
}
func (na *_ResponseDeliverTx__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ResponseDeliverTx); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.ResponseDeliverTx.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ResponseDeliverTx__ReprAssembler) Prototype() ipld.NodePrototype {
	return _ResponseDeliverTx__ReprPrototype{}
}
func (ma *_ResponseDeliverTx__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_ResponseDeliverTx__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Code":
		if ma.s&fieldBit__ResponseDeliverTx_Code != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_Code_serial}
		}
		ma.s += fieldBit__ResponseDeliverTx_Code
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Code.w = &ma.w.Code
		ma.ca_Code.m = &ma.cm
		return &ma.ca_Code, nil
	case "Data":
		if ma.s&fieldBit__ResponseDeliverTx_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_Data_serial}
		}
		ma.s += fieldBit__ResponseDeliverTx_Data
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	case "GasWanted":
		if ma.s&fieldBit__ResponseDeliverTx_GasWanted != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_GasWanted_serial}
		}
		ma.s += fieldBit__ResponseDeliverTx_GasWanted
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_GasWanted.w = &ma.w.GasWanted
		ma.ca_GasWanted.m = &ma.cm
		return &ma.ca_GasWanted, nil
	case "GasUsed":
		if ma.s&fieldBit__ResponseDeliverTx_GasUsed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_GasUsed_serial}
		}
		ma.s += fieldBit__ResponseDeliverTx_GasUsed
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.ResponseDeliverTx.Repr", Key: &_String{k}}
}
func (ma *_ResponseDeliverTx__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ResponseDeliverTx__ReprKeyAssembler)(ma)
}
func (ma *_ResponseDeliverTx__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Code.w = &ma.w.Code
		ma.ca_Code.m = &ma.cm
		return &ma.ca_Code
	case 1:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	case 2:
		ma.ca_GasWanted.w = &ma.w.GasWanted
		ma.ca_GasWanted.m = &ma.cm
		return &ma.ca_GasWanted
	case 3:
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed
	default:
		panic("unreachable")
	}
}
func (ma *_ResponseDeliverTx__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__ResponseDeliverTx_sufficient != fieldBits__ResponseDeliverTx_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__ResponseDeliverTx_Code == 0 {
			err.Missing = append(err.Missing, "Code")
		}
		if ma.s&fieldBit__ResponseDeliverTx_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		if ma.s&fieldBit__ResponseDeliverTx_GasWanted == 0 {
			err.Missing = append(err.Missing, "GasWanted")
		}
		if ma.s&fieldBit__ResponseDeliverTx_GasUsed == 0 {
			err.Missing = append(err.Missing, "GasUsed")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ResponseDeliverTx__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ResponseDeliverTx__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _ResponseDeliverTx__ReprKeyAssembler _ResponseDeliverTx__ReprAssembler

func (_ResponseDeliverTx__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.Repr.KeyAssembler"}.BeginMap(0)
}
func (_ResponseDeliverTx__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_ResponseDeliverTx__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.Repr.KeyAssembler"}.AssignNull()
}
func (_ResponseDeliverTx__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.Repr.KeyAssembler"}.AssignBool(false)
}
func (_ResponseDeliverTx__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.Repr.KeyAssembler"}.AssignInt(0)
}
func (_ResponseDeliverTx__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ResponseDeliverTx__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Code":
		if ka.s&fieldBit__ResponseDeliverTx_Code != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_Code_serial}
		}
		ka.s += fieldBit__ResponseDeliverTx_Code
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Data":
		if ka.s&fieldBit__ResponseDeliverTx_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_Data_serial}
		}
		ka.s += fieldBit__ResponseDeliverTx_Data
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "GasWanted":
		if ka.s&fieldBit__ResponseDeliverTx_GasWanted != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_GasWanted_serial}
		}
		ka.s += fieldBit__ResponseDeliverTx_GasWanted
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "GasUsed":
		if ka.s&fieldBit__ResponseDeliverTx_GasUsed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ResponseDeliverTx_GasUsed_serial}
		}
		ka.s += fieldBit__ResponseDeliverTx_GasUsed
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.ResponseDeliverTx.Repr", Key: &_String{k}}
}
func (_ResponseDeliverTx__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_ResponseDeliverTx__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.ResponseDeliverTx.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ResponseDeliverTx__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ResponseDeliverTx__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _SMTInnerNode) FieldLeft() MaybeLink {
	return &n.Left
}
func (n _SMTInnerNode) FieldRight() MaybeLink {
	return &n.Right
}

type _SMTInnerNode__Maybe struct {
	m schema.Maybe
	v SMTInnerNode
}
type MaybeSMTInnerNode = *_SMTInnerNode__Maybe

func (m MaybeSMTInnerNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSMTInnerNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSMTInnerNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSMTInnerNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSMTInnerNode) Must() SMTInnerNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__SMTInnerNode_Left  = _String{"Left"}
	fieldName__SMTInnerNode_Right = _String{"Right"}
)
var _ ipld.Node = (SMTInnerNode)(&_SMTInnerNode{})
var _ schema.TypedNode = (SMTInnerNode)(&_SMTInnerNode{})

func (SMTInnerNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n SMTInnerNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Left":
		if n.Left.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Left.v, nil
	case "Right":
		if n.Right.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Right.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n SMTInnerNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (SMTInnerNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode"}.LookupByIndex(0)
}
func (n SMTInnerNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n SMTInnerNode) MapIterator() ipld.MapIterator {
	return &_SMTInnerNode__MapItr{n, 0}
}

type _SMTInnerNode__MapItr struct {
	n   SMTInnerNode
	idx int
}

func (itr *_SMTInnerNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SMTInnerNode_Left
		if itr.n.Left.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Left.v
	case 1:
		k = &fieldName__SMTInnerNode_Right
		if itr.n.Right.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Right.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SMTInnerNode__MapItr) Done() bool {
	return itr.idx >= 2
}

func (SMTInnerNode) ListIterator() ipld.ListIterator {
	return nil
}
func (SMTInnerNode) Length() int64 {
	return 2
}
func (SMTInnerNode) IsAbsent() bool {
	return false
}
func (SMTInnerNode) IsNull() bool {
	return false
}
func (SMTInnerNode) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode"}.AsBool()
}
func (SMTInnerNode) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode"}.AsInt()
}
func (SMTInnerNode) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode"}.AsFloat()
}
func (SMTInnerNode) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode"}.AsString()
}
func (SMTInnerNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode"}.AsBytes()
}
func (SMTInnerNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode"}.AsLink()
}
func (SMTInnerNode) Prototype() ipld.NodePrototype {
	return _SMTInnerNode__Prototype{}
}

type _SMTInnerNode__Prototype struct{}

func (_SMTInnerNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _SMTInnerNode__Builder
	nb.Reset()
	return &nb
}

type _SMTInnerNode__Builder struct {
	_SMTInnerNode__Assembler
}

func (nb *_SMTInnerNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SMTInnerNode__Builder) Reset() {
	var w _SMTInnerNode
	var m schema.Maybe
	*nb = _SMTInnerNode__Builder{_SMTInnerNode__Assembler{w: &w, m: &m}}
}

type _SMTInnerNode__Assembler struct {
	w     *_SMTInnerNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Left  _Link__Assembler
	ca_Right _Link__Assembler
}

func (na *_SMTInnerNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Left.reset()
	na.ca_Right.reset()
}

var (
	fieldBit__SMTInnerNode_Left        = 1 << 0
	fieldBit__SMTInnerNode_Right       = 1 << 1
	fieldBits__SMTInnerNode_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_SMTInnerNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SMTInnerNode{}
	}
	return na, nil
}
func (_SMTInnerNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode"}.BeginList(0)
}
func (na *_SMTInnerNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SMTInnerNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SMTInnerNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode"}.AssignBool(false)
}
func (_SMTInnerNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode"}.AssignInt(0)
}
func (_SMTInnerNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode"}.AssignFloat(0)
}
func (_SMTInnerNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode"}.AssignString("")
}
func (_SMTInnerNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode"}.AssignBytes(nil)
}
func (_SMTInnerNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode"}.AssignLink(nil)
}
func (na *_SMTInnerNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SMTInnerNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SMTInnerNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SMTInnerNode__Assembler) Prototype() ipld.NodePrototype {
	return _SMTInnerNode__Prototype{}
}
func (ma *_SMTInnerNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Left.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Left.v = ma.ca_Left.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.Right.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Right.v = ma.ca_Right.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SMTInnerNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Left":
		if ma.s&fieldBit__SMTInnerNode_Left != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SMTInnerNode_Left}
		}
		ma.s += fieldBit__SMTInnerNode_Left
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left, nil
	case "Right":
		if ma.s&fieldBit__SMTInnerNode_Right != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SMTInnerNode_Right}
		}
		ma.s += fieldBit__SMTInnerNode_Right
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTInnerNode", Key: &_String{k}}
}
func (ma *_SMTInnerNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SMTInnerNode__KeyAssembler)(ma)
}
func (ma *_SMTInnerNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left
	case 1:
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right
	default:
		panic("unreachable")
	}
}
func (ma *_SMTInnerNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SMTInnerNode_sufficient != fieldBits__SMTInnerNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SMTInnerNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SMTInnerNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _SMTInnerNode__KeyAssembler _SMTInnerNode__Assembler

func (_SMTInnerNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.KeyAssembler"}.BeginMap(0)
}
func (_SMTInnerNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.KeyAssembler"}.BeginList(0)
}
func (na *_SMTInnerNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.KeyAssembler"}.AssignNull()
}
func (_SMTInnerNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.KeyAssembler"}.AssignBool(false)
}
func (_SMTInnerNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.KeyAssembler"}.AssignInt(0)
}
func (_SMTInnerNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SMTInnerNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Left":
		if ka.s&fieldBit__SMTInnerNode_Left != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SMTInnerNode_Left}
		}
		ka.s += fieldBit__SMTInnerNode_Left
		ka.state = maState_expectValue
		ka.f = 0
	case "Right":
		if ka.s&fieldBit__SMTInnerNode_Right != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SMTInnerNode_Right}
		}
		ka.s += fieldBit__SMTInnerNode_Right
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTInnerNode", Key: &_String{k}}
	}
	return nil
}
func (_SMTInnerNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.KeyAssembler"}.AssignBytes(nil)
}
func (_SMTInnerNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SMTInnerNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SMTInnerNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (SMTInnerNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n SMTInnerNode) Representation() ipld.Node {
	return (*_SMTInnerNode__Repr)(n)
}

type _SMTInnerNode__Repr _SMTInnerNode

var (
	fieldName__SMTInnerNode_Left_serial  = _String{"Left"}
	fieldName__SMTInnerNode_Right_serial = _String{"Right"}
)
var _ ipld.Node = &_SMTInnerNode__Repr{}

func (_SMTInnerNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_SMTInnerNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Left":
		if n.Left.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Left.v.Representation(), nil
	case "Right":
		if n.Right.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Right.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_SMTInnerNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_SMTInnerNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode.Repr"}.LookupByIndex(0)
}
func (n _SMTInnerNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_SMTInnerNode__Repr) MapIterator() ipld.MapIterator {
	return &_SMTInnerNode__ReprMapItr{n, 0}
}

type _SMTInnerNode__ReprMapItr struct {
	n   *_SMTInnerNode__Repr
	idx int
}

func (itr *_SMTInnerNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SMTInnerNode_Left_serial
		if itr.n.Left.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Left.v.Representation()
	case 1:
		k = &fieldName__SMTInnerNode_Right_serial
		if itr.n.Right.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Right.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SMTInnerNode__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_SMTInnerNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_SMTInnerNode__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_SMTInnerNode__Repr) IsAbsent() bool {
	return false
}
func (_SMTInnerNode__Repr) IsNull() bool {
	return false
}
func (_SMTInnerNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode.Repr"}.AsBool()
}
func (_SMTInnerNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode.Repr"}.AsInt()
}
func (_SMTInnerNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode.Repr"}.AsFloat()
}
func (_SMTInnerNode__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode.Repr"}.AsString()
}
func (_SMTInnerNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode.Repr"}.AsBytes()
}
func (_SMTInnerNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SMTInnerNode.Repr"}.AsLink()
}
func (_SMTInnerNode__Repr) Prototype() ipld.NodePrototype {
	return _SMTInnerNode__ReprPrototype{}
}

type _SMTInnerNode__ReprPrototype struct{}

func (_SMTInnerNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _SMTInnerNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _SMTInnerNode__ReprBuilder struct {
	_SMTInnerNode__ReprAssembler
}

func (nb *_SMTInnerNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SMTInnerNode__ReprBuilder) Reset() {
	var w _SMTInnerNode
	var m schema.Maybe
	*nb = _SMTInnerNode__ReprBuilder{_SMTInnerNode__ReprAssembler{w: &w, m: &m}}
}

type _SMTInnerNode__ReprAssembler struct {
	w     *_SMTInnerNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Left  _Link__ReprAssembler
	ca_Right _Link__ReprAssembler
}

func (na *_SMTInnerNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Left.reset()
	na.ca_Right.reset()
}
func (na *_SMTInnerNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SMTInnerNode{}
	}
	return na, nil
}
func (_SMTInnerNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode.Repr"}.BeginList(0)
}
func (na *_SMTInnerNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SMTInnerNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SMTInnerNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode.Repr"}.AssignBool(false)
}
func (_SMTInnerNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode.Repr"}.AssignInt(0)
}
func (_SMTInnerNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode.Repr"}.AssignFloat(0)
}
func (_SMTInnerNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode.Repr"}.AssignString("")
}
func (_SMTInnerNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode.Repr"}.AssignBytes(nil)
}
func (_SMTInnerNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SMTInnerNode.Repr"}.AssignLink(nil)
}
func (na *_SMTInnerNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SMTInnerNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SMTInnerNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SMTInnerNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _SMTInnerNode__ReprPrototype{}
}
func (ma *_SMTInnerNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Left.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Left.v = ma.ca_Left.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.Right.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Right.v = ma.ca_Right.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SMTInnerNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Left":
		if ma.s&fieldBit__SMTInnerNode_Left != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SMTInnerNode_Left_serial}
		}
		ma.s += fieldBit__SMTInnerNode_Left
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left, nil
	case "Right":
		if ma.s&fieldBit__SMTInnerNode_Right != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SMTInnerNode_Right_serial}
		}
		ma.s += fieldBit__SMTInnerNode_Right
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTInnerNode.Repr", Key: &_String{k}}
}
func (ma *_SMTInnerNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SMTInnerNode__ReprKeyAssembler)(ma)
}
func (ma *_SMTInnerNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Left.w = ma.w.Left.v
		ma.ca_Left.m = &ma.w.Left.m
		ma.w.Left.m = allowNull
		return &ma.ca_Left
	case 1:
		ma.ca_Right.w = ma.w.Right.v
		ma.ca_Right.m = &ma.w.Right.m
		ma.w.Right.m = allowNull
		return &ma.ca_Right
	default:
		panic("unreachable")
	}
}
func (ma *_SMTInnerNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SMTInnerNode_sufficient != fieldBits__SMTInnerNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SMTInnerNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SMTInnerNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _SMTInnerNode__ReprKeyAssembler _SMTInnerNode__ReprAssembler

func (_SMTInnerNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_SMTInnerNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_SMTInnerNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.Repr.KeyAssembler"}.AssignNull()
}
func (_SMTInnerNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_SMTInnerNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_SMTInnerNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SMTInnerNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Left":
		if ka.s&fieldBit__SMTInnerNode_Left != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SMTInnerNode_Left_serial}
		}
		ka.s += fieldBit__SMTInnerNode_Left
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Right":
		if ka.s&fieldBit__SMTInnerNode_Right != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SMTInnerNode_Right_serial}
		}
		ka.s += fieldBit__SMTInnerNode_Right
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTInnerNode.Repr", Key: &_String{k}}
}
func (_SMTInnerNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_SMTInnerNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SMTInnerNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SMTInnerNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SMTInnerNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _SMTLeafNode) FieldPath() Hash {
	return &n.Path
}
func (n _SMTLeafNode) FieldValue() Hash {
	return &n.Value
}

type _SMTLeafNode__Maybe struct {
	m schema.Maybe
	v SMTLeafNode
}
type MaybeSMTLeafNode = *_SMTLeafNode__Maybe

func (m MaybeSMTLeafNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSMTLeafNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSMTLeafNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSMTLeafNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSMTLeafNode) Must() SMTLeafNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__SMTLeafNode_Path  = _String{"Path"}
	fieldName__SMTLeafNode_Value = _String{"Value"}
)
var _ ipld.Node = (SMTLeafNode)(&_SMTLeafNode{})
var _ schema.TypedNode = (SMTLeafNode)(&_SMTLeafNode{})

func (SMTLeafNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n SMTLeafNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Path":
		return &n.Path, nil
	case "Value":
		return &n.Value, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n SMTLeafNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (SMTLeafNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode"}.LookupByIndex(0)
}
func (n SMTLeafNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n SMTLeafNode) MapIterator() ipld.MapIterator {
	return &_SMTLeafNode__MapItr{n, 0}
}

type _SMTLeafNode__MapItr struct {
	n   SMTLeafNode
	idx int
}

func (itr *_SMTLeafNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SMTLeafNode_Path
		v = &itr.n.Path
	case 1:
		k = &fieldName__SMTLeafNode_Value
		v = &itr.n.Value
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SMTLeafNode__MapItr) Done() bool {
	return itr.idx >= 2
}

func (SMTLeafNode) ListIterator() ipld.ListIterator {
	return nil
}
func (SMTLeafNode) Length() int64 {
	return 2
}
func (SMTLeafNode) IsAbsent() bool {
	return false
}
func (SMTLeafNode) IsNull() bool {
	return false
}
func (SMTLeafNode) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode"}.AsBool()
}
func (SMTLeafNode) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode"}.AsInt()
}
func (SMTLeafNode) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode"}.AsFloat()
}
func (SMTLeafNode) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode"}.AsString()
}
func (SMTLeafNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode"}.AsBytes()
}
func (SMTLeafNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode"}.AsLink()
}
func (SMTLeafNode) Prototype() ipld.NodePrototype {
	return _SMTLeafNode__Prototype{}
}

type _SMTLeafNode__Prototype struct{}

func (_SMTLeafNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _SMTLeafNode__Builder
	nb.Reset()
	return &nb
}

type _SMTLeafNode__Builder struct {
	_SMTLeafNode__Assembler
}

func (nb *_SMTLeafNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SMTLeafNode__Builder) Reset() {
	var w _SMTLeafNode
	var m schema.Maybe
	*nb = _SMTLeafNode__Builder{_SMTLeafNode__Assembler{w: &w, m: &m}}
}

type _SMTLeafNode__Assembler struct {
	w     *_SMTLeafNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Path  _Hash__Assembler
	ca_Value _Hash__Assembler
}

func (na *_SMTLeafNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Path.reset()
	na.ca_Value.reset()
}

var (
	fieldBit__SMTLeafNode_Path        = 1 << 0
	fieldBit__SMTLeafNode_Value       = 1 << 1
	fieldBits__SMTLeafNode_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_SMTLeafNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SMTLeafNode{}
	}
	return na, nil
}
func (_SMTLeafNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode"}.BeginList(0)
}
func (na *_SMTLeafNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SMTLeafNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SMTLeafNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode"}.AssignBool(false)
}
func (_SMTLeafNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode"}.AssignInt(0)
}
func (_SMTLeafNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode"}.AssignFloat(0)
}
func (_SMTLeafNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode"}.AssignString("")
}
func (_SMTLeafNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode"}.AssignBytes(nil)
}
func (_SMTLeafNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode"}.AssignLink(nil)
}
func (na *_SMTLeafNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SMTLeafNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SMTLeafNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SMTLeafNode__Assembler) Prototype() ipld.NodePrototype {
	return _SMTLeafNode__Prototype{}
}
func (ma *_SMTLeafNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Path.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Value.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SMTLeafNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Path":
		if ma.s&fieldBit__SMTLeafNode_Path != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SMTLeafNode_Path}
		}
		ma.s += fieldBit__SMTLeafNode_Path
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Path.w = &ma.w.Path
		ma.ca_Path.m = &ma.cm
		return &ma.ca_Path, nil
	case "Value":
		if ma.s&fieldBit__SMTLeafNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SMTLeafNode_Value}
		}
		ma.s += fieldBit__SMTLeafNode_Value
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTLeafNode", Key: &_String{k}}
}
func (ma *_SMTLeafNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SMTLeafNode__KeyAssembler)(ma)
}
func (ma *_SMTLeafNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Path.w = &ma.w.Path
		ma.ca_Path.m = &ma.cm
		return &ma.ca_Path
	case 1:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_SMTLeafNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SMTLeafNode_sufficient != fieldBits__SMTLeafNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__SMTLeafNode_Path == 0 {
			err.Missing = append(err.Missing, "Path")
		}
		if ma.s&fieldBit__SMTLeafNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SMTLeafNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SMTLeafNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _SMTLeafNode__KeyAssembler _SMTLeafNode__Assembler

func (_SMTLeafNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.KeyAssembler"}.BeginMap(0)
}
func (_SMTLeafNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.KeyAssembler"}.BeginList(0)
}
func (na *_SMTLeafNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.KeyAssembler"}.AssignNull()
}
func (_SMTLeafNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.KeyAssembler"}.AssignBool(false)
}
func (_SMTLeafNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.KeyAssembler"}.AssignInt(0)
}
func (_SMTLeafNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SMTLeafNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Path":
		if ka.s&fieldBit__SMTLeafNode_Path != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SMTLeafNode_Path}
		}
		ka.s += fieldBit__SMTLeafNode_Path
		ka.state = maState_expectValue
		ka.f = 0
	case "Value":
		if ka.s&fieldBit__SMTLeafNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SMTLeafNode_Value}
		}
		ka.s += fieldBit__SMTLeafNode_Value
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTLeafNode", Key: &_String{k}}
	}
	return nil
}
func (_SMTLeafNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.KeyAssembler"}.AssignBytes(nil)
}
func (_SMTLeafNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SMTLeafNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SMTLeafNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (SMTLeafNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n SMTLeafNode) Representation() ipld.Node {
	return (*_SMTLeafNode__Repr)(n)
}

type _SMTLeafNode__Repr _SMTLeafNode

var (
	fieldName__SMTLeafNode_Path_serial  = _String{"Path"}
	fieldName__SMTLeafNode_Value_serial = _String{"Value"}
)
var _ ipld.Node = &_SMTLeafNode__Repr{}

func (_SMTLeafNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_SMTLeafNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Path":
		return n.Path.Representation(), nil
	case "Value":
		return n.Value.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_SMTLeafNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_SMTLeafNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode.Repr"}.LookupByIndex(0)
}
func (n _SMTLeafNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_SMTLeafNode__Repr) MapIterator() ipld.MapIterator {
	return &_SMTLeafNode__ReprMapItr{n, 0}
}

type _SMTLeafNode__ReprMapItr struct {
	n   *_SMTLeafNode__Repr
	idx int
}

func (itr *_SMTLeafNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SMTLeafNode_Path_serial
		v = itr.n.Path.Representation()
	case 1:
		k = &fieldName__SMTLeafNode_Value_serial
		v = itr.n.Value.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SMTLeafNode__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_SMTLeafNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_SMTLeafNode__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_SMTLeafNode__Repr) IsAbsent() bool {
	return false
}
func (_SMTLeafNode__Repr) IsNull() bool {
	return false
}
func (_SMTLeafNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode.Repr"}.AsBool()
}
func (_SMTLeafNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode.Repr"}.AsInt()
}
func (_SMTLeafNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode.Repr"}.AsFloat()
}
func (_SMTLeafNode__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode.Repr"}.AsString()
}
func (_SMTLeafNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode.Repr"}.AsBytes()
}
func (_SMTLeafNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SMTLeafNode.Repr"}.AsLink()
}
func (_SMTLeafNode__Repr) Prototype() ipld.NodePrototype {
	return _SMTLeafNode__ReprPrototype{}
}

type _SMTLeafNode__ReprPrototype struct{}

func (_SMTLeafNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _SMTLeafNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _SMTLeafNode__ReprBuilder struct {
	_SMTLeafNode__ReprAssembler
}

func (nb *_SMTLeafNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SMTLeafNode__ReprBuilder) Reset() {
	var w _SMTLeafNode
	var m schema.Maybe
	*nb = _SMTLeafNode__ReprBuilder{_SMTLeafNode__ReprAssembler{w: &w, m: &m}}
}

type _SMTLeafNode__ReprAssembler struct {
	w     *_SMTLeafNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Path  _Hash__ReprAssembler
	ca_Value _Hash__ReprAssembler
}

func (na *_SMTLeafNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Path.reset()
	na.ca_Value.reset()
}
func (na *_SMTLeafNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SMTLeafNode{}
	}
	return na, nil
}
func (_SMTLeafNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode.Repr"}.BeginList(0)
}
func (na *_SMTLeafNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SMTLeafNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SMTLeafNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode.Repr"}.AssignBool(false)
}
func (_SMTLeafNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode.Repr"}.AssignInt(0)
}
func (_SMTLeafNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode.Repr"}.AssignFloat(0)
}
func (_SMTLeafNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode.Repr"}.AssignString("")
}
func (_SMTLeafNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode.Repr"}.AssignBytes(nil)
}
func (_SMTLeafNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SMTLeafNode.Repr"}.AssignLink(nil)
}
func (na *_SMTLeafNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SMTLeafNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SMTLeafNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SMTLeafNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _SMTLeafNode__ReprPrototype{}
}
func (ma *_SMTLeafNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SMTLeafNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Path":
		if ma.s&fieldBit__SMTLeafNode_Path != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SMTLeafNode_Path_serial}
		}
		ma.s += fieldBit__SMTLeafNode_Path
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Path.w = &ma.w.Path
		ma.ca_Path.m = &ma.cm
		return &ma.ca_Path, nil
	case "Value":
		if ma.s&fieldBit__SMTLeafNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SMTLeafNode_Value_serial}
		}
		ma.s += fieldBit__SMTLeafNode_Value
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTLeafNode.Repr", Key: &_String{k}}
}
func (ma *_SMTLeafNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SMTLeafNode__ReprKeyAssembler)(ma)
}
func (ma *_SMTLeafNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Path.w = &ma.w.Path
		ma.ca_Path.m = &ma.cm
		return &ma.ca_Path
	case 1:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_SMTLeafNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SMTLeafNode_sufficient != fieldBits__SMTLeafNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__SMTLeafNode_Path == 0 {
			err.Missing = append(err.Missing, "Path")
		}
		if ma.s&fieldBit__SMTLeafNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SMTLeafNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SMTLeafNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _SMTLeafNode__ReprKeyAssembler _SMTLeafNode__ReprAssembler

func (_SMTLeafNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_SMTLeafNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_SMTLeafNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.Repr.KeyAssembler"}.AssignNull()
}
func (_SMTLeafNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_SMTLeafNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_SMTLeafNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SMTLeafNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Path":
		if ka.s&fieldBit__SMTLeafNode_Path != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SMTLeafNode_Path_serial}
		}
		ka.s += fieldBit__SMTLeafNode_Path
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Value":
		if ka.s&fieldBit__SMTLeafNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SMTLeafNode_Value_serial}
		}
		ka.s += fieldBit__SMTLeafNode_Value
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTLeafNode.Repr", Key: &_String{k}}
}
func (_SMTLeafNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_SMTLeafNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SMTLeafNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SMTLeafNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SMTLeafNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _SMTNode) AsInterface() _SMTNode__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	default:
		panic("invalid union state; how did you create this object?")
	}
}

type _SMTNode__Maybe struct {
	m schema.Maybe
	v SMTNode
}
type MaybeSMTNode = *_SMTNode__Maybe

func (m MaybeSMTNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSMTNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSMTNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSMTNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSMTNode) Must() SMTNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	memberName__SMTNode_SMTInnerNode = _String{"SMTInnerNode"}
	memberName__SMTNode_SMTLeafNode  = _String{"SMTLeafNode"}
)
var _ ipld.Node = (SMTNode)(&_SMTNode{})
var _ schema.TypedNode = (SMTNode)(&_SMTNode{})

func (SMTNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n SMTNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "SMTInnerNode":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "SMTLeafNode":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n SMTNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (SMTNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SMTNode"}.LookupByIndex(0)
}
func (n SMTNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n SMTNode) MapIterator() ipld.MapIterator {
	return &_SMTNode__MapItr{n, false}
}

type _SMTNode__MapItr struct {
	n    SMTNode
	done bool
}

func (itr *_SMTNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__SMTNode_SMTInnerNode, &itr.n.x1
	case 2:
		k, v = &memberName__SMTNode_SMTLeafNode, &itr.n.x2
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_SMTNode__MapItr) Done() bool {
	return itr.done
}

func (SMTNode) ListIterator() ipld.ListIterator {
	return nil
}
func (SMTNode) Length() int64 {
	return 1
}
func (SMTNode) IsAbsent() bool {
	return false
}
func (SMTNode) IsNull() bool {
	return false
}
func (SMTNode) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SMTNode"}.AsBool()
}
func (SMTNode) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SMTNode"}.AsInt()
}
func (SMTNode) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SMTNode"}.AsFloat()
}
func (SMTNode) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SMTNode"}.AsString()
}
func (SMTNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SMTNode"}.AsBytes()
}
func (SMTNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SMTNode"}.AsLink()
}
func (SMTNode) Prototype() ipld.NodePrototype {
	return _SMTNode__Prototype{}
}

type _SMTNode__Prototype struct{}

func (_SMTNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _SMTNode__Builder
	nb.Reset()
	return &nb
}

type _SMTNode__Builder struct {
	_SMTNode__Assembler
}

func (nb *_SMTNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SMTNode__Builder) Reset() {
	var w _SMTNode
	var m schema.Maybe
	*nb = _SMTNode__Builder{_SMTNode__Assembler{w: &w, m: &m}}
}

type _SMTNode__Assembler struct {
	w     *_SMTNode
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _SMTInnerNode__Assembler

	ca2 _SMTLeafNode__Assembler
	ca  uint
}

func (na *_SMTNode__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_SMTNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SMTNode{}
	}
	return na, nil
}
func (_SMTNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SMTNode"}.BeginList(0)
}
func (na *_SMTNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SMTNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SMTNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode"}.AssignBool(false)
}
func (_SMTNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode"}.AssignInt(0)
}
func (_SMTNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode"}.AssignFloat(0)
}
func (_SMTNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode"}.AssignString("")
}
func (_SMTNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode"}.AssignBytes(nil)
}
func (_SMTNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode"}.AssignLink(nil)
}
func (na *_SMTNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SMTNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SMTNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SMTNode__Assembler) Prototype() ipld.NodePrototype {
	return _SMTNode__Prototype{}
}
func (ma *_SMTNode__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_SMTNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.SMTNode", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "SMTInnerNode":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "SMTLeafNode":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTNode", Key: &_String{k}}
}
func (ma *_SMTNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SMTNode__KeyAssembler)(ma)
}
func (ma *_SMTNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_SMTNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.SMTNode", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SMTNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SMTNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "SMTInnerNode":
		return _SMTInnerNode__Prototype{}
	case "SMTLeafNode":
		return _SMTLeafNode__Prototype{}
	default:
		return nil
	}
}

type _SMTNode__KeyAssembler _SMTNode__Assembler

func (_SMTNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTNode.KeyAssembler"}.BeginMap(0)
}
func (_SMTNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTNode.KeyAssembler"}.BeginList(0)
}
func (na *_SMTNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.KeyAssembler"}.AssignNull()
}
func (_SMTNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.KeyAssembler"}.AssignBool(false)
}
func (_SMTNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.KeyAssembler"}.AssignInt(0)
}
func (_SMTNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SMTNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.SMTNode", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "SMTInnerNode":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "SMTLeafNode":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTNode", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_SMTNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.KeyAssembler"}.AssignBytes(nil)
}
func (_SMTNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SMTNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SMTNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (SMTNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n SMTNode) Representation() ipld.Node {
	return (*_SMTNode__Repr)(n)
}

type _SMTNode__Repr _SMTNode

var (
	memberName__SMTNode_SMTInnerNode_serial = _String{"inner"}
	memberName__SMTNode_SMTLeafNode_serial  = _String{"leaf"}
)
var _ ipld.Node = &_SMTNode__Repr{}

func (_SMTNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_SMTNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "inner":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "leaf":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_SMTNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_SMTNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SMTNode.Repr"}.LookupByIndex(0)
}
func (n _SMTNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_SMTNode__Repr) MapIterator() ipld.MapIterator {
	return &_SMTNode__ReprMapItr{n, false}
}

type _SMTNode__ReprMapItr struct {
	n    *_SMTNode__Repr
	done bool
}

func (itr *_SMTNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__SMTNode_SMTInnerNode_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__SMTNode_SMTLeafNode_serial, itr.n.x2.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_SMTNode__ReprMapItr) Done() bool {
	return itr.done
}

func (_SMTNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_SMTNode__Repr) Length() int64 {
	return 1
}
func (_SMTNode__Repr) IsAbsent() bool {
	return false
}
func (_SMTNode__Repr) IsNull() bool {
	return false
}
func (_SMTNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SMTNode.Repr"}.AsBool()
}
func (_SMTNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SMTNode.Repr"}.AsInt()
}
func (_SMTNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SMTNode.Repr"}.AsFloat()
}
func (_SMTNode__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SMTNode.Repr"}.AsString()
}
func (_SMTNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SMTNode.Repr"}.AsBytes()
}
func (_SMTNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SMTNode.Repr"}.AsLink()
}
func (_SMTNode__Repr) Prototype() ipld.NodePrototype {
	return _SMTNode__ReprPrototype{}
}

type _SMTNode__ReprPrototype struct{}

func (_SMTNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _SMTNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _SMTNode__ReprBuilder struct {
	_SMTNode__ReprAssembler
}

func (nb *_SMTNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SMTNode__ReprBuilder) Reset() {
	var w _SMTNode
	var m schema.Maybe
	*nb = _SMTNode__ReprBuilder{_SMTNode__ReprAssembler{w: &w, m: &m}}
}

type _SMTNode__ReprAssembler struct {
	w     *_SMTNode
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _SMTInnerNode__ReprAssembler

	ca2 _SMTLeafNode__ReprAssembler
	ca  uint
}

func (na *_SMTNode__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_SMTNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SMTNode{}
	}
	return na, nil
}
func (_SMTNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SMTNode.Repr"}.BeginList(0)
}
func (na *_SMTNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SMTNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SMTNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode.Repr"}.AssignBool(false)
}
func (_SMTNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode.Repr"}.AssignInt(0)
}
func (_SMTNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode.Repr"}.AssignFloat(0)
}
func (_SMTNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode.Repr"}.AssignString("")
}
func (_SMTNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode.Repr"}.AssignBytes(nil)
}
func (_SMTNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SMTNode.Repr"}.AssignLink(nil)
}
func (na *_SMTNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SMTNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SMTNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SMTNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _SMTNode__ReprPrototype{}
}
func (ma *_SMTNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_SMTNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.SMTNode.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "inner":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "leaf":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTNode.Repr", Key: &_String{k}}
}
func (ma *_SMTNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SMTNode__ReprKeyAssembler)(ma)
}
func (ma *_SMTNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_SMTNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.SMTNode.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SMTNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SMTNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "SMTInnerNode":
		return _SMTInnerNode__ReprPrototype{}
	case "SMTLeafNode":
		return _SMTLeafNode__ReprPrototype{}
	default:
		return nil
	}
}

type _SMTNode__ReprKeyAssembler _SMTNode__ReprAssembler

func (_SMTNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_SMTNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SMTNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_SMTNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.Repr.KeyAssembler"}.AssignNull()
}
func (_SMTNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_SMTNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_SMTNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SMTNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.SMTNode.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "inner":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "leaf":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.SMTNode.Repr", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_SMTNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_SMTNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SMTNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SMTNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SMTNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Signature) Bytes() []byte {
	return n.x
}
func (_Signature__Prototype) FromBytes(v []byte) (Signature, error) {
	n := _Signature{v}
	return &n, nil
}

type _Signature__Maybe struct {
	m schema.Maybe
	v Signature
}
type MaybeSignature = *_Signature__Maybe

func (m MaybeSignature) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSignature) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSignature) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSignature) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSignature) Must() Signature {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Signature)(&_Signature{})
var _ schema.TypedNode = (Signature)(&_Signature{})

func (Signature) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Signature) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.LookupByString("")
}
func (Signature) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.LookupByNode(nil)
}
func (Signature) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.LookupByIndex(0)
}
func (Signature) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.LookupBySegment(seg)
}
func (Signature) MapIterator() ipld.MapIterator {
	return nil
}
func (Signature) ListIterator() ipld.ListIterator {
	return nil
}
func (Signature) Length() int64 {
	return -1
}
func (Signature) IsAbsent() bool {
	return false
}
func (Signature) IsNull() bool {
	return false
}
func (Signature) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.AsBool()
}
func (Signature) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.AsInt()
}
func (Signature) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.AsFloat()
}
func (Signature) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.AsString()
}
func (n Signature) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Signature) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.AsLink()
}
func (Signature) Prototype() ipld.NodePrototype {
	return _Signature__Prototype{}
}

type _Signature__Prototype struct{}

func (_Signature__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Signature__Builder
	nb.Reset()
	return &nb
}

type _Signature__Builder struct {
	_Signature__Assembler
}

func (nb *_Signature__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Signature__Builder) Reset() {
	var w _Signature
	var m schema.Maybe
	*nb = _Signature__Builder{_Signature__Assembler{w: &w, m: &m}}
}

type _Signature__Assembler struct {
	w *_Signature
	m *schema.Maybe
}

func (na *_Signature__Assembler) reset() {}
func (_Signature__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.BeginMap(0)
}
func (_Signature__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.BeginList(0)
}
func (na *_Signature__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Signature__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignBool(false)
}
func (_Signature__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignInt(0)
}
func (_Signature__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignFloat(0)
}
func (_Signature__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignString("")
}
func (na *_Signature__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Signature{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Signature__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignLink(nil)
}
func (na *_Signature__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Signature); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Signature__Assembler) Prototype() ipld.NodePrototype {
	return _Signature__Prototype{}
}
func (Signature) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Signature) Representation() ipld.Node {
	return (*_Signature__Repr)(n)
}

type _Signature__Repr = _Signature

var _ ipld.Node = &_Signature__Repr{}

type _Signature__ReprPrototype = _Signature__Prototype
type _Signature__ReprAssembler = _Signature__Assembler

func (n *_Signatures) Lookup(idx int64) CommitSig {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Signatures) LookupMaybe(idx int64) MaybeCommitSig {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_CommitSig__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Signatures__valueAbsent = _CommitSig__Maybe{m: schema.Maybe_Absent}

func (n Signatures) Iterator() *Signatures__Itr {
	return &Signatures__Itr{n, 0}
}

type Signatures__Itr struct {
	n   Signatures
	idx int
}

func (itr *Signatures__Itr) Next() (idx int64, v CommitSig) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Signatures__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Signatures__Maybe struct {
	m schema.Maybe
	v Signatures
}
type MaybeSignatures = *_Signatures__Maybe

func (m MaybeSignatures) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSignatures) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSignatures) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSignatures) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSignatures) Must() Signatures {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Signatures)(&_Signatures{})
var _ schema.TypedNode = (Signatures)(&_Signatures{})

func (Signatures) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Signatures) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Signatures"}.LookupByString("")
}
func (n Signatures) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Signatures) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Signatures) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Signatures", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Signatures) MapIterator() ipld.MapIterator {
	return nil
}
func (n Signatures) ListIterator() ipld.ListIterator {
	return &_Signatures__ListItr{n, 0}
}

type _Signatures__ListItr struct {
	n   Signatures
	idx int
}

func (itr *_Signatures__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Signatures__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Signatures) Length() int64 {
	return int64(len(n.x))
}
func (Signatures) IsAbsent() bool {
	return false
}
func (Signatures) IsNull() bool {
	return false
}
func (Signatures) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsBool()
}
func (Signatures) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsInt()
}
func (Signatures) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsFloat()
}
func (Signatures) AsString() (string, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsString()
}
func (Signatures) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsBytes()
}
func (Signatures) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsLink()
}
func (Signatures) Prototype() ipld.NodePrototype {
	return _Signatures__Prototype{}
}

type _Signatures__Prototype struct{}

func (_Signatures__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Signatures__Builder
	nb.Reset()
	return &nb
}

type _Signatures__Builder struct {
	_Signatures__Assembler
}

func (nb *_Signatures__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Signatures__Builder) Reset() {
	var w _Signatures
	var m schema.Maybe
	*nb = _Signatures__Builder{_Signatures__Assembler{w: &w, m: &m}}
}

type _Signatures__Assembler struct {
	w     *_Signatures
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _CommitSig__Assembler
}

func (na *_Signatures__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Signatures__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.BeginMap(0)
}
func (na *_Signatures__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Signatures{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_CommitSig, 0, sizeHint)
	}
	return na, nil
}
func (na *_Signatures__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Signatures__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignBool(false)
}
func (_Signatures__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignInt(0)
}
func (_Signatures__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignFloat(0)
}
func (_Signatures__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignString("")
}
func (_Signatures__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignBytes(nil)
}
func (_Signatures__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignLink(nil)
}
func (na *_Signatures__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Signatures); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Signatures", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Signatures__Assembler) Prototype() ipld.NodePrototype {
	return _Signatures__Prototype{}
}
func (la *_Signatures__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Signatures__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _CommitSig{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Signatures__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Signatures__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _CommitSig__Prototype{}
}
func (Signatures) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Signatures) Representation() ipld.Node {
	return (*_Signatures__Repr)(n)
}

type _Signatures__Repr _Signatures

var _ ipld.Node = &_Signatures__Repr{}

func (_Signatures__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Signatures__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.LookupByString("")
}
func (nr *_Signatures__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Signatures)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(CommitSig).Representation(), nil
}
func (nr *_Signatures__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Signatures)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(CommitSig).Representation(), nil
}
func (n _Signatures__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Signatures.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Signatures__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Signatures__Repr) ListIterator() ipld.ListIterator {
	return &_Signatures__ReprListItr{(Signatures)(nr), 0}
}

type _Signatures__ReprListItr _Signatures__ListItr

func (itr *_Signatures__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Signatures__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(CommitSig).Representation(), nil
}
func (itr *_Signatures__ReprListItr) Done() bool {
	return (*_Signatures__ListItr)(itr).Done()
}

func (rn *_Signatures__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Signatures__Repr) IsAbsent() bool {
	return false
}
func (_Signatures__Repr) IsNull() bool {
	return false
}
func (_Signatures__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsBool()
}
func (_Signatures__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsInt()
}
func (_Signatures__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsFloat()
}
func (_Signatures__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsString()
}
func (_Signatures__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsBytes()
}
func (_Signatures__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsLink()
}
func (_Signatures__Repr) Prototype() ipld.NodePrototype {
	return _Signatures__ReprPrototype{}
}

type _Signatures__ReprPrototype struct{}

func (_Signatures__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Signatures__ReprBuilder
	nb.Reset()
	return &nb
}

type _Signatures__ReprBuilder struct {
	_Signatures__ReprAssembler
}

func (nb *_Signatures__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Signatures__ReprBuilder) Reset() {
	var w _Signatures
	var m schema.Maybe
	*nb = _Signatures__ReprBuilder{_Signatures__ReprAssembler{w: &w, m: &m}}
}

type _Signatures__ReprAssembler struct {
	w     *_Signatures
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _CommitSig__ReprAssembler
}

func (na *_Signatures__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Signatures__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.BeginMap(0)
}
func (na *_Signatures__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Signatures{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_CommitSig, 0, sizeHint)
	}
	return na, nil
}
func (na *_Signatures__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Signatures.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Signatures__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignBool(false)
}
func (_Signatures__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignInt(0)
}
func (_Signatures__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignFloat(0)
}
func (_Signatures__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignString("")
}
func (_Signatures__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignBytes(nil)
}
func (_Signatures__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignLink(nil)
}
func (na *_Signatures__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Signatures); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Signatures.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Signatures__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Signatures__ReprPrototype{}
}
func (la *_Signatures__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Signatures__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _CommitSig{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Signatures__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Signatures__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _CommitSig__ReprPrototype{}
}

func (n _SignedHeader) FieldHeader() Header {
	return &n.Header
}
func (n _SignedHeader) FieldCommit() Commit {
	return &n.Commit
}

type _SignedHeader__Maybe struct {
	m schema.Maybe
	v SignedHeader
}
type MaybeSignedHeader = *_SignedHeader__Maybe

func (m MaybeSignedHeader) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSignedHeader) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSignedHeader) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSignedHeader) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSignedHeader) Must() SignedHeader {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__SignedHeader_Header = _String{"Header"}
	fieldName__SignedHeader_Commit = _String{"Commit"}
)
var _ ipld.Node = (SignedHeader)(&_SignedHeader{})
var _ schema.TypedNode = (SignedHeader)(&_SignedHeader{})

func (SignedHeader) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n SignedHeader) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Header":
		return &n.Header, nil
	case "Commit":
		return &n.Commit, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n SignedHeader) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (SignedHeader) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.LookupByIndex(0)
}
func (n SignedHeader) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n SignedHeader) MapIterator() ipld.MapIterator {
	return &_SignedHeader__MapItr{n, 0}
}

type _SignedHeader__MapItr struct {
	n   SignedHeader
	idx int
}

func (itr *_SignedHeader__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SignedHeader_Header
		v = &itr.n.Header
	case 1:
		k = &fieldName__SignedHeader_Commit
		v = &itr.n.Commit
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SignedHeader__MapItr) Done() bool {
	return itr.idx >= 2
}

func (SignedHeader) ListIterator() ipld.ListIterator {
	return nil
}
func (SignedHeader) Length() int64 {
	return 2
}
func (SignedHeader) IsAbsent() bool {
	return false
}
func (SignedHeader) IsNull() bool {
	return false
}
func (SignedHeader) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsBool()
}
func (SignedHeader) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsInt()
}
func (SignedHeader) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsFloat()
}
func (SignedHeader) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsString()
}
func (SignedHeader) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsBytes()
}
func (SignedHeader) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsLink()
}
func (SignedHeader) Prototype() ipld.NodePrototype {
	return _SignedHeader__Prototype{}
}

type _SignedHeader__Prototype struct{}

func (_SignedHeader__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _SignedHeader__Builder
	nb.Reset()
	return &nb
}

type _SignedHeader__Builder struct {
	_SignedHeader__Assembler
}

func (nb *_SignedHeader__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SignedHeader__Builder) Reset() {
	var w _SignedHeader
	var m schema.Maybe
	*nb = _SignedHeader__Builder{_SignedHeader__Assembler{w: &w, m: &m}}
}

type _SignedHeader__Assembler struct {
	w     *_SignedHeader
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm        schema.Maybe
	ca_Header _Header__Assembler
	ca_Commit _Commit__Assembler
}

func (na *_SignedHeader__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Header.reset()
	na.ca_Commit.reset()
}

var (
	fieldBit__SignedHeader_Header      = 1 << 0
	fieldBit__SignedHeader_Commit      = 1 << 1
	fieldBits__SignedHeader_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_SignedHeader__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SignedHeader{}
	}
	return na, nil
}
func (_SignedHeader__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.BeginList(0)
}
func (na *_SignedHeader__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SignedHeader__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignBool(false)
}
func (_SignedHeader__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignInt(0)
}
func (_SignedHeader__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignFloat(0)
}
func (_SignedHeader__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignString("")
}
func (_SignedHeader__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignBytes(nil)
}
func (_SignedHeader__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignLink(nil)
}
func (na *_SignedHeader__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SignedHeader); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SignedHeader", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SignedHeader__Assembler) Prototype() ipld.NodePrototype {
	return _SignedHeader__Prototype{}
}
func (ma *_SignedHeader__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Header.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Commit.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SignedHeader__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Header":
		if ma.s&fieldBit__SignedHeader_Header != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Header}
		}
		ma.s += fieldBit__SignedHeader_Header
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header, nil
	case "Commit":
		if ma.s&fieldBit__SignedHeader_Commit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Commit}
		}
		ma.s += fieldBit__SignedHeader_Commit
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Commit.w = &ma.w.Commit
		ma.ca_Commit.m = &ma.cm
		return &ma.ca_Commit, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SignedHeader", Key: &_String{k}}
}
func (ma *_SignedHeader__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SignedHeader__KeyAssembler)(ma)
}
func (ma *_SignedHeader__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header
	case 1:
		ma.ca_Commit.w = &ma.w.Commit
		ma.ca_Commit.m = &ma.cm
		return &ma.ca_Commit
	default:
		panic("unreachable")
	}
}
func (ma *_SignedHeader__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SignedHeader_sufficient != fieldBits__SignedHeader_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__SignedHeader_Header == 0 {
			err.Missing = append(err.Missing, "Header")
		}
		if ma.s&fieldBit__SignedHeader_Commit == 0 {
			err.Missing = append(err.Missing, "Commit")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SignedHeader__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SignedHeader__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _SignedHeader__KeyAssembler _SignedHeader__Assembler

func (_SignedHeader__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.BeginMap(0)
}
func (_SignedHeader__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.BeginList(0)
}
func (na *_SignedHeader__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignNull()
}
func (_SignedHeader__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignBool(false)
}
func (_SignedHeader__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignInt(0)
}
func (_SignedHeader__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SignedHeader__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Header":
		if ka.s&fieldBit__SignedHeader_Header != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Header}
		}
		ka.s += fieldBit__SignedHeader_Header
		ka.state = maState_expectValue
		ka.f = 0
	case "Commit":
		if ka.s&fieldBit__SignedHeader_Commit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Commit}
		}
		ka.s += fieldBit__SignedHeader_Commit
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.SignedHeader", Key: &_String{k}}
	}
	return nil
}
func (_SignedHeader__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignBytes(nil)
}
func (_SignedHeader__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SignedHeader__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SignedHeader__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (SignedHeader) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n SignedHeader) Representation() ipld.Node {
	return (*_SignedHeader__Repr)(n)
}

type _SignedHeader__Repr _SignedHeader

var (
	fieldName__SignedHeader_Header_serial = _String{"Header"}
	fieldName__SignedHeader_Commit_serial = _String{"Commit"}
)
var _ ipld.Node = &_SignedHeader__Repr{}

func (_SignedHeader__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_SignedHeader__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Header":
		return n.Header.Representation(), nil
	case "Commit":
		return n.Commit.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_SignedHeader__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_SignedHeader__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.LookupByIndex(0)
}
func (n _SignedHeader__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_SignedHeader__Repr) MapIterator() ipld.MapIterator {
	return &_SignedHeader__ReprMapItr{n, 0}
}

type _SignedHeader__ReprMapItr struct {
	n   *_SignedHeader__Repr
	idx int
}

func (itr *_SignedHeader__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SignedHeader_Header_serial
		v = itr.n.Header.Representation()
	case 1:
		k = &fieldName__SignedHeader_Commit_serial
		v = itr.n.Commit.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SignedHeader__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_SignedHeader__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_SignedHeader__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_SignedHeader__Repr) IsAbsent() bool {
	return false
}
func (_SignedHeader__Repr) IsNull() bool {
	return false
}
func (_SignedHeader__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsBool()
}
func (_SignedHeader__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsInt()
}
func (_SignedHeader__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsFloat()
}
func (_SignedHeader__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsString()
}
func (_SignedHeader__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsBytes()
}
func (_SignedHeader__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsLink()
}
func (_SignedHeader__Repr) Prototype() ipld.NodePrototype {
	return _SignedHeader__ReprPrototype{}
}

type _SignedHeader__ReprPrototype struct{}

func (_SignedHeader__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _SignedHeader__ReprBuilder
	nb.Reset()
	return &nb
}

type _SignedHeader__ReprBuilder struct {
	_SignedHeader__ReprAssembler
}

func (nb *_SignedHeader__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SignedHeader__ReprBuilder) Reset() {
	var w _SignedHeader
	var m schema.Maybe
	*nb = _SignedHeader__ReprBuilder{_SignedHeader__ReprAssembler{w: &w, m: &m}}
}

type _SignedHeader__ReprAssembler struct {
	w     *_SignedHeader
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm        schema.Maybe
	ca_Header _Header__ReprAssembler
	ca_Commit _Commit__ReprAssembler
}

func (na *_SignedHeader__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Header.reset()
	na.ca_Commit.reset()
}
func (na *_SignedHeader__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SignedHeader{}
	}
	return na, nil
}
func (_SignedHeader__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.BeginList(0)
}
func (na *_SignedHeader__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SignedHeader__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignBool(false)
}
func (_SignedHeader__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignInt(0)
}
func (_SignedHeader__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignFloat(0)
}
func (_SignedHeader__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignString("")
}
func (_SignedHeader__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignBytes(nil)
}
func (_SignedHeader__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignLink(nil)
}
func (na *_SignedHeader__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SignedHeader); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SignedHeader.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SignedHeader__ReprAssembler) Prototype() ipld.NodePrototype {
	return _SignedHeader__ReprPrototype{}
}
func (ma *_SignedHeader__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SignedHeader__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Header":
		if ma.s&fieldBit__SignedHeader_Header != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Header_serial}
		}
		ma.s += fieldBit__SignedHeader_Header
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header, nil
	case "Commit":
		if ma.s&fieldBit__SignedHeader_Commit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Commit_serial}
		}
		ma.s += fieldBit__SignedHeader_Commit
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Commit.w = &ma.w.Commit
		ma.ca_Commit.m = &ma.cm
		return &ma.ca_Commit, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SignedHeader.Repr", Key: &_String{k}}
}
func (ma *_SignedHeader__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SignedHeader__ReprKeyAssembler)(ma)
}
func (ma *_SignedHeader__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header
	case 1:
		ma.ca_Commit.w = &ma.w.Commit
		ma.ca_Commit.m = &ma.cm
		return &ma.ca_Commit
	default:
		panic("unreachable")
	}
}
func (ma *_SignedHeader__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SignedHeader_sufficient != fieldBits__SignedHeader_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__SignedHeader_Header == 0 {
			err.Missing = append(err.Missing, "Header")
		}
		if ma.s&fieldBit__SignedHeader_Commit == 0 {
			err.Missing = append(err.Missing, "Commit")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SignedHeader__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SignedHeader__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _SignedHeader__ReprKeyAssembler _SignedHeader__ReprAssembler

func (_SignedHeader__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.BeginMap(0)
}
func (_SignedHeader__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_SignedHeader__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignNull()
}
func (_SignedHeader__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignBool(false)
}
func (_SignedHeader__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignInt(0)
}
func (_SignedHeader__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SignedHeader__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Header":
		if ka.s&fieldBit__SignedHeader_Header != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Header_serial}
		}
		ka.s += fieldBit__SignedHeader_Header
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Commit":
		if ka.s&fieldBit__SignedHeader_Commit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Commit_serial}
		}
		ka.s += fieldBit__SignedHeader_Commit
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.SignedHeader.Repr", Key: &_String{k}}
}
func (_SignedHeader__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_SignedHeader__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SignedHeader__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SignedHeader__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n SignedMsgType) Int() int64 {
	return n.x
}
func (_SignedMsgType__Prototype) FromInt(v int64) (SignedMsgType, error) {
	n := _SignedMsgType{v}
	return &n, nil
}

type _SignedMsgType__Maybe struct {
	m schema.Maybe
	v SignedMsgType
}
type MaybeSignedMsgType = *_SignedMsgType__Maybe

func (m MaybeSignedMsgType) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSignedMsgType) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSignedMsgType) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSignedMsgType) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSignedMsgType) Must() SignedMsgType {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (SignedMsgType)(&_SignedMsgType{})
var _ schema.TypedNode = (SignedMsgType)(&_SignedMsgType{})

func (SignedMsgType) Kind() ipld.Kind {
	return ipld.Kind_Int
}
func (SignedMsgType) LookupByString(string) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.LookupByString("")
}
func (SignedMsgType) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.LookupByNode(nil)
}
func (SignedMsgType) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.LookupByIndex(0)
}
func (SignedMsgType) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.LookupBySegment(seg)
}
func (SignedMsgType) MapIterator() ipld.MapIterator {
	return nil
}
func (SignedMsgType) ListIterator() ipld.ListIterator {
	return nil
}
func (SignedMsgType) Length() int64 {
	return -1
}
func (SignedMsgType) IsAbsent() bool {
	return false
}
func (SignedMsgType) IsNull() bool {
	return false
}
func (SignedMsgType) AsBool() (bool, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.AsBool()
}
func (n SignedMsgType) AsInt() (int64, error) {
	return n.x, nil
}
func (SignedMsgType) AsFloat() (float64, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.AsFloat()
}
func (SignedMsgType) AsString() (string, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.AsString()
}
func (SignedMsgType) AsBytes() ([]byte, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.AsBytes()
}
func (SignedMsgType) AsLink() (ipld.Link, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.AsLink()
}
func (SignedMsgType) Prototype() ipld.NodePrototype {
	return _SignedMsgType__Prototype{}
}

type _SignedMsgType__Prototype struct{}

func (_SignedMsgType__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _SignedMsgType__Builder
	nb.Reset()
	return &nb
}

type _SignedMsgType__Builder struct {
	_SignedMsgType__Assembler
}

func (nb *_SignedMsgType__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SignedMsgType__Builder) Reset() {
	var w _SignedMsgType
	var m schema.Maybe
	*nb = _SignedMsgType__Builder{_SignedMsgType__Assembler{w: &w, m: &m}}
}

type _SignedMsgType__Assembler struct {
	w *_SignedMsgType
	m *schema.Maybe
}

func (na *_SignedMsgType__Assembler) reset() {}
func (_SignedMsgType__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.BeginMap(0)
}
func (_SignedMsgType__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.BeginList(0)
}
func (na *_SignedMsgType__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_SignedMsgType__Assembler) AssignBool(bool) error {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignBool(false)
}
func (na *_SignedMsgType__Assembler) AssignInt(v int64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_SignedMsgType{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_SignedMsgType__Assembler) AssignFloat(float64) error {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignFloat(0)
}
func (_SignedMsgType__Assembler) AssignString(string) error {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignString("")
}
func (_SignedMsgType__Assembler) AssignBytes([]byte) error {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignBytes(nil)
}
func (_SignedMsgType__Assembler) AssignLink(ipld.Link) error {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignLink(nil)
}
func (na *_SignedMsgType__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SignedMsgType); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsInt(); err != nil {
		return err
	} else {
		return na.AssignInt(v2)
	}
}
func (_SignedMsgType__Assembler) Prototype() ipld.NodePrototype {
	return _SignedMsgType__Prototype{}
}
func (SignedMsgType) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n SignedMsgType) Representation() ipld.Node {
	return (*_SignedMsgType__Repr)(n)
}

type _SignedMsgType__Repr = _SignedMsgType

var _ ipld.Node = &_SignedMsgType__Repr{}

type _SignedMsgType__ReprPrototype = _SignedMsgType__Prototype
type _SignedMsgType__ReprAssembler = _SignedMsgType__Assembler

func (n _SimpleValidator) FieldPubKey() PubKey {
	return &n.PubKey
}
func (n _SimpleValidator) FieldVotingPower() Int {
	return &n.VotingPower
}

type _SimpleValidator__Maybe struct {
	m schema.Maybe
	v SimpleValidator
}
type MaybeSimpleValidator = *_SimpleValidator__Maybe

func (m MaybeSimpleValidator) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSimpleValidator) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSimpleValidator) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSimpleValidator) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSimpleValidator) Must() SimpleValidator {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__SimpleValidator_PubKey      = _String{"PubKey"}
	fieldName__SimpleValidator_VotingPower = _String{"VotingPower"}
)
var _ ipld.Node = (SimpleValidator)(&_SimpleValidator{})
var _ schema.TypedNode = (SimpleValidator)(&_SimpleValidator{})

func (SimpleValidator) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n SimpleValidator) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PubKey":
		return &n.PubKey, nil
	case "VotingPower":
		return &n.VotingPower, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n SimpleValidator) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (SimpleValidator) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.LookupByIndex(0)
}
func (n SimpleValidator) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n SimpleValidator) MapIterator() ipld.MapIterator {
	return &_SimpleValidator__MapItr{n, 0}
}

type _SimpleValidator__MapItr struct {
	n   SimpleValidator
	idx int
}

func (itr *_SimpleValidator__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SimpleValidator_PubKey
		v = &itr.n.PubKey
	case 1:
		k = &fieldName__SimpleValidator_VotingPower
		v = &itr.n.VotingPower
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SimpleValidator__MapItr) Done() bool {
	return itr.idx >= 2
}

func (SimpleValidator) ListIterator() ipld.ListIterator {
	return nil
}
func (SimpleValidator) Length() int64 {
	return 2
}
func (SimpleValidator) IsAbsent() bool {
	return false
}
func (SimpleValidator) IsNull() bool {
	return false
}
func (SimpleValidator) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsBool()
}
func (SimpleValidator) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsInt()
}
func (SimpleValidator) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsFloat()
}
func (SimpleValidator) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsString()
}
func (SimpleValidator) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsBytes()
}
func (SimpleValidator) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsLink()
}
func (SimpleValidator) Prototype() ipld.NodePrototype {
	return _SimpleValidator__Prototype{}
}

type _SimpleValidator__Prototype struct{}

func (_SimpleValidator__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _SimpleValidator__Builder
	nb.Reset()
	return &nb
}

type _SimpleValidator__Builder struct {
	_SimpleValidator__Assembler
}

func (nb *_SimpleValidator__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SimpleValidator__Builder) Reset() {
	var w _SimpleValidator
	var m schema.Maybe
	*nb = _SimpleValidator__Builder{_SimpleValidator__Assembler{w: &w, m: &m}}
}

type _SimpleValidator__Assembler struct {
	w     *_SimpleValidator
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PubKey      _PubKey__Assembler
	ca_VotingPower _Int__Assembler
}

func (na *_SimpleValidator__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PubKey.reset()
	na.ca_VotingPower.reset()
}

var (
	fieldBit__SimpleValidator_PubKey      = 1 << 0
	fieldBit__SimpleValidator_VotingPower = 1 << 1
	fieldBits__SimpleValidator_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_SimpleValidator__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SimpleValidator{}
	}
	return na, nil
}
func (_SimpleValidator__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.BeginList(0)
}
func (na *_SimpleValidator__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SimpleValidator__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignBool(false)
}
func (_SimpleValidator__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignInt(0)
}
func (_SimpleValidator__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignFloat(0)
}
func (_SimpleValidator__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignString("")
}
func (_SimpleValidator__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignBytes(nil)
}
func (_SimpleValidator__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignLink(nil)
}
func (na *_SimpleValidator__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SimpleValidator); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SimpleValidator", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SimpleValidator__Assembler) Prototype() ipld.NodePrototype {
	return _SimpleValidator__Prototype{}
}
func (ma *_SimpleValidator__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PubKey.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_VotingPower.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SimpleValidator__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PubKey":
		if ma.s&fieldBit__SimpleValidator_PubKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_PubKey}
		}
		ma.s += fieldBit__SimpleValidator_PubKey
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey, nil
	case "VotingPower":
		if ma.s&fieldBit__SimpleValidator_VotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_VotingPower}
		}
		ma.s += fieldBit__SimpleValidator_VotingPower
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SimpleValidator", Key: &_String{k}}
}
func (ma *_SimpleValidator__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SimpleValidator__KeyAssembler)(ma)
}
func (ma *_SimpleValidator__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey
	case 1:
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower
	default:
		panic("unreachable")
	}
}
func (ma *_SimpleValidator__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SimpleValidator_sufficient != fieldBits__SimpleValidator_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__SimpleValidator_PubKey == 0 {
			err.Missing = append(err.Missing, "PubKey")
		}
		if ma.s&fieldBit__SimpleValidator_VotingPower == 0 {
			err.Missing = append(err.Missing, "VotingPower")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SimpleValidator__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SimpleValidator__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _SimpleValidator__KeyAssembler _SimpleValidator__Assembler

func (_SimpleValidator__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.BeginMap(0)
}
func (_SimpleValidator__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.BeginList(0)
}
func (na *_SimpleValidator__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignNull()
}
func (_SimpleValidator__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignBool(false)
}
func (_SimpleValidator__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignInt(0)
}
func (_SimpleValidator__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SimpleValidator__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PubKey":
		if ka.s&fieldBit__SimpleValidator_PubKey != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_PubKey}
		}
		ka.s += fieldBit__SimpleValidator_PubKey
		ka.state = maState_expectValue
		ka.f = 0
	case "VotingPower":
		if ka.s&fieldBit__SimpleValidator_VotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_VotingPower}
		}
		ka.s += fieldBit__SimpleValidator_VotingPower
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.SimpleValidator", Key: &_String{k}}
	}
	return nil
}
func (_SimpleValidator__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignBytes(nil)
}
func (_SimpleValidator__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SimpleValidator__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SimpleValidator__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (SimpleValidator) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n SimpleValidator) Representation() ipld.Node {
	return (*_SimpleValidator__Repr)(n)
}

type _SimpleValidator__Repr _SimpleValidator

var (
	fieldName__SimpleValidator_PubKey_serial      = _String{"PubKey"}
	fieldName__SimpleValidator_VotingPower_serial = _String{"VotingPower"}
)
var _ ipld.Node = &_SimpleValidator__Repr{}

func (_SimpleValidator__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_SimpleValidator__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PubKey":
		return n.PubKey.Representation(), nil
	case "VotingPower":
		return n.VotingPower.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_SimpleValidator__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_SimpleValidator__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.LookupByIndex(0)
}
func (n _SimpleValidator__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_SimpleValidator__Repr) MapIterator() ipld.MapIterator {
	return &_SimpleValidator__ReprMapItr{n, 0}
}

type _SimpleValidator__ReprMapItr struct {
	n   *_SimpleValidator__Repr
	idx int
}

func (itr *_SimpleValidator__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SimpleValidator_PubKey_serial
		v = itr.n.PubKey.Representation()
	case 1:
		k = &fieldName__SimpleValidator_VotingPower_serial
		v = itr.n.VotingPower.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SimpleValidator__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_SimpleValidator__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_SimpleValidator__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_SimpleValidator__Repr) IsAbsent() bool {
	return false
}
func (_SimpleValidator__Repr) IsNull() bool {
	return false
}
func (_SimpleValidator__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsBool()
}
func (_SimpleValidator__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsInt()
}
func (_SimpleValidator__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsFloat()
}
func (_SimpleValidator__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsString()
}
func (_SimpleValidator__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsBytes()
}
func (_SimpleValidator__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsLink()
}
func (_SimpleValidator__Repr) Prototype() ipld.NodePrototype {
	return _SimpleValidator__ReprPrototype{}
}

type _SimpleValidator__ReprPrototype struct{}

func (_SimpleValidator__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _SimpleValidator__ReprBuilder
	nb.Reset()
	return &nb
}

type _SimpleValidator__ReprBuilder struct {
	_SimpleValidator__ReprAssembler
}

func (nb *_SimpleValidator__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SimpleValidator__ReprBuilder) Reset() {
	var w _SimpleValidator
	var m schema.Maybe
	*nb = _SimpleValidator__ReprBuilder{_SimpleValidator__ReprAssembler{w: &w, m: &m}}
}

type _SimpleValidator__ReprAssembler struct {
	w     *_SimpleValidator
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PubKey      _PubKey__ReprAssembler
	ca_VotingPower _Int__ReprAssembler
}

func (na *_SimpleValidator__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PubKey.reset()
	na.ca_VotingPower.reset()
}
func (na *_SimpleValidator__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SimpleValidator{}
	}
	return na, nil
}
func (_SimpleValidator__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.BeginList(0)
}
func (na *_SimpleValidator__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SimpleValidator__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignBool(false)
}
func (_SimpleValidator__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignInt(0)
}
func (_SimpleValidator__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignFloat(0)
}
func (_SimpleValidator__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignString("")
}
func (_SimpleValidator__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignBytes(nil)
}
func (_SimpleValidator__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignLink(nil)
}
func (na *_SimpleValidator__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SimpleValidator); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SimpleValidator.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SimpleValidator__ReprAssembler) Prototype() ipld.NodePrototype {
	return _SimpleValidator__ReprPrototype{}
}
func (ma *_SimpleValidator__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SimpleValidator__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PubKey":
		if ma.s&fieldBit__SimpleValidator_PubKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_PubKey_serial}
		}
		ma.s += fieldBit__SimpleValidator_PubKey
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey, nil
	case "VotingPower":
		if ma.s&fieldBit__SimpleValidator_VotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_VotingPower_serial}
		}
		ma.s += fieldBit__SimpleValidator_VotingPower
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SimpleValidator.Repr", Key: &_String{k}}
}
func (ma *_SimpleValidator__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SimpleValidator__ReprKeyAssembler)(ma)
}
func (ma *_SimpleValidator__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey
	case 1:
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower
	default:
		panic("unreachable")
	}
}
func (ma *_SimpleValidator__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SimpleValidator_sufficient != fieldBits__SimpleValidator_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__SimpleValidator_PubKey == 0 {
			err.Missing = append(err.Missing, "PubKey")
		}
		if ma.s&fieldBit__SimpleValidator_VotingPower == 0 {
			err.Missing = append(err.Missing, "VotingPower")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SimpleValidator__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SimpleValidator__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _SimpleValidator__ReprKeyAssembler _SimpleValidator__ReprAssembler

func (_SimpleValidator__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.BeginMap(0)
}
func (_SimpleValidator__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_SimpleValidator__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignNull()
}
func (_SimpleValidator__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignBool(false)
}
func (_SimpleValidator__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignInt(0)
}
func (_SimpleValidator__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SimpleValidator__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PubKey":
		if ka.s&fieldBit__SimpleValidator_PubKey != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_PubKey_serial}
		}
		ka.s += fieldBit__SimpleValidator_PubKey
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "VotingPower":
		if ka.s&fieldBit__SimpleValidator_VotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_VotingPower_serial}
		}
		ka.s += fieldBit__SimpleValidator_VotingPower
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.SimpleValidator.Repr", Key: &_String{k}}
}
func (_SimpleValidator__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_SimpleValidator__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SimpleValidator__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SimpleValidator__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n String) String() string {
	return n.x
}
func (_String__Prototype) fromString(w *_String, v string) error {
	*w = _String{v}
	return nil
}
func (_String__Prototype) FromString(v string) (String, error) {
	n := _String{v}
	return &n, nil
}

type _String__Maybe struct {
	m schema.Maybe
	v String
}
type MaybeString = *_String__Maybe

func (m MaybeString) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeString) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeString) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeString) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeString) Must() String {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (String)(&_String{})
var _ schema.TypedNode = (String)(&_String{})

func (String) Kind() ipld.Kind {
	return ipld.Kind_String
}
func (String) LookupByString(string) (ipld.Node, error) {
	return mixins.String{"dagcosmos.String"}.LookupByString("")
}
func (String) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.String{"dagcosmos.String"}.LookupByNode(nil)
}
func (String) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.String{"dagcosmos.String"}.LookupByIndex(0)
}
func (String) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.String{"dagcosmos.String"}.LookupBySegment(seg)
}
func (String) MapIterator() ipld.MapIterator {
	return nil
}
func (String) ListIterator() ipld.ListIterator {
	return nil
}
func (String) Length() int64 {
	return -1
}
func (String) IsAbsent() bool {
	return false
}
func (String) IsNull() bool {
	return false
}
func (String) AsBool() (bool, error) {
	return mixins.String{"dagcosmos.String"}.AsBool()
}
func (String) AsInt() (int64, error) {
	return mixins.String{"dagcosmos.String"}.AsInt()
}
func (String) AsFloat() (float64, error) {
	return mixins.String{"dagcosmos.String"}.AsFloat()
}
func (n String) AsString() (string, error) {
	return n.x, nil
}
func (String) AsBytes() ([]byte, error) {
	return mixins.String{"dagcosmos.String"}.AsBytes()
}
func (String) AsLink() (ipld.Link, error) {
	return mixins.String{"dagcosmos.String"}.AsLink()
}
func (String) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

type _String__Prototype struct{}

func (_String__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _String__Builder
	nb.Reset()
	return &nb
}

type _String__Builder struct {
	_String__Assembler
}

func (nb *_String__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_String__Builder) Reset() {
	var w _String
	var m schema.Maybe
	*nb = _String__Builder{_String__Assembler{w: &w, m: &m}}
}

type _String__Assembler struct {
	w *_String
	m *schema.Maybe
}

func (na *_String__Assembler) reset() {}
func (_String__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.String"}.BeginMap(0)
}
func (_String__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.String"}.BeginList(0)
}
func (na *_String__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.StringAssembler{"dagcosmos.String"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_String__Assembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.String"}.AssignBool(false)
}
func (_String__Assembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.String"}.AssignInt(0)
}
func (_String__Assembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.String"}.AssignFloat(0)
}
func (na *_String__Assembler) AssignString(v string) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_String{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_String__Assembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.String"}.AssignBytes(nil)
}
func (_String__Assembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.String"}.AssignLink(nil)
}
func (na *_String__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_String); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return na.AssignString(v2)
	}
}
func (_String__Assembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (String) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n String) Representation() ipld.Node {
	return (*_String__Repr)(n)
}

type _String__Repr = _String

var _ ipld.Node = &_String__Repr{}

type _String__ReprPrototype = _String__Prototype
type _String__ReprAssembler = _String__Assembler

func (n _Time) FieldSeconds() Int {
	return &n.Seconds
}
func (n _Time) FieldNanoseconds() Int {
	return &n.Nanoseconds
}

type _Time__Maybe struct {
	m schema.Maybe
	v Time
}
type MaybeTime = *_Time__Maybe

func (m MaybeTime) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTime) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTime) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTime) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTime) Must() Time {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Time_Seconds     = _String{"Seconds"}
	fieldName__Time_Nanoseconds = _String{"Nanoseconds"}
)
var _ ipld.Node = (Time)(&_Time{})
var _ schema.TypedNode = (Time)(&_Time{})

func (Time) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Time) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Seconds":
		return &n.Seconds, nil
	case "Nanoseconds":
		return &n.Nanoseconds, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Time) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Time) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Time"}.LookupByIndex(0)
}
func (n Time) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Time) MapIterator() ipld.MapIterator {
	return &_Time__MapItr{n, 0}
}

type _Time__MapItr struct {
	n   Time
	idx int
}

func (itr *_Time__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Time_Seconds
		v = &itr.n.Seconds
	case 1:
		k = &fieldName__Time_Nanoseconds
		v = &itr.n.Nanoseconds
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Time__MapItr) Done() bool {
	return itr.idx >= 2
}

func (Time) ListIterator() ipld.ListIterator {
	return nil
}
func (Time) Length() int64 {
	return 2
}
func (Time) IsAbsent() bool {
	return false
}
func (Time) IsNull() bool {
	return false
}
func (Time) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Time"}.AsBool()
}
func (Time) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Time"}.AsInt()
}
func (Time) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Time"}.AsFloat()
}
func (Time) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Time"}.AsString()
}
func (Time) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Time"}.AsBytes()
}
func (Time) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Time"}.AsLink()
}
func (Time) Prototype() ipld.NodePrototype {
	return _Time__Prototype{}
}

type _Time__Prototype struct{}

func (_Time__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Time__Builder
	nb.Reset()
	return &nb
}

type _Time__Builder struct {
	_Time__Assembler
}

func (nb *_Time__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Time__Builder) Reset() {
	var w _Time
	var m schema.Maybe
	*nb = _Time__Builder{_Time__Assembler{w: &w, m: &m}}
}

type _Time__Assembler struct {
	w     *_Time
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_Seconds     _Int__Assembler
	ca_Nanoseconds _Int__Assembler
}

func (na *_Time__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Seconds.reset()
	na.ca_Nanoseconds.reset()
}

var (
	fieldBit__Time_Seconds     = 1 << 0
	fieldBit__Time_Nanoseconds = 1 << 1
	fieldBits__Time_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_Time__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Time{}
	}
	return na, nil
}
func (_Time__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Time"}.BeginList(0)
}
func (na *_Time__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Time"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Time__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignBool(false)
}
func (_Time__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignInt(0)
}
func (_Time__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignFloat(0)
}
func (_Time__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignString("")
}
func (_Time__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignBytes(nil)
}
func (_Time__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignLink(nil)
}
func (na *_Time__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Time); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Time", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Time__Assembler) Prototype() ipld.NodePrototype {
	return _Time__Prototype{}
}
func (ma *_Time__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Seconds.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Nanoseconds.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Time__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Seconds":
		if ma.s&fieldBit__Time_Seconds != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Seconds}
		}
		ma.s += fieldBit__Time_Seconds
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Seconds.w = &ma.w.Seconds
		ma.ca_Seconds.m = &ma.cm
		return &ma.ca_Seconds, nil
	case "Nanoseconds":
		if ma.s&fieldBit__Time_Nanoseconds != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Nanoseconds}
		}
		ma.s += fieldBit__Time_Nanoseconds
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Nanoseconds.w = &ma.w.Nanoseconds
		ma.ca_Nanoseconds.m = &ma.cm
		return &ma.ca_Nanoseconds, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Time", Key: &_String{k}}
}
func (ma *_Time__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Time__KeyAssembler)(ma)
}
func (ma *_Time__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Seconds.w = &ma.w.Seconds
		ma.ca_Seconds.m = &ma.cm
		return &ma.ca_Seconds
	case 1:
		ma.ca_Nanoseconds.w = &ma.w.Nanoseconds
		ma.ca_Nanoseconds.m = &ma.cm
		return &ma.ca_Nanoseconds
	default:
		panic("unreachable")
	}
}
func (ma *_Time__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Time_sufficient != fieldBits__Time_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Time_Seconds == 0 {
			err.Missing = append(err.Missing, "Seconds")
		}
		if ma.s&fieldBit__Time_Nanoseconds == 0 {
			err.Missing = append(err.Missing, "Nanoseconds")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Time__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Time__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Time__KeyAssembler _Time__Assembler

func (_Time__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.BeginMap(0)
}
func (_Time__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.BeginList(0)
}
func (na *_Time__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignNull()
}
func (_Time__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignBool(false)
}
func (_Time__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignInt(0)
}
func (_Time__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Time__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Seconds":
		if ka.s&fieldBit__Time_Seconds != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Seconds}
		}
		ka.s += fieldBit__Time_Seconds
		ka.state = maState_expectValue
		ka.f = 0
	case "Nanoseconds":
		if ka.s&fieldBit__Time_Nanoseconds != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Nanoseconds}
		}
		ka.s += fieldBit__Time_Nanoseconds
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Time", Key: &_String{k}}
	}
	return nil
}
func (_Time__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignBytes(nil)
}
func (_Time__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Time__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Time__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Time) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Time) Representation() ipld.Node {
	return (*_Time__Repr)(n)
}

type _Time__Repr _Time

var (
	fieldName__Time_Seconds_serial     = _String{"Seconds"}
	fieldName__Time_Nanoseconds_serial = _String{"Nanoseconds"}
)
var _ ipld.Node = &_Time__Repr{}

func (_Time__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Time__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Seconds":
		return n.Seconds.Representation(), nil
	case "Nanoseconds":
		return n.Nanoseconds.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Time__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Time__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.LookupByIndex(0)
}
func (n _Time__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Time__Repr) MapIterator() ipld.MapIterator {
	return &_Time__ReprMapItr{n, 0}
}

type _Time__ReprMapItr struct {
	n   *_Time__Repr
	idx int
}

func (itr *_Time__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Time_Seconds_serial
		v = itr.n.Seconds.Representation()
	case 1:
		k = &fieldName__Time_Nanoseconds_serial
		v = itr.n.Nanoseconds.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Time__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_Time__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Time__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_Time__Repr) IsAbsent() bool {
	return false
}
func (_Time__Repr) IsNull() bool {
	return false
}
func (_Time__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsBool()
}
func (_Time__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsInt()
}
func (_Time__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsFloat()
}
func (_Time__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsString()
}
func (_Time__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsBytes()
}
func (_Time__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsLink()
}
func (_Time__Repr) Prototype() ipld.NodePrototype {
	return _Time__ReprPrototype{}
}

type _Time__ReprPrototype struct{}

func (_Time__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Time__ReprBuilder
	nb.Reset()
	return &nb
}

type _Time__ReprBuilder struct {
	_Time__ReprAssembler
}

func (nb *_Time__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Time__ReprBuilder) Reset() {
	var w _Time
	var m schema.Maybe
	*nb = _Time__ReprBuilder{_Time__ReprAssembler{w: &w, m: &m}}
}

type _Time__ReprAssembler struct {
	w     *_Time
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_Seconds     _Int__ReprAssembler
	ca_Nanoseconds _Int__ReprAssembler
}

func (na *_Time__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Seconds.reset()
	na.ca_Nanoseconds.reset()
}
func (na *_Time__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Time{}
	}
	return na, nil
}
func (_Time__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.BeginList(0)
}
func (na *_Time__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Time.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Time__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignBool(false)
}
func (_Time__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignInt(0)
}
func (_Time__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignFloat(0)
}
func (_Time__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignString("")
}
func (_Time__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignBytes(nil)
}
func (_Time__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignLink(nil)
}
func (na *_Time__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Time); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Time.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Time__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Time__ReprPrototype{}
}
func (ma *_Time__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Time__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Seconds":
		if ma.s&fieldBit__Time_Seconds != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Seconds_serial}
		}
		ma.s += fieldBit__Time_Seconds
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Seconds.w = &ma.w.Seconds
		ma.ca_Seconds.m = &ma.cm
		return &ma.ca_Seconds, nil
	case "Nanoseconds":
		if ma.s&fieldBit__Time_Nanoseconds != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Nanoseconds_serial}
		}
		ma.s += fieldBit__Time_Nanoseconds
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Nanoseconds.w = &ma.w.Nanoseconds
		ma.ca_Nanoseconds.m = &ma.cm
		return &ma.ca_Nanoseconds, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Time.Repr", Key: &_String{k}}
}
func (ma *_Time__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Time__ReprKeyAssembler)(ma)
}
func (ma *_Time__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Seconds.w = &ma.w.Seconds
		ma.ca_Seconds.m = &ma.cm
		return &ma.ca_Seconds
	case 1:
		ma.ca_Nanoseconds.w = &ma.w.Nanoseconds
		ma.ca_Nanoseconds.m = &ma.cm
		return &ma.ca_Nanoseconds
	default:
		panic("unreachable")
	}
}
func (ma *_Time__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Time_sufficient != fieldBits__Time_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Time_Seconds == 0 {
			err.Missing = append(err.Missing, "Seconds")
		}
		if ma.s&fieldBit__Time_Nanoseconds == 0 {
			err.Missing = append(err.Missing, "Nanoseconds")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Time__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Time__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Time__ReprKeyAssembler _Time__ReprAssembler

func (_Time__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Time__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Time__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignNull()
}
func (_Time__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Time__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Time__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Time__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Seconds":
		if ka.s&fieldBit__Time_Seconds != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Seconds_serial}
		}
		ka.s += fieldBit__Time_Seconds
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Nanoseconds":
		if ka.s&fieldBit__Time_Nanoseconds != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Nanoseconds_serial}
		}
		ka.s += fieldBit__Time_Nanoseconds
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Time.Repr", Key: &_String{k}}
}
func (_Time__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Time__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Time__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Time__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_Tx) Lookup(idx int64) Bytes {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Tx) LookupMaybe(idx int64) MaybeBytes {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Bytes__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Tx__valueAbsent = _Bytes__Maybe{m: schema.Maybe_Absent}

func (n Tx) Iterator() *Tx__Itr {
	return &Tx__Itr{n, 0}
}

type Tx__Itr struct {
	n   Tx
	idx int
}

func (itr *Tx__Itr) Next() (idx int64, v Bytes) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Tx__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Tx__Maybe struct {
	m schema.Maybe
	v Tx
}
type MaybeTx = *_Tx__Maybe

func (m MaybeTx) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTx) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTx) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTx) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTx) Must() Tx {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Tx)(&_Tx{})
var _ schema.TypedNode = (Tx)(&_Tx{})

func (Tx) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Tx) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Tx"}.LookupByString("")
}
func (n Tx) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Tx) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Tx) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Tx", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Tx) MapIterator() ipld.MapIterator {
	return nil
}
func (n Tx) ListIterator() ipld.ListIterator {
	return &_Tx__ListItr{n, 0}
}

type _Tx__ListItr struct {
	n   Tx
	idx int
}

func (itr *_Tx__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Tx__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Tx) Length() int64 {
	return int64(len(n.x))
}
func (Tx) IsAbsent() bool {
	return false
}
func (Tx) IsNull() bool {
	return false
}
func (Tx) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Tx"}.AsBool()
}
func (Tx) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Tx"}.AsInt()
}
func (Tx) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Tx"}.AsFloat()
}
func (Tx) AsString() (string, error) {
	return mixins.List{"dagcosmos.Tx"}.AsString()
}
func (Tx) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Tx"}.AsBytes()
}
func (Tx) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Tx"}.AsLink()
}
func (Tx) Prototype() ipld.NodePrototype {
	return _Tx__Prototype{}
}

type _Tx__Prototype struct{}

func (_Tx__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Tx__Builder
	nb.Reset()
	return &nb
}

type _Tx__Builder struct {
	_Tx__Assembler
}

func (nb *_Tx__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Tx__Builder) Reset() {
	var w _Tx
	var m schema.Maybe
	*nb = _Tx__Builder{_Tx__Assembler{w: &w, m: &m}}
}

type _Tx__Assembler struct {
	w     *_Tx
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Bytes__Assembler
}

func (na *_Tx__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Tx__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Tx"}.BeginMap(0)
}
func (na *_Tx__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Tx{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Bytes, 0, sizeHint)
	}
	return na, nil
}
func (na *_Tx__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Tx"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Tx__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignBool(false)
}
func (_Tx__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignInt(0)
}
func (_Tx__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignFloat(0)
}
func (_Tx__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignString("")
}
func (_Tx__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignBytes(nil)
}
func (_Tx__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignLink(nil)
}
func (na *_Tx__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Tx); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Tx", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Tx__Assembler) Prototype() ipld.NodePrototype {
	return _Tx__Prototype{}
}
func (la *_Tx__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Tx__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Bytes{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Tx__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Tx__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Bytes__Prototype{}
}
func (Tx) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Tx) Representation() ipld.Node {
	return (*_Tx__Repr)(n)
}

type _Tx__Repr _Tx

var _ ipld.Node = &_Tx__Repr{}

func (_Tx__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Tx__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.LookupByString("")
}
func (nr *_Tx__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Tx)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Bytes).Representation(), nil
}
func (nr *_Tx__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Tx)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Bytes).Representation(), nil
}
func (n _Tx__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Tx.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Tx__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Tx__Repr) ListIterator() ipld.ListIterator {
	return &_Tx__ReprListItr{(Tx)(nr), 0}
}

type _Tx__ReprListItr _Tx__ListItr

func (itr *_Tx__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Tx__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Bytes).Representation(), nil
}
func (itr *_Tx__ReprListItr) Done() bool {
	return (*_Tx__ListItr)(itr).Done()
}

func (rn *_Tx__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Tx__Repr) IsAbsent() bool {
	return false
}
func (_Tx__Repr) IsNull() bool {
	return false
}
func (_Tx__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsBool()
}
func (_Tx__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsInt()
}
func (_Tx__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsFloat()
}
func (_Tx__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsString()
}
func (_Tx__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsBytes()
}
func (_Tx__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsLink()
}
func (_Tx__Repr) Prototype() ipld.NodePrototype {
	return _Tx__ReprPrototype{}
}

type _Tx__ReprPrototype struct{}

func (_Tx__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Tx__ReprBuilder
	nb.Reset()
	return &nb
}

type _Tx__ReprBuilder struct {
	_Tx__ReprAssembler
}

func (nb *_Tx__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Tx__ReprBuilder) Reset() {
	var w _Tx
	var m schema.Maybe
	*nb = _Tx__ReprBuilder{_Tx__ReprAssembler{w: &w, m: &m}}
}

type _Tx__ReprAssembler struct {
	w     *_Tx
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Bytes__ReprAssembler
}

func (na *_Tx__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Tx__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.BeginMap(0)
}
func (na *_Tx__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Tx{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Bytes, 0, sizeHint)
	}
	return na, nil
}
func (na *_Tx__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Tx.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Tx__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignBool(false)
}
func (_Tx__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignInt(0)
}
func (_Tx__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignFloat(0)
}
func (_Tx__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignString("")
}
func (_Tx__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignBytes(nil)
}
func (_Tx__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignLink(nil)
}
func (na *_Tx__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Tx); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Tx.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Tx__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Tx__ReprPrototype{}
}
func (la *_Tx__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Tx__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Bytes{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Tx__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Tx__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Bytes__ReprPrototype{}
}

func (n *_Txs) Lookup(idx int64) Tx {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Txs) LookupMaybe(idx int64) MaybeTx {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Tx__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Txs__valueAbsent = _Tx__Maybe{m: schema.Maybe_Absent}

func (n Txs) Iterator() *Txs__Itr {
	return &Txs__Itr{n, 0}
}

type Txs__Itr struct {
	n   Txs
	idx int
}

func (itr *Txs__Itr) Next() (idx int64, v Tx) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Txs__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Txs__Maybe struct {
	m schema.Maybe
	v Txs
}
type MaybeTxs = *_Txs__Maybe

func (m MaybeTxs) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTxs) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTxs) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTxs) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTxs) Must() Txs {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Txs)(&_Txs{})
var _ schema.TypedNode = (Txs)(&_Txs{})

func (Txs) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Txs) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Txs"}.LookupByString("")
}
func (n Txs) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Txs) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Txs) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Txs", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Txs) MapIterator() ipld.MapIterator {
	return nil
}
func (n Txs) ListIterator() ipld.ListIterator {
	return &_Txs__ListItr{n, 0}
}

type _Txs__ListItr struct {
	n   Txs
	idx int
}

func (itr *_Txs__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Txs__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Txs) Length() int64 {
	return int64(len(n.x))
}
func (Txs) IsAbsent() bool {
	return false
}
func (Txs) IsNull() bool {
	return false
}
func (Txs) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Txs"}.AsBool()
}
func (Txs) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Txs"}.AsInt()
}
func (Txs) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Txs"}.AsFloat()
}
func (Txs) AsString() (string, error) {
	return mixins.List{"dagcosmos.Txs"}.AsString()
}
func (Txs) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Txs"}.AsBytes()
}
func (Txs) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Txs"}.AsLink()
}
func (Txs) Prototype() ipld.NodePrototype {
	return _Txs__Prototype{}
}

type _Txs__Prototype struct{}

func (_Txs__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Txs__Builder
	nb.Reset()
	return &nb
}

type _Txs__Builder struct {
	_Txs__Assembler
}

func (nb *_Txs__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Txs__Builder) Reset() {
	var w _Txs
	var m schema.Maybe
	*nb = _Txs__Builder{_Txs__Assembler{w: &w, m: &m}}
}

type _Txs__Assembler struct {
	w     *_Txs
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Tx__Assembler
}

func (na *_Txs__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Txs__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Txs"}.BeginMap(0)
}
func (na *_Txs__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Txs{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Tx, 0, sizeHint)
	}
	return na, nil
}
func (na *_Txs__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Txs"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Txs__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignBool(false)
}
func (_Txs__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignInt(0)
}
func (_Txs__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignFloat(0)
}
func (_Txs__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignString("")
}
func (_Txs__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignBytes(nil)
}
func (_Txs__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignLink(nil)
}
func (na *_Txs__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Txs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Txs", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Txs__Assembler) Prototype() ipld.NodePrototype {
	return _Txs__Prototype{}
}
func (la *_Txs__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Txs__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Tx{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Txs__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Txs__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Tx__Prototype{}
}
func (Txs) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Txs) Representation() ipld.Node {
	return (*_Txs__Repr)(n)
}

type _Txs__Repr _Txs

var _ ipld.Node = &_Txs__Repr{}

func (_Txs__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Txs__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.LookupByString("")
}
func (nr *_Txs__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Txs)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Tx).Representation(), nil
}
func (nr *_Txs__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Txs)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Tx).Representation(), nil
}
func (n _Txs__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Txs.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Txs__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Txs__Repr) ListIterator() ipld.ListIterator {
	return &_Txs__ReprListItr{(Txs)(nr), 0}
}

type _Txs__ReprListItr _Txs__ListItr

func (itr *_Txs__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Txs__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Tx).Representation(), nil
}
func (itr *_Txs__ReprListItr) Done() bool {
	return (*_Txs__ListItr)(itr).Done()
}

func (rn *_Txs__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Txs__Repr) IsAbsent() bool {
	return false
}
func (_Txs__Repr) IsNull() bool {
	return false
}
func (_Txs__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsBool()
}
func (_Txs__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsInt()
}
func (_Txs__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsFloat()
}
func (_Txs__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsString()
}
func (_Txs__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsBytes()
}
func (_Txs__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsLink()
}
func (_Txs__Repr) Prototype() ipld.NodePrototype {
	return _Txs__ReprPrototype{}
}

type _Txs__ReprPrototype struct{}

func (_Txs__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Txs__ReprBuilder
	nb.Reset()
	return &nb
}

type _Txs__ReprBuilder struct {
	_Txs__ReprAssembler
}

func (nb *_Txs__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Txs__ReprBuilder) Reset() {
	var w _Txs
	var m schema.Maybe
	*nb = _Txs__ReprBuilder{_Txs__ReprAssembler{w: &w, m: &m}}
}

type _Txs__ReprAssembler struct {
	w     *_Txs
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Tx__ReprAssembler
}

func (na *_Txs__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Txs__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.BeginMap(0)
}
func (na *_Txs__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Txs{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Tx, 0, sizeHint)
	}
	return na, nil
}
func (na *_Txs__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Txs.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Txs__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignBool(false)
}
func (_Txs__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignInt(0)
}
func (_Txs__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignFloat(0)
}
func (_Txs__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignString("")
}
func (_Txs__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignBytes(nil)
}
func (_Txs__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignLink(nil)
}
func (na *_Txs__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Txs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Txs.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Txs__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Txs__ReprPrototype{}
}
func (la *_Txs__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Txs__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Tx{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Txs__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Txs__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Tx__ReprPrototype{}
}

func (n Uint) Bytes() []byte {
	return n.x
}
func (_Uint__Prototype) FromBytes(v []byte) (Uint, error) {
	n := _Uint{v}
	return &n, nil
}

type _Uint__Maybe struct {
	m schema.Maybe
	v Uint
}
type MaybeUint = *_Uint__Maybe

func (m MaybeUint) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUint) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUint) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUint) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeUint) Must() Uint {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Uint)(&_Uint{})
var _ schema.TypedNode = (Uint)(&_Uint{})

func (Uint) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Uint) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.LookupByString("")
}
func (Uint) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.LookupByNode(nil)
}
func (Uint) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.LookupByIndex(0)
}
func (Uint) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.LookupBySegment(seg)
}
func (Uint) MapIterator() ipld.MapIterator {
	return nil
}
func (Uint) ListIterator() ipld.ListIterator {
	return nil
}
func (Uint) Length() int64 {
	return -1
}
func (Uint) IsAbsent() bool {
	return false
}
func (Uint) IsNull() bool {
	return false
}
func (Uint) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.AsBool()
}
func (Uint) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.AsInt()
}
func (Uint) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.AsFloat()
}
func (Uint) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.AsString()
}
func (n Uint) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Uint) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.AsLink()
}
func (Uint) Prototype() ipld.NodePrototype {
	return _Uint__Prototype{}
}

type _Uint__Prototype struct{}

func (_Uint__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Uint__Builder
	nb.Reset()
	return &nb
}

type _Uint__Builder struct {
	_Uint__Assembler
}

func (nb *_Uint__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Uint__Builder) Reset() {
	var w _Uint
	var m schema.Maybe
	*nb = _Uint__Builder{_Uint__Assembler{w: &w, m: &m}}
}

type _Uint__Assembler struct {
	w *_Uint
	m *schema.Maybe
}

func (na *_Uint__Assembler) reset() {}
func (_Uint__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.BeginMap(0)
}
func (_Uint__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.BeginList(0)
}
func (na *_Uint__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Uint__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignBool(false)
}
func (_Uint__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignInt(0)
}
func (_Uint__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignFloat(0)
}
func (_Uint__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignString("")
}
func (na *_Uint__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Uint{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Uint__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignLink(nil)
}
func (na *_Uint__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Uint); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Uint__Assembler) Prototype() ipld.NodePrototype {
	return _Uint__Prototype{}
}
func (Uint) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Uint) Representation() ipld.Node {
	return (*_Uint__Repr)(n)
}

type _Uint__Repr = _Uint

var _ ipld.Node = &_Uint__Repr{}

type _Uint__ReprPrototype = _Uint__Prototype
type _Uint__ReprAssembler = _Uint__Assembler

func (n _Validator) FieldAddress() Address {
	return &n.Address
}
func (n _Validator) FieldPubKey() PubKey {
	return &n.PubKey
}
func (n _Validator) FieldVotingPower() Int {
	return &n.VotingPower
}
func (n _Validator) FieldProsperPriority() Int {
	return &n.ProsperPriority
}

type _Validator__Maybe struct {
	m schema.Maybe
	v Validator
}
type MaybeValidator = *_Validator__Maybe

func (m MaybeValidator) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeValidator) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeValidator) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeValidator) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeValidator) Must() Validator {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Validator_Address         = _String{"Address"}
	fieldName__Validator_PubKey          = _String{"PubKey"}
	fieldName__Validator_VotingPower     = _String{"VotingPower"}
	fieldName__Validator_ProsperPriority = _String{"ProsperPriority"}
)
var _ ipld.Node = (Validator)(&_Validator{})
var _ schema.TypedNode = (Validator)(&_Validator{})

func (Validator) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Validator) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return &n.Address, nil
	case "PubKey":
		return &n.PubKey, nil
	case "VotingPower":
		return &n.VotingPower, nil
	case "ProsperPriority":
		return &n.ProsperPriority, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Validator) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Validator) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Validator"}.LookupByIndex(0)
}
func (n Validator) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Validator) MapIterator() ipld.MapIterator {
	return &_Validator__MapItr{n, 0}
}

type _Validator__MapItr struct {
	n   Validator
	idx int
}

func (itr *_Validator__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Validator_Address
		v = &itr.n.Address
	case 1:
		k = &fieldName__Validator_PubKey
		v = &itr.n.PubKey
	case 2:
		k = &fieldName__Validator_VotingPower
		v = &itr.n.VotingPower
	case 3:
		k = &fieldName__Validator_ProsperPriority
		v = &itr.n.ProsperPriority
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Validator__MapItr) Done() bool {
	return itr.idx >= 4
}

func (Validator) ListIterator() ipld.ListIterator {
	return nil
}
func (Validator) Length() int64 {
	return 4
}
func (Validator) IsAbsent() bool {
	return false
}
func (Validator) IsNull() bool {
	return false
}
func (Validator) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsBool()
}
func (Validator) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsInt()
}
func (Validator) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsFloat()
}
func (Validator) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsString()
}
func (Validator) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsBytes()
}
func (Validator) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsLink()
}
func (Validator) Prototype() ipld.NodePrototype {
	return _Validator__Prototype{}
}

type _Validator__Prototype struct{}

func (_Validator__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Validator__Builder
	nb.Reset()
	return &nb
}

type _Validator__Builder struct {
	_Validator__Assembler
}

func (nb *_Validator__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Validator__Builder) Reset() {
	var w _Validator
	var m schema.Maybe
	*nb = _Validator__Builder{_Validator__Assembler{w: &w, m: &m}}
}

type _Validator__Assembler struct {
	w     *_Validator
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                 schema.Maybe
	ca_Address         _Address__Assembler
	ca_PubKey          _PubKey__Assembler
	ca_VotingPower     _Int__Assembler
	ca_ProsperPriority _Int__Assembler
}

func (na *_Validator__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_PubKey.reset()
	na.ca_VotingPower.reset()
	na.ca_ProsperPriority.reset()
}

var (
	fieldBit__Validator_Address         = 1 << 0
	fieldBit__Validator_PubKey          = 1 << 1
	fieldBit__Validator_VotingPower     = 1 << 2
	fieldBit__Validator_ProsperPriority = 1 << 3
	fieldBits__Validator_sufficient     = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_Validator__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Validator{}
	}
	return na, nil
}
func (_Validator__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Validator"}.BeginList(0)
}
func (na *_Validator__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Validator"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Validator__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignBool(false)
}
func (_Validator__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignInt(0)
}
func (_Validator__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignFloat(0)
}
func (_Validator__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignString("")
}
func (_Validator__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignBytes(nil)
}
func (_Validator__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignLink(nil)
}
func (na *_Validator__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Validator); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Validator", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Validator__Assembler) Prototype() ipld.NodePrototype {
	return _Validator__Prototype{}
}
func (ma *_Validator__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Address.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PubKey.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_VotingPower.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ProsperPriority.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Validator__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__Validator_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_Address}
		}
		ma.s += fieldBit__Validator_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "PubKey":
		if ma.s&fieldBit__Validator_PubKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_PubKey}
		}
		ma.s += fieldBit__Validator_PubKey
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey, nil
	case "VotingPower":
		if ma.s&fieldBit__Validator_VotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_VotingPower}
		}
		ma.s += fieldBit__Validator_VotingPower
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower, nil
	case "ProsperPriority":
		if ma.s&fieldBit__Validator_ProsperPriority != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_ProsperPriority}
		}
		ma.s += fieldBit__Validator_ProsperPriority
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_ProsperPriority.w = &ma.w.ProsperPriority
		ma.ca_ProsperPriority.m = &ma.cm
		return &ma.ca_ProsperPriority, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Validator", Key: &_String{k}}
}
func (ma *_Validator__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Validator__KeyAssembler)(ma)
}
func (ma *_Validator__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey
	case 2:
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower
	case 3:
		ma.ca_ProsperPriority.w = &ma.w.ProsperPriority
		ma.ca_ProsperPriority.m = &ma.cm
		return &ma.ca_ProsperPriority
	default:
		panic("unreachable")
	}
}
func (ma *_Validator__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Validator_sufficient != fieldBits__Validator_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Validator_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__Validator_PubKey == 0 {
			err.Missing = append(err.Missing, "PubKey")
		}
		if ma.s&fieldBit__Validator_VotingPower == 0 {
			err.Missing = append(err.Missing, "VotingPower")
		}
		if ma.s&fieldBit__Validator_ProsperPriority == 0 {
			err.Missing = append(err.Missing, "ProsperPriority")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Validator__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Validator__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Validator__KeyAssembler _Validator__Assembler

func (_Validator__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.BeginMap(0)
}
func (_Validator__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.BeginList(0)
}
func (na *_Validator__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignNull()
}
func (_Validator__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignBool(false)
}
func (_Validator__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignInt(0)
}
func (_Validator__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Validator__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__Validator_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_Address}
		}
		ka.s += fieldBit__Validator_Address
		ka.state = maState_expectValue
		ka.f = 0
	case "PubKey":
		if ka.s&fieldBit__Validator_PubKey != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_PubKey}
		}
		ka.s += fieldBit__Validator_PubKey
		ka.state = maState_expectValue
		ka.f = 1
	case "VotingPower":
		if ka.s&fieldBit__Validator_VotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_VotingPower}
		}
		ka.s += fieldBit__Validator_VotingPower
		ka.state = maState_expectValue
		ka.f = 2
	case "ProsperPriority":
		if ka.s&fieldBit__Validator_ProsperPriority != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_ProsperPriority}
		}
		ka.s += fieldBit__Validator_ProsperPriority
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Validator", Key: &_String{k}}
	}
	return nil
}
func (_Validator__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignBytes(nil)
}
func (_Validator__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Validator__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Validator__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Validator) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Validator) Representation() ipld.Node {
	return (*_Validator__Repr)(n)
}

type _Validator__Repr _Validator

var (
	fieldName__Validator_Address_serial         = _String{"Address"}
	fieldName__Validator_PubKey_serial          = _String{"PubKey"}
	fieldName__Validator_VotingPower_serial     = _String{"VotingPower"}
	fieldName__Validator_ProsperPriority_serial = _String{"ProsperPriority"}
)
var _ ipld.Node = &_Validator__Repr{}

func (_Validator__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Validator__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return n.Address.Representation(), nil
	case "PubKey":
		return n.PubKey.Representation(), nil
	case "VotingPower":
		return n.VotingPower.Representation(), nil
	case "ProsperPriority":
		return n.ProsperPriority.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Validator__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Validator__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.LookupByIndex(0)
}
func (n _Validator__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Validator__Repr) MapIterator() ipld.MapIterator {
	return &_Validator__ReprMapItr{n, 0}
}

type _Validator__ReprMapItr struct {
	n   *_Validator__Repr
	idx int
}

func (itr *_Validator__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Validator_Address_serial
		v = itr.n.Address.Representation()
	case 1:
		k = &fieldName__Validator_PubKey_serial
		v = itr.n.PubKey.Representation()
	case 2:
		k = &fieldName__Validator_VotingPower_serial
		v = itr.n.VotingPower.Representation()
	case 3:
		k = &fieldName__Validator_ProsperPriority_serial
		v = itr.n.ProsperPriority.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Validator__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_Validator__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Validator__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_Validator__Repr) IsAbsent() bool {
	return false
}
func (_Validator__Repr) IsNull() bool {
	return false
}
func (_Validator__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsBool()
}
func (_Validator__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsInt()
}
func (_Validator__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsFloat()
}
func (_Validator__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsString()
}
func (_Validator__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsBytes()
}
func (_Validator__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsLink()
}
func (_Validator__Repr) Prototype() ipld.NodePrototype {
	return _Validator__ReprPrototype{}
}

type _Validator__ReprPrototype struct{}

func (_Validator__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Validator__ReprBuilder
	nb.Reset()
	return &nb
}

type _Validator__ReprBuilder struct {
	_Validator__ReprAssembler
}

func (nb *_Validator__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Validator__ReprBuilder) Reset() {
	var w _Validator
	var m schema.Maybe
	*nb = _Validator__ReprBuilder{_Validator__ReprAssembler{w: &w, m: &m}}
}

type _Validator__ReprAssembler struct {
	w     *_Validator
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                 schema.Maybe
	ca_Address         _Address__ReprAssembler
	ca_PubKey          _PubKey__ReprAssembler
	ca_VotingPower     _Int__ReprAssembler
	ca_ProsperPriority _Int__ReprAssembler
}

func (na *_Validator__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_PubKey.reset()
	na.ca_VotingPower.reset()
	na.ca_ProsperPriority.reset()
}
func (na *_Validator__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Validator{}
	}
	return na, nil
}
func (_Validator__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.BeginList(0)
}
func (na *_Validator__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Validator.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Validator__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignBool(false)
}
func (_Validator__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignInt(0)
}
func (_Validator__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignFloat(0)
}
func (_Validator__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignString("")
}
func (_Validator__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignBytes(nil)
}
func (_Validator__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignLink(nil)
}
func (na *_Validator__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Validator); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Validator.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Validator__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Validator__ReprPrototype{}
}
func (ma *_Validator__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Validator__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__Validator_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_Address_serial}
		}
		ma.s += fieldBit__Validator_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "PubKey":
		if ma.s&fieldBit__Validator_PubKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_PubKey_serial}
		}
		ma.s += fieldBit__Validator_PubKey
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey, nil
	case "VotingPower":
		if ma.s&fieldBit__Validator_VotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_VotingPower_serial}
		}
		ma.s += fieldBit__Validator_VotingPower
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower, nil
	case "ProsperPriority":
		if ma.s&fieldBit__Validator_ProsperPriority != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_ProsperPriority_serial}
		}
		ma.s += fieldBit__Validator_ProsperPriority
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_ProsperPriority.w = &ma.w.ProsperPriority
		ma.ca_ProsperPriority.m = &ma.cm
		return &ma.ca_ProsperPriority, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Validator.Repr", Key: &_String{k}}
}
func (ma *_Validator__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Validator__ReprKeyAssembler)(ma)
}
func (ma *_Validator__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey
	case 2:
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower
	case 3:
		ma.ca_ProsperPriority.w = &ma.w.ProsperPriority
		ma.ca_ProsperPriority.m = &ma.cm
		return &ma.ca_ProsperPriority
	default:
		panic("unreachable")
	}
}
func (ma *_Validator__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Validator_sufficient != fieldBits__Validator_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Validator_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__Validator_PubKey == 0 {
			err.Missing = append(err.Missing, "PubKey")
		}
		if ma.s&fieldBit__Validator_VotingPower == 0 {
			err.Missing = append(err.Missing, "VotingPower")
		}
		if ma.s&fieldBit__Validator_ProsperPriority == 0 {
			err.Missing = append(err.Missing, "ProsperPriority")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Validator__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Validator__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Validator__ReprKeyAssembler _Validator__ReprAssembler

func (_Validator__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Validator__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Validator__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignNull()
}
func (_Validator__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Validator__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Validator__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Validator__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__Validator_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_Address_serial}
		}
		ka.s += fieldBit__Validator_Address
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "PubKey":
		if ka.s&fieldBit__Validator_PubKey != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_PubKey_serial}
		}
		ka.s += fieldBit__Validator_PubKey
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "VotingPower":
		if ka.s&fieldBit__Validator_VotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_VotingPower_serial}
		}
		ka.s += fieldBit__Validator_VotingPower
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "ProsperPriority":
		if ka.s&fieldBit__Validator_ProsperPriority != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_ProsperPriority_serial}
		}
		ka.s += fieldBit__Validator_ProsperPriority
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Validator.Repr", Key: &_String{k}}
}
func (_Validator__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Validator__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Validator__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Validator__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _ValidatorSet) FieldValidators() Validators {
	return &n.Validators
}
func (n _ValidatorSet) FieldProposer() Validator {
	return &n.Proposer
}

type _ValidatorSet__Maybe struct {
	m schema.Maybe
	v ValidatorSet
}
type MaybeValidatorSet = *_ValidatorSet__Maybe

func (m MaybeValidatorSet) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeValidatorSet) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeValidatorSet) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeValidatorSet) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeValidatorSet) Must() ValidatorSet {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__ValidatorSet_Validators = _String{"Validators"}
	fieldName__ValidatorSet_Proposer   = _String{"Proposer"}
)
var _ ipld.Node = (ValidatorSet)(&_ValidatorSet{})
var _ schema.TypedNode = (ValidatorSet)(&_ValidatorSet{})

func (ValidatorSet) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n ValidatorSet) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Validators":
		return &n.Validators, nil
	case "Proposer":
		return &n.Proposer, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n ValidatorSet) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (ValidatorSet) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.LookupByIndex(0)
}
func (n ValidatorSet) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n ValidatorSet) MapIterator() ipld.MapIterator {
	return &_ValidatorSet__MapItr{n, 0}
}

type _ValidatorSet__MapItr struct {
	n   ValidatorSet
	idx int
}

func (itr *_ValidatorSet__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__ValidatorSet_Validators
		v = &itr.n.Validators
	case 1:
		k = &fieldName__ValidatorSet_Proposer
		v = &itr.n.Proposer
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ValidatorSet__MapItr) Done() bool {
	return itr.idx >= 2
}

func (ValidatorSet) ListIterator() ipld.ListIterator {
	return nil
}
func (ValidatorSet) Length() int64 {
	return 2
}
func (ValidatorSet) IsAbsent() bool {
	return false
}
func (ValidatorSet) IsNull() bool {
	return false
}
func (ValidatorSet) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsBool()
}
func (ValidatorSet) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsInt()
}
func (ValidatorSet) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsFloat()
}
func (ValidatorSet) AsString() (string, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsString()
}
func (ValidatorSet) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsBytes()
}
func (ValidatorSet) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsLink()
}
func (ValidatorSet) Prototype() ipld.NodePrototype {
	return _ValidatorSet__Prototype{}
}

type _ValidatorSet__Prototype struct{}

func (_ValidatorSet__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _ValidatorSet__Builder
	nb.Reset()
	return &nb
}

type _ValidatorSet__Builder struct {
	_ValidatorSet__Assembler
}

func (nb *_ValidatorSet__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ValidatorSet__Builder) Reset() {
	var w _ValidatorSet
	var m schema.Maybe
	*nb = _ValidatorSet__Builder{_ValidatorSet__Assembler{w: &w, m: &m}}
}

type _ValidatorSet__Assembler struct {
	w     *_ValidatorSet
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Validators _Validators__Assembler
	ca_Proposer   _Validator__Assembler
}

func (na *_ValidatorSet__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Validators.reset()
	na.ca_Proposer.reset()
}

var (
	fieldBit__ValidatorSet_Validators  = 1 << 0
	fieldBit__ValidatorSet_Proposer    = 1 << 1
	fieldBits__ValidatorSet_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_ValidatorSet__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ValidatorSet{}
	}
	return na, nil
}
func (_ValidatorSet__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.BeginList(0)
}
func (na *_ValidatorSet__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ValidatorSet__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignBool(false)
}
func (_ValidatorSet__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignInt(0)
}
func (_ValidatorSet__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignFloat(0)
}
func (_ValidatorSet__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignString("")
}
func (_ValidatorSet__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignBytes(nil)
}
func (_ValidatorSet__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignLink(nil)
}
func (na *_ValidatorSet__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ValidatorSet); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.ValidatorSet", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ValidatorSet__Assembler) Prototype() ipld.NodePrototype {
	return _ValidatorSet__Prototype{}
}
func (ma *_ValidatorSet__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Validators.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Proposer.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorSet__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Validators":
		if ma.s&fieldBit__ValidatorSet_Validators != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Validators}
		}
		ma.s += fieldBit__ValidatorSet_Validators
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Validators.w = &ma.w.Validators
		ma.ca_Validators.m = &ma.cm
		return &ma.ca_Validators, nil
	case "Proposer":
		if ma.s&fieldBit__ValidatorSet_Proposer != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Proposer}
		}
		ma.s += fieldBit__ValidatorSet_Proposer
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Proposer.w = &ma.w.Proposer
		ma.ca_Proposer.m = &ma.cm
		return &ma.ca_Proposer, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorSet", Key: &_String{k}}
}
func (ma *_ValidatorSet__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ValidatorSet__KeyAssembler)(ma)
}
func (ma *_ValidatorSet__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Validators.w = &ma.w.Validators
		ma.ca_Validators.m = &ma.cm
		return &ma.ca_Validators
	case 1:
		ma.ca_Proposer.w = &ma.w.Proposer
		ma.ca_Proposer.m = &ma.cm
		return &ma.ca_Proposer
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorSet__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__ValidatorSet_sufficient != fieldBits__ValidatorSet_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__ValidatorSet_Validators == 0 {
			err.Missing = append(err.Missing, "Validators")
		}
		if ma.s&fieldBit__ValidatorSet_Proposer == 0 {
			err.Missing = append(err.Missing, "Proposer")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ValidatorSet__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ValidatorSet__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _ValidatorSet__KeyAssembler _ValidatorSet__Assembler

func (_ValidatorSet__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.BeginMap(0)
}
func (_ValidatorSet__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.BeginList(0)
}
func (na *_ValidatorSet__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignNull()
}
func (_ValidatorSet__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignBool(false)
}
func (_ValidatorSet__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignInt(0)
}
func (_ValidatorSet__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ValidatorSet__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Validators":
		if ka.s&fieldBit__ValidatorSet_Validators != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Validators}
		}
		ka.s += fieldBit__ValidatorSet_Validators
		ka.state = maState_expectValue
		ka.f = 0
	case "Proposer":
		if ka.s&fieldBit__ValidatorSet_Proposer != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Proposer}
		}
		ka.s += fieldBit__ValidatorSet_Proposer
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorSet", Key: &_String{k}}
	}
	return nil
}
func (_ValidatorSet__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignBytes(nil)
}
func (_ValidatorSet__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ValidatorSet__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ValidatorSet__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ValidatorSet) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n ValidatorSet) Representation() ipld.Node {
	return (*_ValidatorSet__Repr)(n)
}

type _ValidatorSet__Repr _ValidatorSet

var (
	fieldName__ValidatorSet_Validators_serial = _String{"Validators"}
	fieldName__ValidatorSet_Proposer_serial   = _String{"Proposer"}
)
var _ ipld.Node = &_ValidatorSet__Repr{}

func (_ValidatorSet__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_ValidatorSet__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Validators":
		return n.Validators.Representation(), nil
	case "Proposer":
		return n.Proposer.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_ValidatorSet__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_ValidatorSet__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.LookupByIndex(0)
}
func (n _ValidatorSet__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_ValidatorSet__Repr) MapIterator() ipld.MapIterator {
	return &_ValidatorSet__ReprMapItr{n, 0}
}

type _ValidatorSet__ReprMapItr struct {
	n   *_ValidatorSet__Repr
	idx int
}

func (itr *_ValidatorSet__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__ValidatorSet_Validators_serial
		v = itr.n.Validators.Representation()
	case 1:
		k = &fieldName__ValidatorSet_Proposer_serial
		v = itr.n.Proposer.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ValidatorSet__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_ValidatorSet__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_ValidatorSet__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_ValidatorSet__Repr) IsAbsent() bool {
	return false
}
func (_ValidatorSet__Repr) IsNull() bool {
	return false
}
func (_ValidatorSet__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsBool()
}
func (_ValidatorSet__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsInt()
}
func (_ValidatorSet__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsFloat()
}
func (_ValidatorSet__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsString()
}
func (_ValidatorSet__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsBytes()
}
func (_ValidatorSet__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsLink()
}
func (_ValidatorSet__Repr) Prototype() ipld.NodePrototype {
	return _ValidatorSet__ReprPrototype{}
}

type _ValidatorSet__ReprPrototype struct{}

func (_ValidatorSet__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _ValidatorSet__ReprBuilder
	nb.Reset()
	return &nb
}

type _ValidatorSet__ReprBuilder struct {
	_ValidatorSet__ReprAssembler
}

func (nb *_ValidatorSet__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ValidatorSet__ReprBuilder) Reset() {
	var w _ValidatorSet
	var m schema.Maybe
	*nb = _ValidatorSet__ReprBuilder{_ValidatorSet__ReprAssembler{w: &w, m: &m}}
}

type _ValidatorSet__ReprAssembler struct {
	w     *_ValidatorSet
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Validators _Validators__ReprAssembler
	ca_Proposer   _Validator__ReprAssembler
}

func (na *_ValidatorSet__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Validators.reset()
	na.ca_Proposer.reset()
}
func (na *_ValidatorSet__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ValidatorSet{}
	}
	return na, nil
}
func (_ValidatorSet__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.BeginList(0)
}
func (na *_ValidatorSet__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ValidatorSet__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignBool(false)
}
func (_ValidatorSet__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignInt(0)
}
func (_ValidatorSet__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignFloat(0)
}
func (_ValidatorSet__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignString("")
}
func (_ValidatorSet__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignBytes(nil)
}
func (_ValidatorSet__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignLink(nil)
}
func (na *_ValidatorSet__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ValidatorSet); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.ValidatorSet.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ValidatorSet__ReprAssembler) Prototype() ipld.NodePrototype {
	return _ValidatorSet__ReprPrototype{}
}
func (ma *_ValidatorSet__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorSet__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Validators":
		if ma.s&fieldBit__ValidatorSet_Validators != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Validators_serial}
		}
		ma.s += fieldBit__ValidatorSet_Validators
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Validators.w = &ma.w.Validators
		ma.ca_Validators.m = &ma.cm
		return &ma.ca_Validators, nil
	case "Proposer":
		if ma.s&fieldBit__ValidatorSet_Proposer != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Proposer_serial}
		}
		ma.s += fieldBit__ValidatorSet_Proposer
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Proposer.w = &ma.w.Proposer
		ma.ca_Proposer.m = &ma.cm
		return &ma.ca_Proposer, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorSet.Repr", Key: &_String{k}}
}
func (ma *_ValidatorSet__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ValidatorSet__ReprKeyAssembler)(ma)
}
func (ma *_ValidatorSet__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Validators.w = &ma.w.Validators
		ma.ca_Validators.m = &ma.cm
		return &ma.ca_Validators
	case 1:
		ma.ca_Proposer.w = &ma.w.Proposer
		ma.ca_Proposer.m = &ma.cm
		return &ma.ca_Proposer
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorSet__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__ValidatorSet_sufficient != fieldBits__ValidatorSet_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__ValidatorSet_Validators == 0 {
			err.Missing = append(err.Missing, "Validators")
		}
		if ma.s&fieldBit__ValidatorSet_Proposer == 0 {
			err.Missing = append(err.Missing, "Proposer")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ValidatorSet__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ValidatorSet__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _ValidatorSet__ReprKeyAssembler _ValidatorSet__ReprAssembler

func (_ValidatorSet__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.BeginMap(0)
}
func (_ValidatorSet__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_ValidatorSet__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignNull()
}
func (_ValidatorSet__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignBool(false)
}
func (_ValidatorSet__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignInt(0)
}
func (_ValidatorSet__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ValidatorSet__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Validators":
		if ka.s&fieldBit__ValidatorSet_Validators != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Validators_serial}
		}
		ka.s += fieldBit__ValidatorSet_Validators
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Proposer":
		if ka.s&fieldBit__ValidatorSet_Proposer != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Proposer_serial}
		}
		ka.s += fieldBit__ValidatorSet_Proposer
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorSet.Repr", Key: &_String{k}}
}
func (_ValidatorSet__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_ValidatorSet__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ValidatorSet__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ValidatorSet__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_Validators) Lookup(idx int64) Validator {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Validators) LookupMaybe(idx int64) MaybeValidator {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Validator__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Validators__valueAbsent = _Validator__Maybe{m: schema.Maybe_Absent}

func (n Validators) Iterator() *Validators__Itr {
	return &Validators__Itr{n, 0}
}

type Validators__Itr struct {
	n   Validators
	idx int
}

func (itr *Validators__Itr) Next() (idx int64, v Validator) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Validators__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Validators__Maybe struct {
	m schema.Maybe
	v Validators
}
type MaybeValidators = *_Validators__Maybe

func (m MaybeValidators) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeValidators) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeValidators) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeValidators) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeValidators) Must() Validators {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Validators)(&_Validators{})
var _ schema.TypedNode = (Validators)(&_Validators{})

func (Validators) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Validators) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Validators"}.LookupByString("")
}
func (n Validators) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Validators) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Validators) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Validators", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Validators) MapIterator() ipld.MapIterator {
	return nil
}
func (n Validators) ListIterator() ipld.ListIterator {
	return &_Validators__ListItr{n, 0}
}

type _Validators__ListItr struct {
	n   Validators
	idx int
}

func (itr *_Validators__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Validators__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Validators) Length() int64 {
	return int64(len(n.x))
}
func (Validators) IsAbsent() bool {
	return false
}
func (Validators) IsNull() bool {
	return false
}
func (Validators) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Validators"}.AsBool()
}
func (Validators) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Validators"}.AsInt()
}
func (Validators) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Validators"}.AsFloat()
}
func (Validators) AsString() (string, error) {
	return mixins.List{"dagcosmos.Validators"}.AsString()
}
func (Validators) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Validators"}.AsBytes()
}
func (Validators) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Validators"}.AsLink()
}
func (Validators) Prototype() ipld.NodePrototype {
	return _Validators__Prototype{}
}

type _Validators__Prototype struct{}

func (_Validators__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Validators__Builder
	nb.Reset()
	return &nb
}

type _Validators__Builder struct {
	_Validators__Assembler
}

func (nb *_Validators__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Validators__Builder) Reset() {
	var w _Validators
	var m schema.Maybe
	*nb = _Validators__Builder{_Validators__Assembler{w: &w, m: &m}}
}

type _Validators__Assembler struct {
	w     *_Validators
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Validator__Assembler
}

func (na *_Validators__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Validators__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Validators"}.BeginMap(0)
}
func (na *_Validators__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Validators{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Validator, 0, sizeHint)
	}
	return na, nil
}
func (na *_Validators__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Validators"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Validators__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignBool(false)
}
func (_Validators__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignInt(0)
}
func (_Validators__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignFloat(0)
}
func (_Validators__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignString("")
}
func (_Validators__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignBytes(nil)
}
func (_Validators__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignLink(nil)
}
func (na *_Validators__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Validators); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Validators", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Validators__Assembler) Prototype() ipld.NodePrototype {
	return _Validators__Prototype{}
}
func (la *_Validators__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Validators__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Validator{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Validators__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Validators__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Validator__Prototype{}
}
func (Validators) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Validators) Representation() ipld.Node {
	return (*_Validators__Repr)(n)
}

type _Validators__Repr _Validators

var _ ipld.Node = &_Validators__Repr{}

func (_Validators__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Validators__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.LookupByString("")
}
func (nr *_Validators__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Validators)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Validator).Representation(), nil
}
func (nr *_Validators__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Validators)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Validator).Representation(), nil
}
func (n _Validators__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Validators.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Validators__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Validators__Repr) ListIterator() ipld.ListIterator {
	return &_Validators__ReprListItr{(Validators)(nr), 0}
}

type _Validators__ReprListItr _Validators__ListItr

func (itr *_Validators__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Validators__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Validator).Representation(), nil
}
func (itr *_Validators__ReprListItr) Done() bool {
	return (*_Validators__ListItr)(itr).Done()
}

func (rn *_Validators__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Validators__Repr) IsAbsent() bool {
	return false
}
func (_Validators__Repr) IsNull() bool {
	return false
}
func (_Validators__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsBool()
}
func (_Validators__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsInt()
}
func (_Validators__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsFloat()
}
func (_Validators__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsString()
}
func (_Validators__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsBytes()
}
func (_Validators__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsLink()
}
func (_Validators__Repr) Prototype() ipld.NodePrototype {
	return _Validators__ReprPrototype{}
}

type _Validators__ReprPrototype struct{}

func (_Validators__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Validators__ReprBuilder
	nb.Reset()
	return &nb
}

type _Validators__ReprBuilder struct {
	_Validators__ReprAssembler
}

func (nb *_Validators__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Validators__ReprBuilder) Reset() {
	var w _Validators
	var m schema.Maybe
	*nb = _Validators__ReprBuilder{_Validators__ReprAssembler{w: &w, m: &m}}
}

type _Validators__ReprAssembler struct {
	w     *_Validators
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Validator__ReprAssembler
}

func (na *_Validators__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Validators__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.BeginMap(0)
}
func (na *_Validators__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Validators{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Validator, 0, sizeHint)
	}
	return na, nil
}
func (na *_Validators__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Validators.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Validators__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignBool(false)
}
func (_Validators__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignInt(0)
}
func (_Validators__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignFloat(0)
}
func (_Validators__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignString("")
}
func (_Validators__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignBytes(nil)
}
func (_Validators__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignLink(nil)
}
func (na *_Validators__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Validators); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Validators.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Validators__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Validators__ReprPrototype{}
}
func (la *_Validators__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Validators__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Validator{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Validators__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Validators__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Validator__ReprPrototype{}
}

func (n _Value) AsInterface() _Value__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	case 3:
		return &n.x3
	case 4:
		return &n.x4
	case 5:
		return &n.x5
	case 6:
		return &n.x6
	case 7:
		return &n.x7
	default:
		panic("invalid union state; how did you create this object?")
	}
}

type _Value__Maybe struct {
	m schema.Maybe
	v Value
}
type MaybeValue = *_Value__Maybe

func (m MaybeValue) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeValue) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeValue) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeValue) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeValue) Must() Value {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	memberName__Value_SimpleValidator   = _String{"SimpleValidator"}
	memberName__Value_Evidence          = _String{"Evidence"}
	memberName__Value_Link              = _String{"Link"}
	memberName__Value_Part              = _String{"Part"}
	memberName__Value_ResponseDeliverTx = _String{"ResponseDeliverTx"}
	memberName__Value_Bytes             = _String{"Bytes"}
	memberName__Value_CommitSig         = _String{"CommitSig"}
)
var _ ipld.Node = (Value)(&_Value{})
var _ schema.TypedNode = (Value)(&_Value{})

func (Value) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Value) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "SimpleValidator":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "Evidence":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	case "Link":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x3, nil
	case "Part":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x4, nil
	case "ResponseDeliverTx":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x5, nil
	case "Bytes":
		if n.tag != 6 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x6, nil
	case "CommitSig":
		if n.tag != 7 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x7, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Value) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Value) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Value"}.LookupByIndex(0)
}
func (n Value) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Value) MapIterator() ipld.MapIterator {
	return &_Value__MapItr{n, false}
}

type _Value__MapItr struct {
	n    Value
	done bool
}

func (itr *_Value__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__Value_SimpleValidator, &itr.n.x1
	case 2:
		k, v = &memberName__Value_Evidence, &itr.n.x2
	case 3:
		k, v = &memberName__Value_Link, &itr.n.x3
	case 4:
		k, v = &memberName__Value_Part, &itr.n.x4
	case 5:
		k, v = &memberName__Value_ResponseDeliverTx, &itr.n.x5
	case 6:
		k, v = &memberName__Value_Bytes, &itr.n.x6
	case 7:
		k, v = &memberName__Value_CommitSig, &itr.n.x7
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_Value__MapItr) Done() bool {
	return itr.done
}

func (Value) ListIterator() ipld.ListIterator {
	return nil
}
func (Value) Length() int64 {
	return 1
}
func (Value) IsAbsent() bool {
	return false
}
func (Value) IsNull() bool {
	return false
}
func (Value) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Value"}.AsBool()
}
func (Value) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Value"}.AsInt()
}
func (Value) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Value"}.AsFloat()
}
func (Value) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Value"}.AsString()
}
func (Value) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Value"}.AsBytes()
}
func (Value) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Value"}.AsLink()
}
func (Value) Prototype() ipld.NodePrototype {
	return _Value__Prototype{}
}

type _Value__Prototype struct{}

func (_Value__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Value__Builder
	nb.Reset()
	return &nb
}

type _Value__Builder struct {
	_Value__Assembler
}

func (nb *_Value__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Value__Builder) Reset() {
	var w _Value
	var m schema.Maybe
	*nb = _Value__Builder{_Value__Assembler{w: &w, m: &m}}
}

type _Value__Assembler struct {
	w     *_Value
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _SimpleValidator__Assembler

	ca2 _Evidence__Assembler

	ca3 _Link__Assembler

	ca4 _Part__Assembler

	ca5 _ResponseDeliverTx__Assembler

	ca6 _Bytes__Assembler

	ca7 _CommitSig__Assembler
	ca  uint
}

func (na *_Value__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()

	case 3:
		na.ca3.reset()

	case 4:
		na.ca4.reset()

	case 5:
		na.ca5.reset()

	case 6:
		na.ca6.reset()

	case 7:
		na.ca7.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_Value__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Value{}
	}
	return na, nil
}
func (_Value__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Value"}.BeginList(0)
}
func (na *_Value__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Value"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Value__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Value"}.AssignBool(false)
}
func (_Value__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Value"}.AssignInt(0)
}
func (_Value__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Value"}.AssignFloat(0)
}
func (_Value__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Value"}.AssignString("")
}
func (_Value__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Value"}.AssignBytes(nil)
}
func (_Value__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Value"}.AssignLink(nil)
}
func (na *_Value__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Value); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Value", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Value__Assembler) Prototype() ipld.NodePrototype {
	return _Value__Prototype{}
}
func (ma *_Value__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_Value__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.Value", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "SimpleValidator":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "Evidence":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "Link":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "Part":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "ResponseDeliverTx":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	case "Bytes":
		ma.state = maState_midValue
		ma.ca = 6
		ma.w.tag = 6
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6, nil
	case "CommitSig":
		ma.state = maState_midValue
		ma.ca = 7
		ma.w.tag = 7
		ma.ca7.w = &ma.w.x7
		ma.ca7.m = &ma.cm
		return &ma.ca7, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Value", Key: &_String{k}}
}
func (ma *_Value__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Value__KeyAssembler)(ma)
}
func (ma *_Value__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 4:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	case 5:
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6
	case 6:
		ma.ca7.w = &ma.w.x7
		ma.ca7.m = &ma.cm
		return &ma.ca7
	default:
		panic("unreachable")
	}
}
func (ma *_Value__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Value", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Value__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Value__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "SimpleValidator":
		return _SimpleValidator__Prototype{}
	case "Evidence":
		return _Evidence__Prototype{}
	case "Link":
		return _Link__Prototype{}
	case "Part":
		return _Part__Prototype{}
	case "ResponseDeliverTx":
		return _ResponseDeliverTx__Prototype{}
	case "Bytes":
		return _Bytes__Prototype{}
	case "CommitSig":
		return _CommitSig__Prototype{}
	default:
		return nil
	}
}

type _Value__KeyAssembler _Value__Assembler

func (_Value__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Value.KeyAssembler"}.BeginMap(0)
}
func (_Value__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Value.KeyAssembler"}.BeginList(0)
}
func (na *_Value__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Value.KeyAssembler"}.AssignNull()
}
func (_Value__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Value.KeyAssembler"}.AssignBool(false)
}
func (_Value__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Value.KeyAssembler"}.AssignInt(0)
}
func (_Value__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Value.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Value__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Value", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "SimpleValidator":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "Evidence":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "Link":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "Part":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "ResponseDeliverTx":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	case "Bytes":
		ka.ca = 6
		ka.w.tag = 6
		ka.state = maState_expectValue
		return nil
	case "CommitSig":
		ka.ca = 7
		ka.w.tag = 7
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Value", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_Value__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Value.KeyAssembler"}.AssignBytes(nil)
}
func (_Value__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Value.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Value__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Value__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Value) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Value) Representation() ipld.Node {
	return (*_Value__Repr)(n)
}

type _Value__Repr _Value

var (
	memberName__Value_SimpleValidator_serial   = _String{"validator"}
	memberName__Value_Evidence_serial          = _String{"evidence"}
	memberName__Value_Link_serial              = _String{"tx"}
	memberName__Value_Part_serial              = _String{"part"}
	memberName__Value_ResponseDeliverTx_serial = _String{"result"}
	memberName__Value_Bytes_serial             = _String{"header"}
	memberName__Value_CommitSig_serial         = _String{"commit"}
)
var _ ipld.Node = &_Value__Repr{}

func (_Value__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Value__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "validator":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "evidence":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	case "tx":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x3.Representation(), nil
	case "part":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x4.Representation(), nil
	case "result":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x5.Representation(), nil
	case "header":
		if n.tag != 6 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x6.Representation(), nil
	case "commit":
		if n.tag != 7 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x7.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Value__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Value__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Value.Repr"}.LookupByIndex(0)
}
func (n _Value__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Value__Repr) MapIterator() ipld.MapIterator {
	return &_Value__ReprMapItr{n, false}
}

type _Value__ReprMapItr struct {
	n    *_Value__Repr
	done bool
}

func (itr *_Value__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__Value_SimpleValidator_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__Value_Evidence_serial, itr.n.x2.Representation()
	case 3:
		k, v = &memberName__Value_Link_serial, itr.n.x3.Representation()
	case 4:
		k, v = &memberName__Value_Part_serial, itr.n.x4.Representation()
	case 5:
		k, v = &memberName__Value_ResponseDeliverTx_serial, itr.n.x5.Representation()
	case 6:
		k, v = &memberName__Value_Bytes_serial, itr.n.x6.Representation()
	case 7:
		k, v = &memberName__Value_CommitSig_serial, itr.n.x7.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_Value__ReprMapItr) Done() bool {
	return itr.done
}

func (_Value__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_Value__Repr) Length() int64 {
	return 1
}
func (_Value__Repr) IsAbsent() bool {
	return false
}
func (_Value__Repr) IsNull() bool {
	return false
}
func (_Value__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Value.Repr"}.AsBool()
}
func (_Value__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Value.Repr"}.AsInt()
}
func (_Value__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Value.Repr"}.AsFloat()
}
func (_Value__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Value.Repr"}.AsString()
}
func (_Value__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Value.Repr"}.AsBytes()
}
func (_Value__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Value.Repr"}.AsLink()
}
func (_Value__Repr) Prototype() ipld.NodePrototype {
	return _Value__ReprPrototype{}
}

type _Value__ReprPrototype struct{}

func (_Value__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Value__ReprBuilder
	nb.Reset()
	return &nb
}

type _Value__ReprBuilder struct {
	_Value__ReprAssembler
}

func (nb *_Value__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Value__ReprBuilder) Reset() {
	var w _Value
	var m schema.Maybe
	*nb = _Value__ReprBuilder{_Value__ReprAssembler{w: &w, m: &m}}
}

type _Value__ReprAssembler struct {
	w     *_Value
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _SimpleValidator__ReprAssembler

	ca2 _Evidence__ReprAssembler

	ca3 _Link__ReprAssembler

	ca4 _Part__ReprAssembler

	ca5 _ResponseDeliverTx__ReprAssembler

	ca6 _Bytes__ReprAssembler

	ca7 _CommitSig__ReprAssembler
	ca  uint
}

func (na *_Value__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()

	case 3:
		na.ca3.reset()

	case 4:
		na.ca4.reset()

	case 5:
		na.ca5.reset()

	case 6:
		na.ca6.reset()

	case 7:
		na.ca7.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_Value__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Value{}
	}
	return na, nil
}
func (_Value__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Value.Repr"}.BeginList(0)
}
func (na *_Value__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Value.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Value__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Value.Repr"}.AssignBool(false)
}
func (_Value__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Value.Repr"}.AssignInt(0)
}
func (_Value__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Value.Repr"}.AssignFloat(0)
}
func (_Value__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Value.Repr"}.AssignString("")
}
func (_Value__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Value.Repr"}.AssignBytes(nil)
}
func (_Value__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Value.Repr"}.AssignLink(nil)
}
func (na *_Value__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Value); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Value.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Value__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Value__ReprPrototype{}
}
func (ma *_Value__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_Value__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.Value.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "validator":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "evidence":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "tx":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "part":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "result":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	case "header":
		ma.state = maState_midValue
		ma.ca = 6
		ma.w.tag = 6
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6, nil
	case "commit":
		ma.state = maState_midValue
		ma.ca = 7
		ma.w.tag = 7
		ma.ca7.w = &ma.w.x7
		ma.ca7.m = &ma.cm
		return &ma.ca7, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Value.Repr", Key: &_String{k}}
}
func (ma *_Value__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Value__ReprKeyAssembler)(ma)
}
func (ma *_Value__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 4:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	case 5:
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6
	case 6:
		ma.ca7.w = &ma.w.x7
		ma.ca7.m = &ma.cm
		return &ma.ca7
	default:
		panic("unreachable")
	}
}
func (ma *_Value__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Value.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Value__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Value__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "SimpleValidator":
		return _SimpleValidator__ReprPrototype{}
	case "Evidence":
		return _Evidence__ReprPrototype{}
	case "Link":
		return _Link__ReprPrototype{}
	case "Part":
		return _Part__ReprPrototype{}
	case "ResponseDeliverTx":
		return _ResponseDeliverTx__ReprPrototype{}
	case "Bytes":
		return _Bytes__ReprPrototype{}
	case "CommitSig":
		return _CommitSig__ReprPrototype{}
	default:
		return nil
	}
}

type _Value__ReprKeyAssembler _Value__ReprAssembler

func (_Value__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Value.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Value__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Value.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Value__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Value.Repr.KeyAssembler"}.AssignNull()
}
func (_Value__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Value.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Value__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Value.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Value__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Value.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Value__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Value.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "validator":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "evidence":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "tx":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "part":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "result":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	case "header":
		ka.ca = 6
		ka.w.tag = 6
		ka.state = maState_expectValue
		return nil
	case "commit":
		ka.ca = 7
		ka.w.tag = 7
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Value.Repr", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_Value__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Value.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Value__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Value.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Value__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Value__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _Version) FieldBlock() Uint {
	return &n.Block
}
func (n _Version) FieldApp() Uint {
	return &n.App
}

type _Version__Maybe struct {
	m schema.Maybe
	v Version
}
type MaybeVersion = *_Version__Maybe

func (m MaybeVersion) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeVersion) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeVersion) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeVersion) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeVersion) Must() Version {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Version_Block = _String{"Block"}
	fieldName__Version_App   = _String{"App"}
)
var _ ipld.Node = (Version)(&_Version{})
var _ schema.TypedNode = (Version)(&_Version{})

func (Version) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Version) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Block":
		return &n.Block, nil
	case "App":
		return &n.App, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Version) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Version) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Version"}.LookupByIndex(0)
}
func (n Version) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Version) MapIterator() ipld.MapIterator {
	return &_Version__MapItr{n, 0}
}

type _Version__MapItr struct {
	n   Version
	idx int
}

func (itr *_Version__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Version_Block
		v = &itr.n.Block
	case 1:
		k = &fieldName__Version_App
		v = &itr.n.App
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Version__MapItr) Done() bool {
	return itr.idx >= 2
}

func (Version) ListIterator() ipld.ListIterator {
	return nil
}
func (Version) Length() int64 {
	return 2
}
func (Version) IsAbsent() bool {
	return false
}
func (Version) IsNull() bool {
	return false
}
func (Version) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Version"}.AsBool()
}
func (Version) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Version"}.AsInt()
}
func (Version) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Version"}.AsFloat()
}
func (Version) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Version"}.AsString()
}
func (Version) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Version"}.AsBytes()
}
func (Version) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Version"}.AsLink()
}
func (Version) Prototype() ipld.NodePrototype {
	return _Version__Prototype{}
}

type _Version__Prototype struct{}

func (_Version__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Version__Builder
	nb.Reset()
	return &nb
}

type _Version__Builder struct {
	_Version__Assembler
}

func (nb *_Version__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Version__Builder) Reset() {
	var w _Version
	var m schema.Maybe
	*nb = _Version__Builder{_Version__Assembler{w: &w, m: &m}}
}

type _Version__Assembler struct {
	w     *_Version
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Block _Uint__Assembler
	ca_App   _Uint__Assembler
}

func (na *_Version__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Block.reset()
	na.ca_App.reset()
}

var (
	fieldBit__Version_Block       = 1 << 0
	fieldBit__Version_App         = 1 << 1
	fieldBits__Version_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_Version__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Version{}
	}
	return na, nil
}
func (_Version__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Version"}.BeginList(0)
}
func (na *_Version__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Version"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Version__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignBool(false)
}
func (_Version__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignInt(0)
}
func (_Version__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignFloat(0)
}
func (_Version__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignString("")
}
func (_Version__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignBytes(nil)
}
func (_Version__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignLink(nil)
}
func (na *_Version__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Version); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Version", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Version__Assembler) Prototype() ipld.NodePrototype {
	return _Version__Prototype{}
}
func (ma *_Version__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Block.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_App.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Version__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Block":
		if ma.s&fieldBit__Version_Block != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Version_Block}
		}
		ma.s += fieldBit__Version_Block
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block, nil
	case "App":
		if ma.s&fieldBit__Version_App != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Version_App}
		}
		ma.s += fieldBit__Version_App
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_App.w = &ma.w.App
		ma.ca_App.m = &ma.cm
		return &ma.ca_App, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Version", Key: &_String{k}}
}
func (ma *_Version__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Version__KeyAssembler)(ma)
}
func (ma *_Version__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block
	case 1:
		ma.ca_App.w = &ma.w.App
		ma.ca_App.m = &ma.cm
		return &ma.ca_App
	default:
		panic("unreachable")
	}
}
func (ma *_Version__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Version_sufficient != fieldBits__Version_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Version_Block == 0 {
			err.Missing = append(err.Missing, "Block")
		}
		if ma.s&fieldBit__Version_App == 0 {
			err.Missing = append(err.Missing, "App")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Version__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Version__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Version__KeyAssembler _Version__Assembler

func (_Version__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.BeginMap(0)
}
func (_Version__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.BeginList(0)
}
func (na *_Version__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignNull()
}
func (_Version__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignBool(false)
}
func (_Version__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignInt(0)
}
func (_Version__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Version__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Block":
		if ka.s&fieldBit__Version_Block != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Version_Block}
		}
		ka.s += fieldBit__Version_Block
		ka.state = maState_expectValue
		ka.f = 0
	case "App":
		if ka.s&fieldBit__Version_App != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Version_App}
		}
		ka.s += fieldBit__Version_App
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Version", Key: &_String{k}}
	}
	return nil
}
func (_Version__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignBytes(nil)
}
func (_Version__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Version__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Version__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Version) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Version) Representation() ipld.Node {
	return (*_Version__Repr)(n)
}

type _Version__Repr _Version

var (
	fieldName__Version_Block_serial = _String{"Block"}
	fieldName__Version_App_serial   = _String{"App"}
)
var _ ipld.Node = &_Version__Repr{}

func (_Version__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Version__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Block":
		return n.Block.Representation(), nil
	case "App":
		return n.App.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Version__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Version__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.LookupByIndex(0)
}
func (n _Version__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Version__Repr) MapIterator() ipld.MapIterator {
	return &_Version__ReprMapItr{n, 0}
}

type _Version__ReprMapItr struct {
	n   *_Version__Repr
	idx int
}

func (itr *_Version__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Version_Block_serial
		v = itr.n.Block.Representation()
	case 1:
		k = &fieldName__Version_App_serial
		v = itr.n.App.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Version__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_Version__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Version__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_Version__Repr) IsAbsent() bool {
	return false
}
func (_Version__Repr) IsNull() bool {
	return false
}
func (_Version__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsBool()
}
func (_Version__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsInt()
}
func (_Version__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsFloat()
}
func (_Version__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsString()
}
func (_Version__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsBytes()
}
func (_Version__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsLink()
}
func (_Version__Repr) Prototype() ipld.NodePrototype {
	return _Version__ReprPrototype{}
}

type _Version__ReprPrototype struct{}

func (_Version__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Version__ReprBuilder
	nb.Reset()
	return &nb
}

type _Version__ReprBuilder struct {
	_Version__ReprAssembler
}

func (nb *_Version__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Version__ReprBuilder) Reset() {
	var w _Version
	var m schema.Maybe
	*nb = _Version__ReprBuilder{_Version__ReprAssembler{w: &w, m: &m}}
}

type _Version__ReprAssembler struct {
	w     *_Version
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Block _Uint__ReprAssembler
	ca_App   _Uint__ReprAssembler
}

func (na *_Version__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Block.reset()
	na.ca_App.reset()
}
func (na *_Version__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Version{}
	}
	return na, nil
}
func (_Version__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.BeginList(0)
}
func (na *_Version__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Version.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Version__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignBool(false)
}
func (_Version__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignInt(0)
}
func (_Version__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignFloat(0)
}
func (_Version__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignString("")
}
func (_Version__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignBytes(nil)
}
func (_Version__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignLink(nil)
}
func (na *_Version__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Version); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Version.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Version__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Version__ReprPrototype{}
}
func (ma *_Version__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Version__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Block":
		if ma.s&fieldBit__Version_Block != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Version_Block_serial}
		}
		ma.s += fieldBit__Version_Block
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block, nil
	case "App":
		if ma.s&fieldBit__Version_App != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Version_App_serial}
		}
		ma.s += fieldBit__Version_App
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_App.w = &ma.w.App
		ma.ca_App.m = &ma.cm
		return &ma.ca_App, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Version.Repr", Key: &_String{k}}
}
func (ma *_Version__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Version__ReprKeyAssembler)(ma)
}
func (ma *_Version__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block
	case 1:
		ma.ca_App.w = &ma.w.App
		ma.ca_App.m = &ma.cm
		return &ma.ca_App
	default:
		panic("unreachable")
	}
}
func (ma *_Version__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Version_sufficient != fieldBits__Version_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Version_Block == 0 {
			err.Missing = append(err.Missing, "Block")
		}
		if ma.s&fieldBit__Version_App == 0 {
			err.Missing = append(err.Missing, "App")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Version__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Version__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Version__ReprKeyAssembler _Version__ReprAssembler

func (_Version__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Version__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Version__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignNull()
}
func (_Version__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Version__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Version__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Version__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Block":
		if ka.s&fieldBit__Version_Block != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Version_Block_serial}
		}
		ka.s += fieldBit__Version_Block
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "App":
		if ka.s&fieldBit__Version_App != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Version_App_serial}
		}
		ka.s += fieldBit__Version_App
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Version.Repr", Key: &_String{k}}
}
func (_Version__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Version__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Version__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Version__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _Vote) FieldSMType() SignedMsgType {
	return &n.SMType
}
func (n _Vote) FieldHeight() Int {
	return &n.Height
}
func (n _Vote) FieldRound() Int {
	return &n.Round
}
func (n _Vote) FieldBlockID() BlockID {
	return &n.BlockID
}
func (n _Vote) FieldTimestamp() Time {
	return &n.Timestamp
}
func (n _Vote) FieldValidatorAddress() Address {
	return &n.ValidatorAddress
}
func (n _Vote) FieldValidatorIndex() Int {
	return &n.ValidatorIndex
}
func (n _Vote) FieldSignature() Signature {
	return &n.Signature
}

type _Vote__Maybe struct {
	m schema.Maybe
	v Vote
}
type MaybeVote = *_Vote__Maybe

func (m MaybeVote) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeVote) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeVote) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeVote) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeVote) Must() Vote {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Vote_SMType           = _String{"SMType"}
	fieldName__Vote_Height           = _String{"Height"}
	fieldName__Vote_Round            = _String{"Round"}
	fieldName__Vote_BlockID          = _String{"BlockID"}
	fieldName__Vote_Timestamp        = _String{"Timestamp"}
	fieldName__Vote_ValidatorAddress = _String{"ValidatorAddress"}
	fieldName__Vote_ValidatorIndex   = _String{"ValidatorIndex"}
	fieldName__Vote_Signature        = _String{"Signature"}
)
var _ ipld.Node = (Vote)(&_Vote{})
var _ schema.TypedNode = (Vote)(&_Vote{})

func (Vote) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Vote) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "SMType":
		return &n.SMType, nil
	case "Height":
		return &n.Height, nil
	case "Round":
		return &n.Round, nil
	case "BlockID":
		return &n.BlockID, nil
	case "Timestamp":
		return &n.Timestamp, nil
	case "ValidatorAddress":
		return &n.ValidatorAddress, nil
	case "ValidatorIndex":
		return &n.ValidatorIndex, nil
	case "Signature":
		return &n.Signature, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Vote) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Vote) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Vote"}.LookupByIndex(0)
}
func (n Vote) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Vote) MapIterator() ipld.MapIterator {
	return &_Vote__MapItr{n, 0}
}

type _Vote__MapItr struct {
	n   Vote
	idx int
}

func (itr *_Vote__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 8 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Vote_SMType
		v = &itr.n.SMType
	case 1:
		k = &fieldName__Vote_Height
		v = &itr.n.Height
	case 2:
		k = &fieldName__Vote_Round
		v = &itr.n.Round
	case 3:
		k = &fieldName__Vote_BlockID
		v = &itr.n.BlockID
	case 4:
		k = &fieldName__Vote_Timestamp
		v = &itr.n.Timestamp
	case 5:
		k = &fieldName__Vote_ValidatorAddress
		v = &itr.n.ValidatorAddress
	case 6:
		k = &fieldName__Vote_ValidatorIndex
		v = &itr.n.ValidatorIndex
	case 7:
		k = &fieldName__Vote_Signature
		v = &itr.n.Signature
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Vote__MapItr) Done() bool {
	return itr.idx >= 8
}

func (Vote) ListIterator() ipld.ListIterator {
	return nil
}
func (Vote) Length() int64 {
	return 8
}
func (Vote) IsAbsent() bool {
	return false
}
func (Vote) IsNull() bool {
	return false
}
func (Vote) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsBool()
}
func (Vote) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsInt()
}
func (Vote) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsFloat()
}
func (Vote) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsString()
}
func (Vote) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsBytes()
}
func (Vote) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsLink()
}
func (Vote) Prototype() ipld.NodePrototype {
	return _Vote__Prototype{}
}

type _Vote__Prototype struct{}

func (_Vote__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Vote__Builder
	nb.Reset()
	return &nb
}

type _Vote__Builder struct {
	_Vote__Assembler
}

func (nb *_Vote__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Vote__Builder) Reset() {
	var w _Vote
	var m schema.Maybe
	*nb = _Vote__Builder{_Vote__Assembler{w: &w, m: &m}}
}

type _Vote__Assembler struct {
	w     *_Vote
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_SMType           _SignedMsgType__Assembler
	ca_Height           _Int__Assembler
	ca_Round            _Int__Assembler
	ca_BlockID          _BlockID__Assembler
	ca_Timestamp        _Time__Assembler
	ca_ValidatorAddress _Address__Assembler
	ca_ValidatorIndex   _Int__Assembler
	ca_Signature        _Signature__Assembler
}

func (na *_Vote__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_SMType.reset()
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_BlockID.reset()
	na.ca_Timestamp.reset()
	na.ca_ValidatorAddress.reset()
	na.ca_ValidatorIndex.reset()
	na.ca_Signature.reset()
}

var (
	fieldBit__Vote_SMType           = 1 << 0
	fieldBit__Vote_Height           = 1 << 1
	fieldBit__Vote_Round            = 1 << 2
	fieldBit__Vote_BlockID          = 1 << 3
	fieldBit__Vote_Timestamp        = 1 << 4
	fieldBit__Vote_ValidatorAddress = 1 << 5
	fieldBit__Vote_ValidatorIndex   = 1 << 6
	fieldBit__Vote_Signature        = 1 << 7
	fieldBits__Vote_sufficient      = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6 + 1<<7
)

func (na *_Vote__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Vote{}
	}
	return na, nil
}
func (_Vote__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Vote"}.BeginList(0)
}
func (na *_Vote__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Vote"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Vote__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignBool(false)
}
func (_Vote__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignInt(0)
}
func (_Vote__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignFloat(0)
}
func (_Vote__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignString("")
}
func (_Vote__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignBytes(nil)
}
func (_Vote__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignLink(nil)
}
func (na *_Vote__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Vote); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Vote", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Vote__Assembler) Prototype() ipld.NodePrototype {
	return _Vote__Prototype{}
}
func (ma *_Vote__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_SMType.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Height.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Round.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Timestamp.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorAddress.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorIndex.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Signature.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Vote__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "SMType":
		if ma.s&fieldBit__Vote_SMType != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_SMType}
		}
		ma.s += fieldBit__Vote_SMType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_SMType.w = &ma.w.SMType
		ma.ca_SMType.m = &ma.cm
		return &ma.ca_SMType, nil
	case "Height":
		if ma.s&fieldBit__Vote_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Height}
		}
		ma.s += fieldBit__Vote_Height
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Vote_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Round}
		}
		ma.s += fieldBit__Vote_Round
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "BlockID":
		if ma.s&fieldBit__Vote_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_BlockID}
		}
		ma.s += fieldBit__Vote_BlockID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Timestamp":
		if ma.s&fieldBit__Vote_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Timestamp}
		}
		ma.s += fieldBit__Vote_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "ValidatorAddress":
		if ma.s&fieldBit__Vote_ValidatorAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorAddress}
		}
		ma.s += fieldBit__Vote_ValidatorAddress
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress, nil
	case "ValidatorIndex":
		if ma.s&fieldBit__Vote_ValidatorIndex != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorIndex}
		}
		ma.s += fieldBit__Vote_ValidatorIndex
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_ValidatorIndex.w = &ma.w.ValidatorIndex
		ma.ca_ValidatorIndex.m = &ma.cm
		return &ma.ca_ValidatorIndex, nil
	case "Signature":
		if ma.s&fieldBit__Vote_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Signature}
		}
		ma.s += fieldBit__Vote_Signature
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Vote", Key: &_String{k}}
}
func (ma *_Vote__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Vote__KeyAssembler)(ma)
}
func (ma *_Vote__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_SMType.w = &ma.w.SMType
		ma.ca_SMType.m = &ma.cm
		return &ma.ca_SMType
	case 1:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 2:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 3:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 5:
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress
	case 6:
		ma.ca_ValidatorIndex.w = &ma.w.ValidatorIndex
		ma.ca_ValidatorIndex.m = &ma.cm
		return &ma.ca_ValidatorIndex
	case 7:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_Vote__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Vote_sufficient != fieldBits__Vote_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Vote_SMType == 0 {
			err.Missing = append(err.Missing, "SMType")
		}
		if ma.s&fieldBit__Vote_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Vote_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Vote_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Vote_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__Vote_ValidatorAddress == 0 {
			err.Missing = append(err.Missing, "ValidatorAddress")
		}
		if ma.s&fieldBit__Vote_ValidatorIndex == 0 {
			err.Missing = append(err.Missing, "ValidatorIndex")
		}
		if ma.s&fieldBit__Vote_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Vote__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Vote__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Vote__KeyAssembler _Vote__Assembler

func (_Vote__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.BeginMap(0)
}
func (_Vote__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.BeginList(0)
}
func (na *_Vote__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignNull()
}
func (_Vote__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignBool(false)
}
func (_Vote__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignInt(0)
}
func (_Vote__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Vote__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "SMType":
		if ka.s&fieldBit__Vote_SMType != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_SMType}
		}
		ka.s += fieldBit__Vote_SMType
		ka.state = maState_expectValue
		ka.f = 0
	case "Height":
		if ka.s&fieldBit__Vote_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Height}
		}
		ka.s += fieldBit__Vote_Height
		ka.state = maState_expectValue
		ka.f = 1
	case "Round":
		if ka.s&fieldBit__Vote_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Round}
		}
		ka.s += fieldBit__Vote_Round
		ka.state = maState_expectValue
		ka.f = 2
	case "BlockID":
		if ka.s&fieldBit__Vote_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_BlockID}
		}
		ka.s += fieldBit__Vote_BlockID
		ka.state = maState_expectValue
		ka.f = 3
	case "Timestamp":
		if ka.s&fieldBit__Vote_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Timestamp}
		}
		ka.s += fieldBit__Vote_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
	case "ValidatorAddress":
		if ka.s&fieldBit__Vote_ValidatorAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorAddress}
		}
		ka.s += fieldBit__Vote_ValidatorAddress
		ka.state = maState_expectValue
		ka.f = 5
	case "ValidatorIndex":
		if ka.s&fieldBit__Vote_ValidatorIndex != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorIndex}
		}
		ka.s += fieldBit__Vote_ValidatorIndex
		ka.state = maState_expectValue
		ka.f = 6
	case "Signature":
		if ka.s&fieldBit__Vote_Signature != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Signature}
		}
		ka.s += fieldBit__Vote_Signature
		ka.state = maState_expectValue
		ka.f = 7
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Vote", Key: &_String{k}}
	}
	return nil
}
func (_Vote__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignBytes(nil)
}
func (_Vote__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Vote__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Vote__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Vote) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Vote) Representation() ipld.Node {
	return (*_Vote__Repr)(n)
}

type _Vote__Repr _Vote

var (
	fieldName__Vote_SMType_serial           = _String{"SMType"}
	fieldName__Vote_Height_serial           = _String{"Height"}
	fieldName__Vote_Round_serial            = _String{"Round"}
	fieldName__Vote_BlockID_serial          = _String{"BlockID"}
	fieldName__Vote_Timestamp_serial        = _String{"Timestamp"}
	fieldName__Vote_ValidatorAddress_serial = _String{"ValidatorAddress"}
	fieldName__Vote_ValidatorIndex_serial   = _String{"ValidatorIndex"}
	fieldName__Vote_Signature_serial        = _String{"Signature"}
)
var _ ipld.Node = &_Vote__Repr{}

func (_Vote__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Vote__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "SMType":
		return n.SMType.Representation(), nil
	case "Height":
		return n.Height.Representation(), nil
	case "Round":
		return n.Round.Representation(), nil
	case "BlockID":
		return n.BlockID.Representation(), nil
	case "Timestamp":
		return n.Timestamp.Representation(), nil
	case "ValidatorAddress":
		return n.ValidatorAddress.Representation(), nil
	case "ValidatorIndex":
		return n.ValidatorIndex.Representation(), nil
	case "Signature":
		return n.Signature.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Vote__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Vote__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.LookupByIndex(0)
}
func (n _Vote__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Vote__Repr) MapIterator() ipld.MapIterator {
	return &_Vote__ReprMapItr{n, 0}
}

type _Vote__ReprMapItr struct {
	n   *_Vote__Repr
	idx int
}

func (itr *_Vote__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 8 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Vote_SMType_serial
		v = itr.n.SMType.Representation()
	case 1:
		k = &fieldName__Vote_Height_serial
		v = itr.n.Height.Representation()
	case 2:
		k = &fieldName__Vote_Round_serial
		v = itr.n.Round.Representation()
	case 3:
		k = &fieldName__Vote_BlockID_serial
		v = itr.n.BlockID.Representation()
	case 4:
		k = &fieldName__Vote_Timestamp_serial
		v = itr.n.Timestamp.Representation()
	case 5:
		k = &fieldName__Vote_ValidatorAddress_serial
		v = itr.n.ValidatorAddress.Representation()
	case 6:
		k = &fieldName__Vote_ValidatorIndex_serial
		v = itr.n.ValidatorIndex.Representation()
	case 7:
		k = &fieldName__Vote_Signature_serial
		v = itr.n.Signature.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Vote__ReprMapItr) Done() bool {
	return itr.idx >= 8
}
func (_Vote__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Vote__Repr) Length() int64 {
	l := 8
	return int64(l)
}
func (_Vote__Repr) IsAbsent() bool {
	return false
}
func (_Vote__Repr) IsNull() bool {
	return false
}
func (_Vote__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsBool()
}
func (_Vote__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsInt()
}
func (_Vote__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsFloat()
}
func (_Vote__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsString()
}
func (_Vote__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsBytes()
}
func (_Vote__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsLink()
}
func (_Vote__Repr) Prototype() ipld.NodePrototype {
	return _Vote__ReprPrototype{}
}

type _Vote__ReprPrototype struct{}

func (_Vote__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Vote__ReprBuilder
	nb.Reset()
	return &nb
}

type _Vote__ReprBuilder struct {
	_Vote__ReprAssembler
}

func (nb *_Vote__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Vote__ReprBuilder) Reset() {
	var w _Vote
	var m schema.Maybe
	*nb = _Vote__ReprBuilder{_Vote__ReprAssembler{w: &w, m: &m}}
}

type _Vote__ReprAssembler struct {
	w     *_Vote
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_SMType           _SignedMsgType__ReprAssembler
	ca_Height           _Int__ReprAssembler
	ca_Round            _Int__ReprAssembler
	ca_BlockID          _BlockID__ReprAssembler
	ca_Timestamp        _Time__ReprAssembler
	ca_ValidatorAddress _Address__ReprAssembler
	ca_ValidatorIndex   _Int__ReprAssembler
	ca_Signature        _Signature__ReprAssembler
}

func (na *_Vote__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_SMType.reset()
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_BlockID.reset()
	na.ca_Timestamp.reset()
	na.ca_ValidatorAddress.reset()
	na.ca_ValidatorIndex.reset()
	na.ca_Signature.reset()
}
func (na *_Vote__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Vote{}
	}
	return na, nil
}
func (_Vote__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.BeginList(0)
}
func (na *_Vote__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Vote.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Vote__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignBool(false)
}
func (_Vote__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignInt(0)
}
func (_Vote__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignFloat(0)
}
func (_Vote__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignString("")
}
func (_Vote__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignBytes(nil)
}
func (_Vote__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignLink(nil)
}
func (na *_Vote__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Vote); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Vote.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Vote__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Vote__ReprPrototype{}
}
func (ma *_Vote__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Vote__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "SMType":
		if ma.s&fieldBit__Vote_SMType != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_SMType_serial}
		}
		ma.s += fieldBit__Vote_SMType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_SMType.w = &ma.w.SMType
		ma.ca_SMType.m = &ma.cm
		return &ma.ca_SMType, nil
	case "Height":
		if ma.s&fieldBit__Vote_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Height_serial}
		}
		ma.s += fieldBit__Vote_Height
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Vote_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Round_serial}
		}
		ma.s += fieldBit__Vote_Round
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "BlockID":
		if ma.s&fieldBit__Vote_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_BlockID_serial}
		}
		ma.s += fieldBit__Vote_BlockID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Timestamp":
		if ma.s&fieldBit__Vote_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Timestamp_serial}
		}
		ma.s += fieldBit__Vote_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "ValidatorAddress":
		if ma.s&fieldBit__Vote_ValidatorAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorAddress_serial}
		}
		ma.s += fieldBit__Vote_ValidatorAddress
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress, nil
	case "ValidatorIndex":
		if ma.s&fieldBit__Vote_ValidatorIndex != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorIndex_serial}
		}
		ma.s += fieldBit__Vote_ValidatorIndex
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_ValidatorIndex.w = &ma.w.ValidatorIndex
		ma.ca_ValidatorIndex.m = &ma.cm
		return &ma.ca_ValidatorIndex, nil
	case "Signature":
		if ma.s&fieldBit__Vote_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Signature_serial}
		}
		ma.s += fieldBit__Vote_Signature
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Vote.Repr", Key: &_String{k}}
}
func (ma *_Vote__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Vote__ReprKeyAssembler)(ma)
}
func (ma *_Vote__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_SMType.w = &ma.w.SMType
		ma.ca_SMType.m = &ma.cm
		return &ma.ca_SMType
	case 1:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 2:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 3:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 5:
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress
	case 6:
		ma.ca_ValidatorIndex.w = &ma.w.ValidatorIndex
		ma.ca_ValidatorIndex.m = &ma.cm
		return &ma.ca_ValidatorIndex
	case 7:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_Vote__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Vote_sufficient != fieldBits__Vote_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Vote_SMType == 0 {
			err.Missing = append(err.Missing, "SMType")
		}
		if ma.s&fieldBit__Vote_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Vote_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Vote_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Vote_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__Vote_ValidatorAddress == 0 {
			err.Missing = append(err.Missing, "ValidatorAddress")
		}
		if ma.s&fieldBit__Vote_ValidatorIndex == 0 {
			err.Missing = append(err.Missing, "ValidatorIndex")
		}
		if ma.s&fieldBit__Vote_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Vote__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Vote__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Vote__ReprKeyAssembler _Vote__ReprAssembler

func (_Vote__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Vote__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Vote__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignNull()
}
func (_Vote__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Vote__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Vote__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Vote__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "SMType":
		if ka.s&fieldBit__Vote_SMType != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_SMType_serial}
		}
		ka.s += fieldBit__Vote_SMType
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Height":
		if ka.s&fieldBit__Vote_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Height_serial}
		}
		ka.s += fieldBit__Vote_Height
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Round":
		if ka.s&fieldBit__Vote_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Round_serial}
		}
		ka.s += fieldBit__Vote_Round
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "BlockID":
		if ka.s&fieldBit__Vote_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_BlockID_serial}
		}
		ka.s += fieldBit__Vote_BlockID
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Timestamp":
		if ka.s&fieldBit__Vote_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Timestamp_serial}
		}
		ka.s += fieldBit__Vote_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "ValidatorAddress":
		if ka.s&fieldBit__Vote_ValidatorAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorAddress_serial}
		}
		ka.s += fieldBit__Vote_ValidatorAddress
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "ValidatorIndex":
		if ka.s&fieldBit__Vote_ValidatorIndex != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorIndex_serial}
		}
		ka.s += fieldBit__Vote_ValidatorIndex
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	case "Signature":
		if ka.s&fieldBit__Vote_Signature != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Signature_serial}
		}
		ka.s += fieldBit__Vote_Signature
		ka.state = maState_expectValue
		ka.f = 7
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Vote.Repr", Key: &_String{k}}
}
func (_Vote__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Vote__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Vote__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Vote__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
