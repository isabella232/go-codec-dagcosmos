package dagcosmos

// Code generated by go-ipld-prime gengo.  DO NOT EDIT.

import (
	ipld "github.com/ipld/go-ipld-prime"
	"github.com/ipld/go-ipld-prime/node/mixins"
	"github.com/ipld/go-ipld-prime/schema"
)

func (n Address) Bytes() []byte {
	return n.x
}
func (_Address__Prototype) FromBytes(v []byte) (Address, error) {
	n := _Address{v}
	return &n, nil
}

type _Address__Maybe struct {
	m schema.Maybe
	v Address
}
type MaybeAddress = *_Address__Maybe

func (m MaybeAddress) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAddress) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAddress) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAddress) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeAddress) Must() Address {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Address)(&_Address{})
var _ schema.TypedNode = (Address)(&_Address{})

func (Address) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Address) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Address"}.LookupByString("")
}
func (Address) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Address"}.LookupByNode(nil)
}
func (Address) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Address"}.LookupByIndex(0)
}
func (Address) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Address"}.LookupBySegment(seg)
}
func (Address) MapIterator() ipld.MapIterator {
	return nil
}
func (Address) ListIterator() ipld.ListIterator {
	return nil
}
func (Address) Length() int64 {
	return -1
}
func (Address) IsAbsent() bool {
	return false
}
func (Address) IsNull() bool {
	return false
}
func (Address) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Address"}.AsBool()
}
func (Address) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Address"}.AsInt()
}
func (Address) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Address"}.AsFloat()
}
func (Address) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Address"}.AsString()
}
func (n Address) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Address) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Address"}.AsLink()
}
func (Address) Prototype() ipld.NodePrototype {
	return _Address__Prototype{}
}

type _Address__Prototype struct{}

func (_Address__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Address__Builder
	nb.Reset()
	return &nb
}

type _Address__Builder struct {
	_Address__Assembler
}

func (nb *_Address__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Address__Builder) Reset() {
	var w _Address
	var m schema.Maybe
	*nb = _Address__Builder{_Address__Assembler{w: &w, m: &m}}
}

type _Address__Assembler struct {
	w *_Address
	m *schema.Maybe
}

func (na *_Address__Assembler) reset() {}
func (_Address__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Address"}.BeginMap(0)
}
func (_Address__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Address"}.BeginList(0)
}
func (na *_Address__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Address"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Address__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Address"}.AssignBool(false)
}
func (_Address__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Address"}.AssignInt(0)
}
func (_Address__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Address"}.AssignFloat(0)
}
func (_Address__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Address"}.AssignString("")
}
func (na *_Address__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Address{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Address__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Address"}.AssignLink(nil)
}
func (na *_Address__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Address); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Address__Assembler) Prototype() ipld.NodePrototype {
	return _Address__Prototype{}
}
func (Address) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Address) Representation() ipld.Node {
	return (*_Address__Repr)(n)
}

type _Address__Repr = _Address

var _ ipld.Node = &_Address__Repr{}

type _Address__ReprPrototype = _Address__Prototype
type _Address__ReprAssembler = _Address__Assembler

func (n *_Aunts) Lookup(idx int64) Hash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Aunts) LookupMaybe(idx int64) MaybeHash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Hash__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Aunts__valueAbsent = _Hash__Maybe{m: schema.Maybe_Absent}

func (n Aunts) Iterator() *Aunts__Itr {
	return &Aunts__Itr{n, 0}
}

type Aunts__Itr struct {
	n   Aunts
	idx int
}

func (itr *Aunts__Itr) Next() (idx int64, v Hash) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Aunts__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Aunts__Maybe struct {
	m schema.Maybe
	v Aunts
}
type MaybeAunts = *_Aunts__Maybe

func (m MaybeAunts) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAunts) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAunts) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAunts) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeAunts) Must() Aunts {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Aunts)(&_Aunts{})
var _ schema.TypedNode = (Aunts)(&_Aunts{})

func (Aunts) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Aunts) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Aunts"}.LookupByString("")
}
func (n Aunts) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Aunts) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Aunts) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Aunts", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Aunts) MapIterator() ipld.MapIterator {
	return nil
}
func (n Aunts) ListIterator() ipld.ListIterator {
	return &_Aunts__ListItr{n, 0}
}

type _Aunts__ListItr struct {
	n   Aunts
	idx int
}

func (itr *_Aunts__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Aunts__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Aunts) Length() int64 {
	return int64(len(n.x))
}
func (Aunts) IsAbsent() bool {
	return false
}
func (Aunts) IsNull() bool {
	return false
}
func (Aunts) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsBool()
}
func (Aunts) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsInt()
}
func (Aunts) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsFloat()
}
func (Aunts) AsString() (string, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsString()
}
func (Aunts) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsBytes()
}
func (Aunts) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Aunts"}.AsLink()
}
func (Aunts) Prototype() ipld.NodePrototype {
	return _Aunts__Prototype{}
}

type _Aunts__Prototype struct{}

func (_Aunts__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Aunts__Builder
	nb.Reset()
	return &nb
}

type _Aunts__Builder struct {
	_Aunts__Assembler
}

func (nb *_Aunts__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Aunts__Builder) Reset() {
	var w _Aunts
	var m schema.Maybe
	*nb = _Aunts__Builder{_Aunts__Assembler{w: &w, m: &m}}
}

type _Aunts__Assembler struct {
	w     *_Aunts
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__Assembler
}

func (na *_Aunts__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Aunts__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.BeginMap(0)
}
func (na *_Aunts__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Aunts{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_Aunts__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Aunts__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignBool(false)
}
func (_Aunts__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignInt(0)
}
func (_Aunts__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignFloat(0)
}
func (_Aunts__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignString("")
}
func (_Aunts__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignBytes(nil)
}
func (_Aunts__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Aunts"}.AssignLink(nil)
}
func (na *_Aunts__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Aunts); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Aunts", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Aunts__Assembler) Prototype() ipld.NodePrototype {
	return _Aunts__Prototype{}
}
func (la *_Aunts__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Aunts__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Aunts__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Aunts__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__Prototype{}
}
func (Aunts) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Aunts) Representation() ipld.Node {
	return (*_Aunts__Repr)(n)
}

type _Aunts__Repr _Aunts

var _ ipld.Node = &_Aunts__Repr{}

func (_Aunts__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Aunts__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.LookupByString("")
}
func (nr *_Aunts__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Aunts)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (nr *_Aunts__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Aunts)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (n _Aunts__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Aunts.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Aunts__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Aunts__Repr) ListIterator() ipld.ListIterator {
	return &_Aunts__ReprListItr{(Aunts)(nr), 0}
}

type _Aunts__ReprListItr _Aunts__ListItr

func (itr *_Aunts__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Aunts__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Hash).Representation(), nil
}
func (itr *_Aunts__ReprListItr) Done() bool {
	return (*_Aunts__ListItr)(itr).Done()
}

func (rn *_Aunts__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Aunts__Repr) IsAbsent() bool {
	return false
}
func (_Aunts__Repr) IsNull() bool {
	return false
}
func (_Aunts__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsBool()
}
func (_Aunts__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsInt()
}
func (_Aunts__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsFloat()
}
func (_Aunts__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsString()
}
func (_Aunts__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsBytes()
}
func (_Aunts__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Aunts.Repr"}.AsLink()
}
func (_Aunts__Repr) Prototype() ipld.NodePrototype {
	return _Aunts__ReprPrototype{}
}

type _Aunts__ReprPrototype struct{}

func (_Aunts__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Aunts__ReprBuilder
	nb.Reset()
	return &nb
}

type _Aunts__ReprBuilder struct {
	_Aunts__ReprAssembler
}

func (nb *_Aunts__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Aunts__ReprBuilder) Reset() {
	var w _Aunts
	var m schema.Maybe
	*nb = _Aunts__ReprBuilder{_Aunts__ReprAssembler{w: &w, m: &m}}
}

type _Aunts__ReprAssembler struct {
	w     *_Aunts
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__ReprAssembler
}

func (na *_Aunts__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Aunts__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.BeginMap(0)
}
func (na *_Aunts__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Aunts{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_Aunts__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Aunts.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Aunts__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignBool(false)
}
func (_Aunts__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignInt(0)
}
func (_Aunts__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignFloat(0)
}
func (_Aunts__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignString("")
}
func (_Aunts__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignBytes(nil)
}
func (_Aunts__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Aunts.Repr"}.AssignLink(nil)
}
func (na *_Aunts__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Aunts); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Aunts.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Aunts__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Aunts__ReprPrototype{}
}
func (la *_Aunts__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Aunts__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Aunts__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Aunts__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__ReprPrototype{}
}

func (n _Block) FieldHeader() Header {
	return &n.Header
}
func (n _Block) FieldData() Data {
	return &n.Data
}
func (n _Block) FieldEvidence() EvidenceData {
	return &n.Evidence
}
func (n _Block) FieldLastCommit() Commit {
	return &n.LastCommit
}

type _Block__Maybe struct {
	m schema.Maybe
	v Block
}
type MaybeBlock = *_Block__Maybe

func (m MaybeBlock) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBlock) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBlock) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBlock) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBlock) Must() Block {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Block_Header     = _String{"Header"}
	fieldName__Block_Data       = _String{"Data"}
	fieldName__Block_Evidence   = _String{"Evidence"}
	fieldName__Block_LastCommit = _String{"LastCommit"}
)
var _ ipld.Node = (Block)(&_Block{})
var _ schema.TypedNode = (Block)(&_Block{})

func (Block) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Block) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Header":
		return &n.Header, nil
	case "Data":
		return &n.Data, nil
	case "Evidence":
		return &n.Evidence, nil
	case "LastCommit":
		return &n.LastCommit, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Block) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Block) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Block"}.LookupByIndex(0)
}
func (n Block) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Block) MapIterator() ipld.MapIterator {
	return &_Block__MapItr{n, 0}
}

type _Block__MapItr struct {
	n   Block
	idx int
}

func (itr *_Block__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Block_Header
		v = &itr.n.Header
	case 1:
		k = &fieldName__Block_Data
		v = &itr.n.Data
	case 2:
		k = &fieldName__Block_Evidence
		v = &itr.n.Evidence
	case 3:
		k = &fieldName__Block_LastCommit
		v = &itr.n.LastCommit
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Block__MapItr) Done() bool {
	return itr.idx >= 4
}

func (Block) ListIterator() ipld.ListIterator {
	return nil
}
func (Block) Length() int64 {
	return 4
}
func (Block) IsAbsent() bool {
	return false
}
func (Block) IsNull() bool {
	return false
}
func (Block) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Block"}.AsBool()
}
func (Block) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Block"}.AsInt()
}
func (Block) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Block"}.AsFloat()
}
func (Block) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Block"}.AsString()
}
func (Block) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Block"}.AsBytes()
}
func (Block) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Block"}.AsLink()
}
func (Block) Prototype() ipld.NodePrototype {
	return _Block__Prototype{}
}

type _Block__Prototype struct{}

func (_Block__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Block__Builder
	nb.Reset()
	return &nb
}

type _Block__Builder struct {
	_Block__Assembler
}

func (nb *_Block__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Block__Builder) Reset() {
	var w _Block
	var m schema.Maybe
	*nb = _Block__Builder{_Block__Assembler{w: &w, m: &m}}
}

type _Block__Assembler struct {
	w     *_Block
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Header     _Header__Assembler
	ca_Data       _Data__Assembler
	ca_Evidence   _EvidenceData__Assembler
	ca_LastCommit _Commit__Assembler
}

func (na *_Block__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Header.reset()
	na.ca_Data.reset()
	na.ca_Evidence.reset()
	na.ca_LastCommit.reset()
}

var (
	fieldBit__Block_Header      = 1 << 0
	fieldBit__Block_Data        = 1 << 1
	fieldBit__Block_Evidence    = 1 << 2
	fieldBit__Block_LastCommit  = 1 << 3
	fieldBits__Block_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_Block__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Block{}
	}
	return na, nil
}
func (_Block__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Block"}.BeginList(0)
}
func (na *_Block__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Block"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Block__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignBool(false)
}
func (_Block__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignInt(0)
}
func (_Block__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignFloat(0)
}
func (_Block__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignString("")
}
func (_Block__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignBytes(nil)
}
func (_Block__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Block"}.AssignLink(nil)
}
func (na *_Block__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Block); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Block", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Block__Assembler) Prototype() ipld.NodePrototype {
	return _Block__Prototype{}
}
func (ma *_Block__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Header.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Data.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Evidence.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_LastCommit.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Block__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Header":
		if ma.s&fieldBit__Block_Header != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header}
		}
		ma.s += fieldBit__Block_Header
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header, nil
	case "Data":
		if ma.s&fieldBit__Block_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Data}
		}
		ma.s += fieldBit__Block_Data
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	case "Evidence":
		if ma.s&fieldBit__Block_Evidence != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Evidence}
		}
		ma.s += fieldBit__Block_Evidence
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence, nil
	case "LastCommit":
		if ma.s&fieldBit__Block_LastCommit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_LastCommit}
		}
		ma.s += fieldBit__Block_LastCommit
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_LastCommit.w = &ma.w.LastCommit
		ma.ca_LastCommit.m = &ma.cm
		return &ma.ca_LastCommit, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Block", Key: &_String{k}}
}
func (ma *_Block__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Block__KeyAssembler)(ma)
}
func (ma *_Block__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header
	case 1:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	case 2:
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence
	case 3:
		ma.ca_LastCommit.w = &ma.w.LastCommit
		ma.ca_LastCommit.m = &ma.cm
		return &ma.ca_LastCommit
	default:
		panic("unreachable")
	}
}
func (ma *_Block__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Block_sufficient != fieldBits__Block_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Block_Header == 0 {
			err.Missing = append(err.Missing, "Header")
		}
		if ma.s&fieldBit__Block_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		if ma.s&fieldBit__Block_Evidence == 0 {
			err.Missing = append(err.Missing, "Evidence")
		}
		if ma.s&fieldBit__Block_LastCommit == 0 {
			err.Missing = append(err.Missing, "LastCommit")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Block__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Block__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Block__KeyAssembler _Block__Assembler

func (_Block__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.BeginMap(0)
}
func (_Block__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.BeginList(0)
}
func (na *_Block__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignNull()
}
func (_Block__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignBool(false)
}
func (_Block__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignInt(0)
}
func (_Block__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Block__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Header":
		if ka.s&fieldBit__Block_Header != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header}
		}
		ka.s += fieldBit__Block_Header
		ka.state = maState_expectValue
		ka.f = 0
	case "Data":
		if ka.s&fieldBit__Block_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Data}
		}
		ka.s += fieldBit__Block_Data
		ka.state = maState_expectValue
		ka.f = 1
	case "Evidence":
		if ka.s&fieldBit__Block_Evidence != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Evidence}
		}
		ka.s += fieldBit__Block_Evidence
		ka.state = maState_expectValue
		ka.f = 2
	case "LastCommit":
		if ka.s&fieldBit__Block_LastCommit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_LastCommit}
		}
		ka.s += fieldBit__Block_LastCommit
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Block", Key: &_String{k}}
	}
	return nil
}
func (_Block__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignBytes(nil)
}
func (_Block__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Block.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Block__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Block__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Block) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Block) Representation() ipld.Node {
	return (*_Block__Repr)(n)
}

type _Block__Repr _Block

var (
	fieldName__Block_Header_serial     = _String{"Header"}
	fieldName__Block_Data_serial       = _String{"Data"}
	fieldName__Block_Evidence_serial   = _String{"Evidence"}
	fieldName__Block_LastCommit_serial = _String{"LastCommit"}
)
var _ ipld.Node = &_Block__Repr{}

func (_Block__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Block__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Header":
		return n.Header.Representation(), nil
	case "Data":
		return n.Data.Representation(), nil
	case "Evidence":
		return n.Evidence.Representation(), nil
	case "LastCommit":
		return n.LastCommit.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Block__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Block__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.LookupByIndex(0)
}
func (n _Block__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Block__Repr) MapIterator() ipld.MapIterator {
	return &_Block__ReprMapItr{n, 0}
}

type _Block__ReprMapItr struct {
	n   *_Block__Repr
	idx int
}

func (itr *_Block__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Block_Header_serial
		v = itr.n.Header.Representation()
	case 1:
		k = &fieldName__Block_Data_serial
		v = itr.n.Data.Representation()
	case 2:
		k = &fieldName__Block_Evidence_serial
		v = itr.n.Evidence.Representation()
	case 3:
		k = &fieldName__Block_LastCommit_serial
		v = itr.n.LastCommit.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Block__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_Block__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Block__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_Block__Repr) IsAbsent() bool {
	return false
}
func (_Block__Repr) IsNull() bool {
	return false
}
func (_Block__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsBool()
}
func (_Block__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsInt()
}
func (_Block__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsFloat()
}
func (_Block__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsString()
}
func (_Block__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsBytes()
}
func (_Block__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Block.Repr"}.AsLink()
}
func (_Block__Repr) Prototype() ipld.NodePrototype {
	return _Block__ReprPrototype{}
}

type _Block__ReprPrototype struct{}

func (_Block__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Block__ReprBuilder
	nb.Reset()
	return &nb
}

type _Block__ReprBuilder struct {
	_Block__ReprAssembler
}

func (nb *_Block__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Block__ReprBuilder) Reset() {
	var w _Block
	var m schema.Maybe
	*nb = _Block__ReprBuilder{_Block__ReprAssembler{w: &w, m: &m}}
}

type _Block__ReprAssembler struct {
	w     *_Block
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Header     _Header__ReprAssembler
	ca_Data       _Data__ReprAssembler
	ca_Evidence   _EvidenceData__ReprAssembler
	ca_LastCommit _Commit__ReprAssembler
}

func (na *_Block__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Header.reset()
	na.ca_Data.reset()
	na.ca_Evidence.reset()
	na.ca_LastCommit.reset()
}
func (na *_Block__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Block{}
	}
	return na, nil
}
func (_Block__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.BeginList(0)
}
func (na *_Block__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Block.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Block__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignBool(false)
}
func (_Block__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignInt(0)
}
func (_Block__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignFloat(0)
}
func (_Block__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignString("")
}
func (_Block__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignBytes(nil)
}
func (_Block__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Block.Repr"}.AssignLink(nil)
}
func (na *_Block__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Block); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Block.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Block__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Block__ReprPrototype{}
}
func (ma *_Block__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Block__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Header":
		if ma.s&fieldBit__Block_Header != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header_serial}
		}
		ma.s += fieldBit__Block_Header
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header, nil
	case "Data":
		if ma.s&fieldBit__Block_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Data_serial}
		}
		ma.s += fieldBit__Block_Data
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	case "Evidence":
		if ma.s&fieldBit__Block_Evidence != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Evidence_serial}
		}
		ma.s += fieldBit__Block_Evidence
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence, nil
	case "LastCommit":
		if ma.s&fieldBit__Block_LastCommit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_LastCommit_serial}
		}
		ma.s += fieldBit__Block_LastCommit
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_LastCommit.w = &ma.w.LastCommit
		ma.ca_LastCommit.m = &ma.cm
		return &ma.ca_LastCommit, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Block.Repr", Key: &_String{k}}
}
func (ma *_Block__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Block__ReprKeyAssembler)(ma)
}
func (ma *_Block__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header
	case 1:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	case 2:
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence
	case 3:
		ma.ca_LastCommit.w = &ma.w.LastCommit
		ma.ca_LastCommit.m = &ma.cm
		return &ma.ca_LastCommit
	default:
		panic("unreachable")
	}
}
func (ma *_Block__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Block_sufficient != fieldBits__Block_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Block_Header == 0 {
			err.Missing = append(err.Missing, "Header")
		}
		if ma.s&fieldBit__Block_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		if ma.s&fieldBit__Block_Evidence == 0 {
			err.Missing = append(err.Missing, "Evidence")
		}
		if ma.s&fieldBit__Block_LastCommit == 0 {
			err.Missing = append(err.Missing, "LastCommit")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Block__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Block__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Block__ReprKeyAssembler _Block__ReprAssembler

func (_Block__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Block__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Block__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignNull()
}
func (_Block__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Block__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Block__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Block__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Header":
		if ka.s&fieldBit__Block_Header != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header_serial}
		}
		ka.s += fieldBit__Block_Header
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Data":
		if ka.s&fieldBit__Block_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Data_serial}
		}
		ka.s += fieldBit__Block_Data
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Evidence":
		if ka.s&fieldBit__Block_Evidence != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Evidence_serial}
		}
		ka.s += fieldBit__Block_Evidence
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "LastCommit":
		if ka.s&fieldBit__Block_LastCommit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_LastCommit_serial}
		}
		ka.s += fieldBit__Block_LastCommit
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Block.Repr", Key: &_String{k}}
}
func (_Block__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Block__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Block.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Block__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Block__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _BlockID) FieldHash() Link {
	return &n.Hash
}
func (n _BlockID) FieldPartSetHeader() PartSetHeader {
	return &n.PartSetHeader
}

type _BlockID__Maybe struct {
	m schema.Maybe
	v BlockID
}
type MaybeBlockID = *_BlockID__Maybe

func (m MaybeBlockID) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBlockID) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBlockID) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBlockID) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBlockID) Must() BlockID {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__BlockID_Hash          = _String{"Hash"}
	fieldName__BlockID_PartSetHeader = _String{"PartSetHeader"}
)
var _ ipld.Node = (BlockID)(&_BlockID{})
var _ schema.TypedNode = (BlockID)(&_BlockID{})

func (BlockID) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n BlockID) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Hash":
		return &n.Hash, nil
	case "PartSetHeader":
		return &n.PartSetHeader, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n BlockID) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (BlockID) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.BlockID"}.LookupByIndex(0)
}
func (n BlockID) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n BlockID) MapIterator() ipld.MapIterator {
	return &_BlockID__MapItr{n, 0}
}

type _BlockID__MapItr struct {
	n   BlockID
	idx int
}

func (itr *_BlockID__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__BlockID_Hash
		v = &itr.n.Hash
	case 1:
		k = &fieldName__BlockID_PartSetHeader
		v = &itr.n.PartSetHeader
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_BlockID__MapItr) Done() bool {
	return itr.idx >= 2
}

func (BlockID) ListIterator() ipld.ListIterator {
	return nil
}
func (BlockID) Length() int64 {
	return 2
}
func (BlockID) IsAbsent() bool {
	return false
}
func (BlockID) IsNull() bool {
	return false
}
func (BlockID) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsBool()
}
func (BlockID) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsInt()
}
func (BlockID) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsFloat()
}
func (BlockID) AsString() (string, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsString()
}
func (BlockID) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsBytes()
}
func (BlockID) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.BlockID"}.AsLink()
}
func (BlockID) Prototype() ipld.NodePrototype {
	return _BlockID__Prototype{}
}

type _BlockID__Prototype struct{}

func (_BlockID__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _BlockID__Builder
	nb.Reset()
	return &nb
}

type _BlockID__Builder struct {
	_BlockID__Assembler
}

func (nb *_BlockID__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_BlockID__Builder) Reset() {
	var w _BlockID
	var m schema.Maybe
	*nb = _BlockID__Builder{_BlockID__Assembler{w: &w, m: &m}}
}

type _BlockID__Assembler struct {
	w     *_BlockID
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm               schema.Maybe
	ca_Hash          _Link__Assembler
	ca_PartSetHeader _PartSetHeader__Assembler
}

func (na *_BlockID__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Hash.reset()
	na.ca_PartSetHeader.reset()
}

var (
	fieldBit__BlockID_Hash          = 1 << 0
	fieldBit__BlockID_PartSetHeader = 1 << 1
	fieldBits__BlockID_sufficient   = 0 + 1<<0 + 1<<1
)

func (na *_BlockID__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_BlockID{}
	}
	return na, nil
}
func (_BlockID__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.BeginList(0)
}
func (na *_BlockID__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_BlockID__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignBool(false)
}
func (_BlockID__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignInt(0)
}
func (_BlockID__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignFloat(0)
}
func (_BlockID__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignString("")
}
func (_BlockID__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignBytes(nil)
}
func (_BlockID__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.BlockID"}.AssignLink(nil)
}
func (na *_BlockID__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_BlockID); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.BlockID", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_BlockID__Assembler) Prototype() ipld.NodePrototype {
	return _BlockID__Prototype{}
}
func (ma *_BlockID__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Hash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PartSetHeader.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_BlockID__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Hash":
		if ma.s&fieldBit__BlockID_Hash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_Hash}
		}
		ma.s += fieldBit__BlockID_Hash
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash, nil
	case "PartSetHeader":
		if ma.s&fieldBit__BlockID_PartSetHeader != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_PartSetHeader}
		}
		ma.s += fieldBit__BlockID_PartSetHeader
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PartSetHeader.w = &ma.w.PartSetHeader
		ma.ca_PartSetHeader.m = &ma.cm
		return &ma.ca_PartSetHeader, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockID", Key: &_String{k}}
}
func (ma *_BlockID__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_BlockID__KeyAssembler)(ma)
}
func (ma *_BlockID__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash
	case 1:
		ma.ca_PartSetHeader.w = &ma.w.PartSetHeader
		ma.ca_PartSetHeader.m = &ma.cm
		return &ma.ca_PartSetHeader
	default:
		panic("unreachable")
	}
}
func (ma *_BlockID__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__BlockID_sufficient != fieldBits__BlockID_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__BlockID_Hash == 0 {
			err.Missing = append(err.Missing, "Hash")
		}
		if ma.s&fieldBit__BlockID_PartSetHeader == 0 {
			err.Missing = append(err.Missing, "PartSetHeader")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_BlockID__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_BlockID__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _BlockID__KeyAssembler _BlockID__Assembler

func (_BlockID__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.BeginMap(0)
}
func (_BlockID__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.BeginList(0)
}
func (na *_BlockID__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignNull()
}
func (_BlockID__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignBool(false)
}
func (_BlockID__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignInt(0)
}
func (_BlockID__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignFloat(0)
}
func (ka *_BlockID__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Hash":
		if ka.s&fieldBit__BlockID_Hash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_Hash}
		}
		ka.s += fieldBit__BlockID_Hash
		ka.state = maState_expectValue
		ka.f = 0
	case "PartSetHeader":
		if ka.s&fieldBit__BlockID_PartSetHeader != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_PartSetHeader}
		}
		ka.s += fieldBit__BlockID_PartSetHeader
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockID", Key: &_String{k}}
	}
	return nil
}
func (_BlockID__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignBytes(nil)
}
func (_BlockID__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.KeyAssembler"}.AssignLink(nil)
}
func (ka *_BlockID__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_BlockID__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (BlockID) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n BlockID) Representation() ipld.Node {
	return (*_BlockID__Repr)(n)
}

type _BlockID__Repr _BlockID

var (
	fieldName__BlockID_Hash_serial          = _String{"Hash"}
	fieldName__BlockID_PartSetHeader_serial = _String{"PartSetHeader"}
)
var _ ipld.Node = &_BlockID__Repr{}

func (_BlockID__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_BlockID__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Hash":
		return n.Hash.Representation(), nil
	case "PartSetHeader":
		return n.PartSetHeader.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_BlockID__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_BlockID__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.LookupByIndex(0)
}
func (n _BlockID__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_BlockID__Repr) MapIterator() ipld.MapIterator {
	return &_BlockID__ReprMapItr{n, 0}
}

type _BlockID__ReprMapItr struct {
	n   *_BlockID__Repr
	idx int
}

func (itr *_BlockID__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__BlockID_Hash_serial
		v = itr.n.Hash.Representation()
	case 1:
		k = &fieldName__BlockID_PartSetHeader_serial
		v = itr.n.PartSetHeader.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_BlockID__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_BlockID__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_BlockID__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_BlockID__Repr) IsAbsent() bool {
	return false
}
func (_BlockID__Repr) IsNull() bool {
	return false
}
func (_BlockID__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsBool()
}
func (_BlockID__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsInt()
}
func (_BlockID__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsFloat()
}
func (_BlockID__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsString()
}
func (_BlockID__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsBytes()
}
func (_BlockID__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.BlockID.Repr"}.AsLink()
}
func (_BlockID__Repr) Prototype() ipld.NodePrototype {
	return _BlockID__ReprPrototype{}
}

type _BlockID__ReprPrototype struct{}

func (_BlockID__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _BlockID__ReprBuilder
	nb.Reset()
	return &nb
}

type _BlockID__ReprBuilder struct {
	_BlockID__ReprAssembler
}

func (nb *_BlockID__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_BlockID__ReprBuilder) Reset() {
	var w _BlockID
	var m schema.Maybe
	*nb = _BlockID__ReprBuilder{_BlockID__ReprAssembler{w: &w, m: &m}}
}

type _BlockID__ReprAssembler struct {
	w     *_BlockID
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm               schema.Maybe
	ca_Hash          _Link__ReprAssembler
	ca_PartSetHeader _PartSetHeader__ReprAssembler
}

func (na *_BlockID__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Hash.reset()
	na.ca_PartSetHeader.reset()
}
func (na *_BlockID__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_BlockID{}
	}
	return na, nil
}
func (_BlockID__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.BeginList(0)
}
func (na *_BlockID__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.BlockID.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_BlockID__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignBool(false)
}
func (_BlockID__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignInt(0)
}
func (_BlockID__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignFloat(0)
}
func (_BlockID__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignString("")
}
func (_BlockID__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignBytes(nil)
}
func (_BlockID__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.BlockID.Repr"}.AssignLink(nil)
}
func (na *_BlockID__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_BlockID); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.BlockID.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_BlockID__ReprAssembler) Prototype() ipld.NodePrototype {
	return _BlockID__ReprPrototype{}
}
func (ma *_BlockID__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_BlockID__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Hash":
		if ma.s&fieldBit__BlockID_Hash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_Hash_serial}
		}
		ma.s += fieldBit__BlockID_Hash
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash, nil
	case "PartSetHeader":
		if ma.s&fieldBit__BlockID_PartSetHeader != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_PartSetHeader_serial}
		}
		ma.s += fieldBit__BlockID_PartSetHeader
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PartSetHeader.w = &ma.w.PartSetHeader
		ma.ca_PartSetHeader.m = &ma.cm
		return &ma.ca_PartSetHeader, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockID.Repr", Key: &_String{k}}
}
func (ma *_BlockID__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_BlockID__ReprKeyAssembler)(ma)
}
func (ma *_BlockID__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash
	case 1:
		ma.ca_PartSetHeader.w = &ma.w.PartSetHeader
		ma.ca_PartSetHeader.m = &ma.cm
		return &ma.ca_PartSetHeader
	default:
		panic("unreachable")
	}
}
func (ma *_BlockID__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__BlockID_sufficient != fieldBits__BlockID_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__BlockID_Hash == 0 {
			err.Missing = append(err.Missing, "Hash")
		}
		if ma.s&fieldBit__BlockID_PartSetHeader == 0 {
			err.Missing = append(err.Missing, "PartSetHeader")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_BlockID__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_BlockID__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _BlockID__ReprKeyAssembler _BlockID__ReprAssembler

func (_BlockID__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.BeginMap(0)
}
func (_BlockID__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_BlockID__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignNull()
}
func (_BlockID__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignBool(false)
}
func (_BlockID__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignInt(0)
}
func (_BlockID__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_BlockID__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Hash":
		if ka.s&fieldBit__BlockID_Hash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_Hash_serial}
		}
		ka.s += fieldBit__BlockID_Hash
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "PartSetHeader":
		if ka.s&fieldBit__BlockID_PartSetHeader != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockID_PartSetHeader_serial}
		}
		ka.s += fieldBit__BlockID_PartSetHeader
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockID.Repr", Key: &_String{k}}
}
func (_BlockID__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_BlockID__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.BlockID.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_BlockID__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_BlockID__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n BlockIDFlag) Int() int64 {
	return n.x
}
func (_BlockIDFlag__Prototype) FromInt(v int64) (BlockIDFlag, error) {
	n := _BlockIDFlag{v}
	return &n, nil
}

type _BlockIDFlag__Maybe struct {
	m schema.Maybe
	v BlockIDFlag
}
type MaybeBlockIDFlag = *_BlockIDFlag__Maybe

func (m MaybeBlockIDFlag) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBlockIDFlag) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBlockIDFlag) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBlockIDFlag) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBlockIDFlag) Must() BlockIDFlag {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (BlockIDFlag)(&_BlockIDFlag{})
var _ schema.TypedNode = (BlockIDFlag)(&_BlockIDFlag{})

func (BlockIDFlag) Kind() ipld.Kind {
	return ipld.Kind_Int
}
func (BlockIDFlag) LookupByString(string) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.LookupByString("")
}
func (BlockIDFlag) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.LookupByNode(nil)
}
func (BlockIDFlag) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.LookupByIndex(0)
}
func (BlockIDFlag) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.LookupBySegment(seg)
}
func (BlockIDFlag) MapIterator() ipld.MapIterator {
	return nil
}
func (BlockIDFlag) ListIterator() ipld.ListIterator {
	return nil
}
func (BlockIDFlag) Length() int64 {
	return -1
}
func (BlockIDFlag) IsAbsent() bool {
	return false
}
func (BlockIDFlag) IsNull() bool {
	return false
}
func (BlockIDFlag) AsBool() (bool, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.AsBool()
}
func (n BlockIDFlag) AsInt() (int64, error) {
	return n.x, nil
}
func (BlockIDFlag) AsFloat() (float64, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.AsFloat()
}
func (BlockIDFlag) AsString() (string, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.AsString()
}
func (BlockIDFlag) AsBytes() ([]byte, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.AsBytes()
}
func (BlockIDFlag) AsLink() (ipld.Link, error) {
	return mixins.Int{"dagcosmos.BlockIDFlag"}.AsLink()
}
func (BlockIDFlag) Prototype() ipld.NodePrototype {
	return _BlockIDFlag__Prototype{}
}

type _BlockIDFlag__Prototype struct{}

func (_BlockIDFlag__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _BlockIDFlag__Builder
	nb.Reset()
	return &nb
}

type _BlockIDFlag__Builder struct {
	_BlockIDFlag__Assembler
}

func (nb *_BlockIDFlag__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_BlockIDFlag__Builder) Reset() {
	var w _BlockIDFlag
	var m schema.Maybe
	*nb = _BlockIDFlag__Builder{_BlockIDFlag__Assembler{w: &w, m: &m}}
}

type _BlockIDFlag__Assembler struct {
	w *_BlockIDFlag
	m *schema.Maybe
}

func (na *_BlockIDFlag__Assembler) reset() {}
func (_BlockIDFlag__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.BeginMap(0)
}
func (_BlockIDFlag__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.BeginList(0)
}
func (na *_BlockIDFlag__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_BlockIDFlag__Assembler) AssignBool(bool) error {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignBool(false)
}
func (na *_BlockIDFlag__Assembler) AssignInt(v int64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_BlockIDFlag{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_BlockIDFlag__Assembler) AssignFloat(float64) error {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignFloat(0)
}
func (_BlockIDFlag__Assembler) AssignString(string) error {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignString("")
}
func (_BlockIDFlag__Assembler) AssignBytes([]byte) error {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignBytes(nil)
}
func (_BlockIDFlag__Assembler) AssignLink(ipld.Link) error {
	return mixins.IntAssembler{"dagcosmos.BlockIDFlag"}.AssignLink(nil)
}
func (na *_BlockIDFlag__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_BlockIDFlag); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsInt(); err != nil {
		return err
	} else {
		return na.AssignInt(v2)
	}
}
func (_BlockIDFlag__Assembler) Prototype() ipld.NodePrototype {
	return _BlockIDFlag__Prototype{}
}
func (BlockIDFlag) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n BlockIDFlag) Representation() ipld.Node {
	return (*_BlockIDFlag__Repr)(n)
}

type _BlockIDFlag__Repr = _BlockIDFlag

var _ ipld.Node = &_BlockIDFlag__Repr{}

type _BlockIDFlag__ReprPrototype = _BlockIDFlag__Prototype
type _BlockIDFlag__ReprAssembler = _BlockIDFlag__Assembler

func (n _BlockParams) FieldMaxBytes() Int {
	return &n.MaxBytes
}
func (n _BlockParams) FieldMaxGas() Int {
	return &n.MaxGas
}

type _BlockParams__Maybe struct {
	m schema.Maybe
	v BlockParams
}
type MaybeBlockParams = *_BlockParams__Maybe

func (m MaybeBlockParams) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBlockParams) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBlockParams) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBlockParams) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBlockParams) Must() BlockParams {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__BlockParams_MaxBytes = _String{"MaxBytes"}
	fieldName__BlockParams_MaxGas   = _String{"MaxGas"}
)
var _ ipld.Node = (BlockParams)(&_BlockParams{})
var _ schema.TypedNode = (BlockParams)(&_BlockParams{})

func (BlockParams) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n BlockParams) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "MaxBytes":
		return &n.MaxBytes, nil
	case "MaxGas":
		return &n.MaxGas, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n BlockParams) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (BlockParams) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.BlockParams"}.LookupByIndex(0)
}
func (n BlockParams) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n BlockParams) MapIterator() ipld.MapIterator {
	return &_BlockParams__MapItr{n, 0}
}

type _BlockParams__MapItr struct {
	n   BlockParams
	idx int
}

func (itr *_BlockParams__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__BlockParams_MaxBytes
		v = &itr.n.MaxBytes
	case 1:
		k = &fieldName__BlockParams_MaxGas
		v = &itr.n.MaxGas
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_BlockParams__MapItr) Done() bool {
	return itr.idx >= 2
}

func (BlockParams) ListIterator() ipld.ListIterator {
	return nil
}
func (BlockParams) Length() int64 {
	return 2
}
func (BlockParams) IsAbsent() bool {
	return false
}
func (BlockParams) IsNull() bool {
	return false
}
func (BlockParams) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.BlockParams"}.AsBool()
}
func (BlockParams) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.BlockParams"}.AsInt()
}
func (BlockParams) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.BlockParams"}.AsFloat()
}
func (BlockParams) AsString() (string, error) {
	return mixins.Map{"dagcosmos.BlockParams"}.AsString()
}
func (BlockParams) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.BlockParams"}.AsBytes()
}
func (BlockParams) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.BlockParams"}.AsLink()
}
func (BlockParams) Prototype() ipld.NodePrototype {
	return _BlockParams__Prototype{}
}

type _BlockParams__Prototype struct{}

func (_BlockParams__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _BlockParams__Builder
	nb.Reset()
	return &nb
}

type _BlockParams__Builder struct {
	_BlockParams__Assembler
}

func (nb *_BlockParams__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_BlockParams__Builder) Reset() {
	var w _BlockParams
	var m schema.Maybe
	*nb = _BlockParams__Builder{_BlockParams__Assembler{w: &w, m: &m}}
}

type _BlockParams__Assembler struct {
	w     *_BlockParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm          schema.Maybe
	ca_MaxBytes _Int__Assembler
	ca_MaxGas   _Int__Assembler
}

func (na *_BlockParams__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_MaxBytes.reset()
	na.ca_MaxGas.reset()
}

var (
	fieldBit__BlockParams_MaxBytes    = 1 << 0
	fieldBit__BlockParams_MaxGas      = 1 << 1
	fieldBits__BlockParams_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_BlockParams__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_BlockParams{}
	}
	return na, nil
}
func (_BlockParams__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.BlockParams"}.BeginList(0)
}
func (na *_BlockParams__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.BlockParams"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_BlockParams__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams"}.AssignBool(false)
}
func (_BlockParams__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams"}.AssignInt(0)
}
func (_BlockParams__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams"}.AssignFloat(0)
}
func (_BlockParams__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams"}.AssignString("")
}
func (_BlockParams__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams"}.AssignBytes(nil)
}
func (_BlockParams__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams"}.AssignLink(nil)
}
func (na *_BlockParams__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_BlockParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.BlockParams", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_BlockParams__Assembler) Prototype() ipld.NodePrototype {
	return _BlockParams__Prototype{}
}
func (ma *_BlockParams__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_MaxBytes.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_MaxGas.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_BlockParams__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "MaxBytes":
		if ma.s&fieldBit__BlockParams_MaxBytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockParams_MaxBytes}
		}
		ma.s += fieldBit__BlockParams_MaxBytes
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_MaxBytes.w = &ma.w.MaxBytes
		ma.ca_MaxBytes.m = &ma.cm
		return &ma.ca_MaxBytes, nil
	case "MaxGas":
		if ma.s&fieldBit__BlockParams_MaxGas != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockParams_MaxGas}
		}
		ma.s += fieldBit__BlockParams_MaxGas
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_MaxGas.w = &ma.w.MaxGas
		ma.ca_MaxGas.m = &ma.cm
		return &ma.ca_MaxGas, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockParams", Key: &_String{k}}
}
func (ma *_BlockParams__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_BlockParams__KeyAssembler)(ma)
}
func (ma *_BlockParams__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_MaxBytes.w = &ma.w.MaxBytes
		ma.ca_MaxBytes.m = &ma.cm
		return &ma.ca_MaxBytes
	case 1:
		ma.ca_MaxGas.w = &ma.w.MaxGas
		ma.ca_MaxGas.m = &ma.cm
		return &ma.ca_MaxGas
	default:
		panic("unreachable")
	}
}
func (ma *_BlockParams__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__BlockParams_sufficient != fieldBits__BlockParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__BlockParams_MaxBytes == 0 {
			err.Missing = append(err.Missing, "MaxBytes")
		}
		if ma.s&fieldBit__BlockParams_MaxGas == 0 {
			err.Missing = append(err.Missing, "MaxGas")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_BlockParams__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_BlockParams__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _BlockParams__KeyAssembler _BlockParams__Assembler

func (_BlockParams__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockParams.KeyAssembler"}.BeginMap(0)
}
func (_BlockParams__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockParams.KeyAssembler"}.BeginList(0)
}
func (na *_BlockParams__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.KeyAssembler"}.AssignNull()
}
func (_BlockParams__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.KeyAssembler"}.AssignBool(false)
}
func (_BlockParams__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.KeyAssembler"}.AssignInt(0)
}
func (_BlockParams__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.KeyAssembler"}.AssignFloat(0)
}
func (ka *_BlockParams__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "MaxBytes":
		if ka.s&fieldBit__BlockParams_MaxBytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockParams_MaxBytes}
		}
		ka.s += fieldBit__BlockParams_MaxBytes
		ka.state = maState_expectValue
		ka.f = 0
	case "MaxGas":
		if ka.s&fieldBit__BlockParams_MaxGas != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockParams_MaxGas}
		}
		ka.s += fieldBit__BlockParams_MaxGas
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockParams", Key: &_String{k}}
	}
	return nil
}
func (_BlockParams__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.KeyAssembler"}.AssignBytes(nil)
}
func (_BlockParams__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.KeyAssembler"}.AssignLink(nil)
}
func (ka *_BlockParams__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_BlockParams__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (BlockParams) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n BlockParams) Representation() ipld.Node {
	return (*_BlockParams__Repr)(n)
}

type _BlockParams__Repr _BlockParams

var (
	fieldName__BlockParams_MaxBytes_serial = _String{"MaxBytes"}
	fieldName__BlockParams_MaxGas_serial   = _String{"MaxGas"}
)
var _ ipld.Node = &_BlockParams__Repr{}

func (_BlockParams__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_BlockParams__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "MaxBytes":
		return n.MaxBytes.Representation(), nil
	case "MaxGas":
		return n.MaxGas.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_BlockParams__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_BlockParams__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.BlockParams.Repr"}.LookupByIndex(0)
}
func (n _BlockParams__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_BlockParams__Repr) MapIterator() ipld.MapIterator {
	return &_BlockParams__ReprMapItr{n, 0}
}

type _BlockParams__ReprMapItr struct {
	n   *_BlockParams__Repr
	idx int
}

func (itr *_BlockParams__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__BlockParams_MaxBytes_serial
		v = itr.n.MaxBytes.Representation()
	case 1:
		k = &fieldName__BlockParams_MaxGas_serial
		v = itr.n.MaxGas.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_BlockParams__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_BlockParams__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_BlockParams__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_BlockParams__Repr) IsAbsent() bool {
	return false
}
func (_BlockParams__Repr) IsNull() bool {
	return false
}
func (_BlockParams__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.BlockParams.Repr"}.AsBool()
}
func (_BlockParams__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.BlockParams.Repr"}.AsInt()
}
func (_BlockParams__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.BlockParams.Repr"}.AsFloat()
}
func (_BlockParams__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.BlockParams.Repr"}.AsString()
}
func (_BlockParams__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.BlockParams.Repr"}.AsBytes()
}
func (_BlockParams__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.BlockParams.Repr"}.AsLink()
}
func (_BlockParams__Repr) Prototype() ipld.NodePrototype {
	return _BlockParams__ReprPrototype{}
}

type _BlockParams__ReprPrototype struct{}

func (_BlockParams__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _BlockParams__ReprBuilder
	nb.Reset()
	return &nb
}

type _BlockParams__ReprBuilder struct {
	_BlockParams__ReprAssembler
}

func (nb *_BlockParams__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_BlockParams__ReprBuilder) Reset() {
	var w _BlockParams
	var m schema.Maybe
	*nb = _BlockParams__ReprBuilder{_BlockParams__ReprAssembler{w: &w, m: &m}}
}

type _BlockParams__ReprAssembler struct {
	w     *_BlockParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm          schema.Maybe
	ca_MaxBytes _Int__ReprAssembler
	ca_MaxGas   _Int__ReprAssembler
}

func (na *_BlockParams__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_MaxBytes.reset()
	na.ca_MaxGas.reset()
}
func (na *_BlockParams__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_BlockParams{}
	}
	return na, nil
}
func (_BlockParams__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.BlockParams.Repr"}.BeginList(0)
}
func (na *_BlockParams__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.BlockParams.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_BlockParams__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams.Repr"}.AssignBool(false)
}
func (_BlockParams__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams.Repr"}.AssignInt(0)
}
func (_BlockParams__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams.Repr"}.AssignFloat(0)
}
func (_BlockParams__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams.Repr"}.AssignString("")
}
func (_BlockParams__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams.Repr"}.AssignBytes(nil)
}
func (_BlockParams__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.BlockParams.Repr"}.AssignLink(nil)
}
func (na *_BlockParams__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_BlockParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.BlockParams.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_BlockParams__ReprAssembler) Prototype() ipld.NodePrototype {
	return _BlockParams__ReprPrototype{}
}
func (ma *_BlockParams__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_BlockParams__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "MaxBytes":
		if ma.s&fieldBit__BlockParams_MaxBytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockParams_MaxBytes_serial}
		}
		ma.s += fieldBit__BlockParams_MaxBytes
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_MaxBytes.w = &ma.w.MaxBytes
		ma.ca_MaxBytes.m = &ma.cm
		return &ma.ca_MaxBytes, nil
	case "MaxGas":
		if ma.s&fieldBit__BlockParams_MaxGas != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__BlockParams_MaxGas_serial}
		}
		ma.s += fieldBit__BlockParams_MaxGas
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_MaxGas.w = &ma.w.MaxGas
		ma.ca_MaxGas.m = &ma.cm
		return &ma.ca_MaxGas, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockParams.Repr", Key: &_String{k}}
}
func (ma *_BlockParams__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_BlockParams__ReprKeyAssembler)(ma)
}
func (ma *_BlockParams__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_MaxBytes.w = &ma.w.MaxBytes
		ma.ca_MaxBytes.m = &ma.cm
		return &ma.ca_MaxBytes
	case 1:
		ma.ca_MaxGas.w = &ma.w.MaxGas
		ma.ca_MaxGas.m = &ma.cm
		return &ma.ca_MaxGas
	default:
		panic("unreachable")
	}
}
func (ma *_BlockParams__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__BlockParams_sufficient != fieldBits__BlockParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__BlockParams_MaxBytes == 0 {
			err.Missing = append(err.Missing, "MaxBytes")
		}
		if ma.s&fieldBit__BlockParams_MaxGas == 0 {
			err.Missing = append(err.Missing, "MaxGas")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_BlockParams__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_BlockParams__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _BlockParams__ReprKeyAssembler _BlockParams__ReprAssembler

func (_BlockParams__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockParams.Repr.KeyAssembler"}.BeginMap(0)
}
func (_BlockParams__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.BlockParams.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_BlockParams__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.Repr.KeyAssembler"}.AssignNull()
}
func (_BlockParams__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.Repr.KeyAssembler"}.AssignBool(false)
}
func (_BlockParams__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.Repr.KeyAssembler"}.AssignInt(0)
}
func (_BlockParams__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_BlockParams__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "MaxBytes":
		if ka.s&fieldBit__BlockParams_MaxBytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockParams_MaxBytes_serial}
		}
		ka.s += fieldBit__BlockParams_MaxBytes
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "MaxGas":
		if ka.s&fieldBit__BlockParams_MaxGas != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__BlockParams_MaxGas_serial}
		}
		ka.s += fieldBit__BlockParams_MaxGas
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.BlockParams.Repr", Key: &_String{k}}
}
func (_BlockParams__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_BlockParams__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.BlockParams.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_BlockParams__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_BlockParams__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Bytes) Bytes() []byte {
	return n.x
}
func (_Bytes__Prototype) FromBytes(v []byte) (Bytes, error) {
	n := _Bytes{v}
	return &n, nil
}

type _Bytes__Maybe struct {
	m schema.Maybe
	v Bytes
}
type MaybeBytes = *_Bytes__Maybe

func (m MaybeBytes) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBytes) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBytes) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBytes) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBytes) Must() Bytes {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Bytes)(&_Bytes{})
var _ schema.TypedNode = (Bytes)(&_Bytes{})

func (Bytes) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Bytes) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.LookupByString("")
}
func (Bytes) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.LookupByNode(nil)
}
func (Bytes) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.LookupByIndex(0)
}
func (Bytes) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.LookupBySegment(seg)
}
func (Bytes) MapIterator() ipld.MapIterator {
	return nil
}
func (Bytes) ListIterator() ipld.ListIterator {
	return nil
}
func (Bytes) Length() int64 {
	return -1
}
func (Bytes) IsAbsent() bool {
	return false
}
func (Bytes) IsNull() bool {
	return false
}
func (Bytes) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.AsBool()
}
func (Bytes) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.AsInt()
}
func (Bytes) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.AsFloat()
}
func (Bytes) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.AsString()
}
func (n Bytes) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Bytes) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Bytes"}.AsLink()
}
func (Bytes) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}

type _Bytes__Prototype struct{}

func (_Bytes__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Bytes__Builder
	nb.Reset()
	return &nb
}

type _Bytes__Builder struct {
	_Bytes__Assembler
}

func (nb *_Bytes__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Bytes__Builder) Reset() {
	var w _Bytes
	var m schema.Maybe
	*nb = _Bytes__Builder{_Bytes__Assembler{w: &w, m: &m}}
}

type _Bytes__Assembler struct {
	w *_Bytes
	m *schema.Maybe
}

func (na *_Bytes__Assembler) reset() {}
func (_Bytes__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.BeginMap(0)
}
func (_Bytes__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.BeginList(0)
}
func (na *_Bytes__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Bytes__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignBool(false)
}
func (_Bytes__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignInt(0)
}
func (_Bytes__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignFloat(0)
}
func (_Bytes__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignString("")
}
func (na *_Bytes__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Bytes{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Bytes__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Bytes"}.AssignLink(nil)
}
func (na *_Bytes__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Bytes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Bytes__Assembler) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}
func (Bytes) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Bytes) Representation() ipld.Node {
	return (*_Bytes__Repr)(n)
}

type _Bytes__Repr = _Bytes

var _ ipld.Node = &_Bytes__Repr{}

type _Bytes__ReprPrototype = _Bytes__Prototype
type _Bytes__ReprAssembler = _Bytes__Assembler

func (n _Commit) FieldHeight() Int {
	return &n.Height
}
func (n _Commit) FieldRound() Int {
	return &n.Round
}
func (n _Commit) FieldBlockID() BlockID {
	return &n.BlockID
}
func (n _Commit) FieldSignatures() Signatures {
	return &n.Signatures
}

type _Commit__Maybe struct {
	m schema.Maybe
	v Commit
}
type MaybeCommit = *_Commit__Maybe

func (m MaybeCommit) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeCommit) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeCommit) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeCommit) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeCommit) Must() Commit {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Commit_Height     = _String{"Height"}
	fieldName__Commit_Round      = _String{"Round"}
	fieldName__Commit_BlockID    = _String{"BlockID"}
	fieldName__Commit_Signatures = _String{"Signatures"}
)
var _ ipld.Node = (Commit)(&_Commit{})
var _ schema.TypedNode = (Commit)(&_Commit{})

func (Commit) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Commit) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Height":
		return &n.Height, nil
	case "Round":
		return &n.Round, nil
	case "BlockID":
		return &n.BlockID, nil
	case "Signatures":
		return &n.Signatures, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Commit) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Commit) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Commit"}.LookupByIndex(0)
}
func (n Commit) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Commit) MapIterator() ipld.MapIterator {
	return &_Commit__MapItr{n, 0}
}

type _Commit__MapItr struct {
	n   Commit
	idx int
}

func (itr *_Commit__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Commit_Height
		v = &itr.n.Height
	case 1:
		k = &fieldName__Commit_Round
		v = &itr.n.Round
	case 2:
		k = &fieldName__Commit_BlockID
		v = &itr.n.BlockID
	case 3:
		k = &fieldName__Commit_Signatures
		v = &itr.n.Signatures
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Commit__MapItr) Done() bool {
	return itr.idx >= 4
}

func (Commit) ListIterator() ipld.ListIterator {
	return nil
}
func (Commit) Length() int64 {
	return 4
}
func (Commit) IsAbsent() bool {
	return false
}
func (Commit) IsNull() bool {
	return false
}
func (Commit) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsBool()
}
func (Commit) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsInt()
}
func (Commit) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsFloat()
}
func (Commit) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsString()
}
func (Commit) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsBytes()
}
func (Commit) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Commit"}.AsLink()
}
func (Commit) Prototype() ipld.NodePrototype {
	return _Commit__Prototype{}
}

type _Commit__Prototype struct{}

func (_Commit__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Commit__Builder
	nb.Reset()
	return &nb
}

type _Commit__Builder struct {
	_Commit__Assembler
}

func (nb *_Commit__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Commit__Builder) Reset() {
	var w _Commit
	var m schema.Maybe
	*nb = _Commit__Builder{_Commit__Assembler{w: &w, m: &m}}
}

type _Commit__Assembler struct {
	w     *_Commit
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Height     _Int__Assembler
	ca_Round      _Int__Assembler
	ca_BlockID    _BlockID__Assembler
	ca_Signatures _Signatures__Assembler
}

func (na *_Commit__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_BlockID.reset()
	na.ca_Signatures.reset()
}

var (
	fieldBit__Commit_Height      = 1 << 0
	fieldBit__Commit_Round       = 1 << 1
	fieldBit__Commit_BlockID     = 1 << 2
	fieldBit__Commit_Signatures  = 1 << 3
	fieldBits__Commit_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_Commit__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Commit{}
	}
	return na, nil
}
func (_Commit__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Commit"}.BeginList(0)
}
func (na *_Commit__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Commit"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Commit__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignBool(false)
}
func (_Commit__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignInt(0)
}
func (_Commit__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignFloat(0)
}
func (_Commit__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignString("")
}
func (_Commit__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignBytes(nil)
}
func (_Commit__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Commit"}.AssignLink(nil)
}
func (na *_Commit__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Commit); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Commit", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Commit__Assembler) Prototype() ipld.NodePrototype {
	return _Commit__Prototype{}
}
func (ma *_Commit__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Height.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Round.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Signatures.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Commit__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Height":
		if ma.s&fieldBit__Commit_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Height}
		}
		ma.s += fieldBit__Commit_Height
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Commit_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Round}
		}
		ma.s += fieldBit__Commit_Round
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "BlockID":
		if ma.s&fieldBit__Commit_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_BlockID}
		}
		ma.s += fieldBit__Commit_BlockID
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Signatures":
		if ma.s&fieldBit__Commit_Signatures != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Signatures}
		}
		ma.s += fieldBit__Commit_Signatures
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Signatures.w = &ma.w.Signatures
		ma.ca_Signatures.m = &ma.cm
		return &ma.ca_Signatures, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Commit", Key: &_String{k}}
}
func (ma *_Commit__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Commit__KeyAssembler)(ma)
}
func (ma *_Commit__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 1:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 2:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 3:
		ma.ca_Signatures.w = &ma.w.Signatures
		ma.ca_Signatures.m = &ma.cm
		return &ma.ca_Signatures
	default:
		panic("unreachable")
	}
}
func (ma *_Commit__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Commit_sufficient != fieldBits__Commit_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Commit_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Commit_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Commit_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Commit_Signatures == 0 {
			err.Missing = append(err.Missing, "Signatures")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Commit__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Commit__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Commit__KeyAssembler _Commit__Assembler

func (_Commit__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.BeginMap(0)
}
func (_Commit__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.BeginList(0)
}
func (na *_Commit__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignNull()
}
func (_Commit__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignBool(false)
}
func (_Commit__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignInt(0)
}
func (_Commit__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Commit__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Height":
		if ka.s&fieldBit__Commit_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Height}
		}
		ka.s += fieldBit__Commit_Height
		ka.state = maState_expectValue
		ka.f = 0
	case "Round":
		if ka.s&fieldBit__Commit_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Round}
		}
		ka.s += fieldBit__Commit_Round
		ka.state = maState_expectValue
		ka.f = 1
	case "BlockID":
		if ka.s&fieldBit__Commit_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_BlockID}
		}
		ka.s += fieldBit__Commit_BlockID
		ka.state = maState_expectValue
		ka.f = 2
	case "Signatures":
		if ka.s&fieldBit__Commit_Signatures != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Signatures}
		}
		ka.s += fieldBit__Commit_Signatures
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Commit", Key: &_String{k}}
	}
	return nil
}
func (_Commit__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignBytes(nil)
}
func (_Commit__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Commit.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Commit__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Commit__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Commit) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Commit) Representation() ipld.Node {
	return (*_Commit__Repr)(n)
}

type _Commit__Repr _Commit

var (
	fieldName__Commit_Height_serial     = _String{"Height"}
	fieldName__Commit_Round_serial      = _String{"Round"}
	fieldName__Commit_BlockID_serial    = _String{"BlockID"}
	fieldName__Commit_Signatures_serial = _String{"Signatures"}
)
var _ ipld.Node = &_Commit__Repr{}

func (_Commit__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Commit__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Height":
		return n.Height.Representation(), nil
	case "Round":
		return n.Round.Representation(), nil
	case "BlockID":
		return n.BlockID.Representation(), nil
	case "Signatures":
		return n.Signatures.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Commit__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Commit__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.LookupByIndex(0)
}
func (n _Commit__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Commit__Repr) MapIterator() ipld.MapIterator {
	return &_Commit__ReprMapItr{n, 0}
}

type _Commit__ReprMapItr struct {
	n   *_Commit__Repr
	idx int
}

func (itr *_Commit__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Commit_Height_serial
		v = itr.n.Height.Representation()
	case 1:
		k = &fieldName__Commit_Round_serial
		v = itr.n.Round.Representation()
	case 2:
		k = &fieldName__Commit_BlockID_serial
		v = itr.n.BlockID.Representation()
	case 3:
		k = &fieldName__Commit_Signatures_serial
		v = itr.n.Signatures.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Commit__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_Commit__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Commit__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_Commit__Repr) IsAbsent() bool {
	return false
}
func (_Commit__Repr) IsNull() bool {
	return false
}
func (_Commit__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsBool()
}
func (_Commit__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsInt()
}
func (_Commit__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsFloat()
}
func (_Commit__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsString()
}
func (_Commit__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsBytes()
}
func (_Commit__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Commit.Repr"}.AsLink()
}
func (_Commit__Repr) Prototype() ipld.NodePrototype {
	return _Commit__ReprPrototype{}
}

type _Commit__ReprPrototype struct{}

func (_Commit__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Commit__ReprBuilder
	nb.Reset()
	return &nb
}

type _Commit__ReprBuilder struct {
	_Commit__ReprAssembler
}

func (nb *_Commit__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Commit__ReprBuilder) Reset() {
	var w _Commit
	var m schema.Maybe
	*nb = _Commit__ReprBuilder{_Commit__ReprAssembler{w: &w, m: &m}}
}

type _Commit__ReprAssembler struct {
	w     *_Commit
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Height     _Int__ReprAssembler
	ca_Round      _Int__ReprAssembler
	ca_BlockID    _BlockID__ReprAssembler
	ca_Signatures _Signatures__ReprAssembler
}

func (na *_Commit__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_BlockID.reset()
	na.ca_Signatures.reset()
}
func (na *_Commit__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Commit{}
	}
	return na, nil
}
func (_Commit__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.BeginList(0)
}
func (na *_Commit__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Commit.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Commit__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignBool(false)
}
func (_Commit__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignInt(0)
}
func (_Commit__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignFloat(0)
}
func (_Commit__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignString("")
}
func (_Commit__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignBytes(nil)
}
func (_Commit__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Commit.Repr"}.AssignLink(nil)
}
func (na *_Commit__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Commit); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Commit.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Commit__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Commit__ReprPrototype{}
}
func (ma *_Commit__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Commit__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Height":
		if ma.s&fieldBit__Commit_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Height_serial}
		}
		ma.s += fieldBit__Commit_Height
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Commit_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Round_serial}
		}
		ma.s += fieldBit__Commit_Round
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "BlockID":
		if ma.s&fieldBit__Commit_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_BlockID_serial}
		}
		ma.s += fieldBit__Commit_BlockID
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Signatures":
		if ma.s&fieldBit__Commit_Signatures != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Signatures_serial}
		}
		ma.s += fieldBit__Commit_Signatures
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Signatures.w = &ma.w.Signatures
		ma.ca_Signatures.m = &ma.cm
		return &ma.ca_Signatures, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Commit.Repr", Key: &_String{k}}
}
func (ma *_Commit__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Commit__ReprKeyAssembler)(ma)
}
func (ma *_Commit__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 1:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 2:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 3:
		ma.ca_Signatures.w = &ma.w.Signatures
		ma.ca_Signatures.m = &ma.cm
		return &ma.ca_Signatures
	default:
		panic("unreachable")
	}
}
func (ma *_Commit__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Commit_sufficient != fieldBits__Commit_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Commit_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Commit_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Commit_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Commit_Signatures == 0 {
			err.Missing = append(err.Missing, "Signatures")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Commit__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Commit__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Commit__ReprKeyAssembler _Commit__ReprAssembler

func (_Commit__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Commit__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Commit__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignNull()
}
func (_Commit__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Commit__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Commit__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Commit__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Height":
		if ka.s&fieldBit__Commit_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Height_serial}
		}
		ka.s += fieldBit__Commit_Height
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Round":
		if ka.s&fieldBit__Commit_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Round_serial}
		}
		ka.s += fieldBit__Commit_Round
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "BlockID":
		if ka.s&fieldBit__Commit_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_BlockID_serial}
		}
		ka.s += fieldBit__Commit_BlockID
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Signatures":
		if ka.s&fieldBit__Commit_Signatures != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Commit_Signatures_serial}
		}
		ka.s += fieldBit__Commit_Signatures
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Commit.Repr", Key: &_String{k}}
}
func (_Commit__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Commit__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Commit.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Commit__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Commit__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _CommitSig) FieldBlockIDFlag() BlockIDFlag {
	return &n.BlockIDFlag
}
func (n _CommitSig) FieldValidatorAddress() Address {
	return &n.ValidatorAddress
}
func (n _CommitSig) FieldTimestamp() Time {
	return &n.Timestamp
}
func (n _CommitSig) FieldSignature() Signature {
	return &n.Signature
}

type _CommitSig__Maybe struct {
	m schema.Maybe
	v CommitSig
}
type MaybeCommitSig = *_CommitSig__Maybe

func (m MaybeCommitSig) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeCommitSig) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeCommitSig) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeCommitSig) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeCommitSig) Must() CommitSig {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__CommitSig_BlockIDFlag      = _String{"BlockIDFlag"}
	fieldName__CommitSig_ValidatorAddress = _String{"ValidatorAddress"}
	fieldName__CommitSig_Timestamp        = _String{"Timestamp"}
	fieldName__CommitSig_Signature        = _String{"Signature"}
)
var _ ipld.Node = (CommitSig)(&_CommitSig{})
var _ schema.TypedNode = (CommitSig)(&_CommitSig{})

func (CommitSig) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n CommitSig) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "BlockIDFlag":
		return &n.BlockIDFlag, nil
	case "ValidatorAddress":
		return &n.ValidatorAddress, nil
	case "Timestamp":
		return &n.Timestamp, nil
	case "Signature":
		return &n.Signature, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n CommitSig) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (CommitSig) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.LookupByIndex(0)
}
func (n CommitSig) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n CommitSig) MapIterator() ipld.MapIterator {
	return &_CommitSig__MapItr{n, 0}
}

type _CommitSig__MapItr struct {
	n   CommitSig
	idx int
}

func (itr *_CommitSig__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__CommitSig_BlockIDFlag
		v = &itr.n.BlockIDFlag
	case 1:
		k = &fieldName__CommitSig_ValidatorAddress
		v = &itr.n.ValidatorAddress
	case 2:
		k = &fieldName__CommitSig_Timestamp
		v = &itr.n.Timestamp
	case 3:
		k = &fieldName__CommitSig_Signature
		v = &itr.n.Signature
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_CommitSig__MapItr) Done() bool {
	return itr.idx >= 4
}

func (CommitSig) ListIterator() ipld.ListIterator {
	return nil
}
func (CommitSig) Length() int64 {
	return 4
}
func (CommitSig) IsAbsent() bool {
	return false
}
func (CommitSig) IsNull() bool {
	return false
}
func (CommitSig) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsBool()
}
func (CommitSig) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsInt()
}
func (CommitSig) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsFloat()
}
func (CommitSig) AsString() (string, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsString()
}
func (CommitSig) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsBytes()
}
func (CommitSig) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.CommitSig"}.AsLink()
}
func (CommitSig) Prototype() ipld.NodePrototype {
	return _CommitSig__Prototype{}
}

type _CommitSig__Prototype struct{}

func (_CommitSig__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _CommitSig__Builder
	nb.Reset()
	return &nb
}

type _CommitSig__Builder struct {
	_CommitSig__Assembler
}

func (nb *_CommitSig__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_CommitSig__Builder) Reset() {
	var w _CommitSig
	var m schema.Maybe
	*nb = _CommitSig__Builder{_CommitSig__Assembler{w: &w, m: &m}}
}

type _CommitSig__Assembler struct {
	w     *_CommitSig
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_BlockIDFlag      _BlockIDFlag__Assembler
	ca_ValidatorAddress _Address__Assembler
	ca_Timestamp        _Time__Assembler
	ca_Signature        _Signature__Assembler
}

func (na *_CommitSig__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_BlockIDFlag.reset()
	na.ca_ValidatorAddress.reset()
	na.ca_Timestamp.reset()
	na.ca_Signature.reset()
}

var (
	fieldBit__CommitSig_BlockIDFlag      = 1 << 0
	fieldBit__CommitSig_ValidatorAddress = 1 << 1
	fieldBit__CommitSig_Timestamp        = 1 << 2
	fieldBit__CommitSig_Signature        = 1 << 3
	fieldBits__CommitSig_sufficient      = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_CommitSig__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_CommitSig{}
	}
	return na, nil
}
func (_CommitSig__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.BeginList(0)
}
func (na *_CommitSig__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_CommitSig__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignBool(false)
}
func (_CommitSig__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignInt(0)
}
func (_CommitSig__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignFloat(0)
}
func (_CommitSig__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignString("")
}
func (_CommitSig__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignBytes(nil)
}
func (_CommitSig__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig"}.AssignLink(nil)
}
func (na *_CommitSig__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_CommitSig); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.CommitSig", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_CommitSig__Assembler) Prototype() ipld.NodePrototype {
	return _CommitSig__Prototype{}
}
func (ma *_CommitSig__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockIDFlag.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorAddress.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Timestamp.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Signature.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_CommitSig__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "BlockIDFlag":
		if ma.s&fieldBit__CommitSig_BlockIDFlag != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_BlockIDFlag}
		}
		ma.s += fieldBit__CommitSig_BlockIDFlag
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_BlockIDFlag.w = &ma.w.BlockIDFlag
		ma.ca_BlockIDFlag.m = &ma.cm
		return &ma.ca_BlockIDFlag, nil
	case "ValidatorAddress":
		if ma.s&fieldBit__CommitSig_ValidatorAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_ValidatorAddress}
		}
		ma.s += fieldBit__CommitSig_ValidatorAddress
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress, nil
	case "Timestamp":
		if ma.s&fieldBit__CommitSig_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Timestamp}
		}
		ma.s += fieldBit__CommitSig_Timestamp
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "Signature":
		if ma.s&fieldBit__CommitSig_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Signature}
		}
		ma.s += fieldBit__CommitSig_Signature
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.CommitSig", Key: &_String{k}}
}
func (ma *_CommitSig__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_CommitSig__KeyAssembler)(ma)
}
func (ma *_CommitSig__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_BlockIDFlag.w = &ma.w.BlockIDFlag
		ma.ca_BlockIDFlag.m = &ma.cm
		return &ma.ca_BlockIDFlag
	case 1:
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress
	case 2:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 3:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_CommitSig__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__CommitSig_sufficient != fieldBits__CommitSig_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__CommitSig_BlockIDFlag == 0 {
			err.Missing = append(err.Missing, "BlockIDFlag")
		}
		if ma.s&fieldBit__CommitSig_ValidatorAddress == 0 {
			err.Missing = append(err.Missing, "ValidatorAddress")
		}
		if ma.s&fieldBit__CommitSig_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__CommitSig_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_CommitSig__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_CommitSig__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _CommitSig__KeyAssembler _CommitSig__Assembler

func (_CommitSig__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.BeginMap(0)
}
func (_CommitSig__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.BeginList(0)
}
func (na *_CommitSig__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignNull()
}
func (_CommitSig__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignBool(false)
}
func (_CommitSig__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignInt(0)
}
func (_CommitSig__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignFloat(0)
}
func (ka *_CommitSig__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "BlockIDFlag":
		if ka.s&fieldBit__CommitSig_BlockIDFlag != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_BlockIDFlag}
		}
		ka.s += fieldBit__CommitSig_BlockIDFlag
		ka.state = maState_expectValue
		ka.f = 0
	case "ValidatorAddress":
		if ka.s&fieldBit__CommitSig_ValidatorAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_ValidatorAddress}
		}
		ka.s += fieldBit__CommitSig_ValidatorAddress
		ka.state = maState_expectValue
		ka.f = 1
	case "Timestamp":
		if ka.s&fieldBit__CommitSig_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Timestamp}
		}
		ka.s += fieldBit__CommitSig_Timestamp
		ka.state = maState_expectValue
		ka.f = 2
	case "Signature":
		if ka.s&fieldBit__CommitSig_Signature != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Signature}
		}
		ka.s += fieldBit__CommitSig_Signature
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.CommitSig", Key: &_String{k}}
	}
	return nil
}
func (_CommitSig__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignBytes(nil)
}
func (_CommitSig__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.KeyAssembler"}.AssignLink(nil)
}
func (ka *_CommitSig__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_CommitSig__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (CommitSig) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n CommitSig) Representation() ipld.Node {
	return (*_CommitSig__Repr)(n)
}

type _CommitSig__Repr _CommitSig

var (
	fieldName__CommitSig_BlockIDFlag_serial      = _String{"BlockIDFlag"}
	fieldName__CommitSig_ValidatorAddress_serial = _String{"ValidatorAddress"}
	fieldName__CommitSig_Timestamp_serial        = _String{"Timestamp"}
	fieldName__CommitSig_Signature_serial        = _String{"Signature"}
)
var _ ipld.Node = &_CommitSig__Repr{}

func (_CommitSig__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_CommitSig__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "BlockIDFlag":
		return n.BlockIDFlag.Representation(), nil
	case "ValidatorAddress":
		return n.ValidatorAddress.Representation(), nil
	case "Timestamp":
		return n.Timestamp.Representation(), nil
	case "Signature":
		return n.Signature.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_CommitSig__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_CommitSig__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.LookupByIndex(0)
}
func (n _CommitSig__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_CommitSig__Repr) MapIterator() ipld.MapIterator {
	return &_CommitSig__ReprMapItr{n, 0}
}

type _CommitSig__ReprMapItr struct {
	n   *_CommitSig__Repr
	idx int
}

func (itr *_CommitSig__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__CommitSig_BlockIDFlag_serial
		v = itr.n.BlockIDFlag.Representation()
	case 1:
		k = &fieldName__CommitSig_ValidatorAddress_serial
		v = itr.n.ValidatorAddress.Representation()
	case 2:
		k = &fieldName__CommitSig_Timestamp_serial
		v = itr.n.Timestamp.Representation()
	case 3:
		k = &fieldName__CommitSig_Signature_serial
		v = itr.n.Signature.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_CommitSig__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_CommitSig__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_CommitSig__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_CommitSig__Repr) IsAbsent() bool {
	return false
}
func (_CommitSig__Repr) IsNull() bool {
	return false
}
func (_CommitSig__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsBool()
}
func (_CommitSig__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsInt()
}
func (_CommitSig__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsFloat()
}
func (_CommitSig__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsString()
}
func (_CommitSig__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsBytes()
}
func (_CommitSig__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.CommitSig.Repr"}.AsLink()
}
func (_CommitSig__Repr) Prototype() ipld.NodePrototype {
	return _CommitSig__ReprPrototype{}
}

type _CommitSig__ReprPrototype struct{}

func (_CommitSig__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _CommitSig__ReprBuilder
	nb.Reset()
	return &nb
}

type _CommitSig__ReprBuilder struct {
	_CommitSig__ReprAssembler
}

func (nb *_CommitSig__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_CommitSig__ReprBuilder) Reset() {
	var w _CommitSig
	var m schema.Maybe
	*nb = _CommitSig__ReprBuilder{_CommitSig__ReprAssembler{w: &w, m: &m}}
}

type _CommitSig__ReprAssembler struct {
	w     *_CommitSig
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_BlockIDFlag      _BlockIDFlag__ReprAssembler
	ca_ValidatorAddress _Address__ReprAssembler
	ca_Timestamp        _Time__ReprAssembler
	ca_Signature        _Signature__ReprAssembler
}

func (na *_CommitSig__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_BlockIDFlag.reset()
	na.ca_ValidatorAddress.reset()
	na.ca_Timestamp.reset()
	na.ca_Signature.reset()
}
func (na *_CommitSig__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_CommitSig{}
	}
	return na, nil
}
func (_CommitSig__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.BeginList(0)
}
func (na *_CommitSig__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.CommitSig.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_CommitSig__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignBool(false)
}
func (_CommitSig__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignInt(0)
}
func (_CommitSig__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignFloat(0)
}
func (_CommitSig__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignString("")
}
func (_CommitSig__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignBytes(nil)
}
func (_CommitSig__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.CommitSig.Repr"}.AssignLink(nil)
}
func (na *_CommitSig__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_CommitSig); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.CommitSig.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_CommitSig__ReprAssembler) Prototype() ipld.NodePrototype {
	return _CommitSig__ReprPrototype{}
}
func (ma *_CommitSig__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_CommitSig__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "BlockIDFlag":
		if ma.s&fieldBit__CommitSig_BlockIDFlag != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_BlockIDFlag_serial}
		}
		ma.s += fieldBit__CommitSig_BlockIDFlag
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_BlockIDFlag.w = &ma.w.BlockIDFlag
		ma.ca_BlockIDFlag.m = &ma.cm
		return &ma.ca_BlockIDFlag, nil
	case "ValidatorAddress":
		if ma.s&fieldBit__CommitSig_ValidatorAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_ValidatorAddress_serial}
		}
		ma.s += fieldBit__CommitSig_ValidatorAddress
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress, nil
	case "Timestamp":
		if ma.s&fieldBit__CommitSig_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Timestamp_serial}
		}
		ma.s += fieldBit__CommitSig_Timestamp
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "Signature":
		if ma.s&fieldBit__CommitSig_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Signature_serial}
		}
		ma.s += fieldBit__CommitSig_Signature
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.CommitSig.Repr", Key: &_String{k}}
}
func (ma *_CommitSig__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_CommitSig__ReprKeyAssembler)(ma)
}
func (ma *_CommitSig__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_BlockIDFlag.w = &ma.w.BlockIDFlag
		ma.ca_BlockIDFlag.m = &ma.cm
		return &ma.ca_BlockIDFlag
	case 1:
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress
	case 2:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 3:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_CommitSig__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__CommitSig_sufficient != fieldBits__CommitSig_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__CommitSig_BlockIDFlag == 0 {
			err.Missing = append(err.Missing, "BlockIDFlag")
		}
		if ma.s&fieldBit__CommitSig_ValidatorAddress == 0 {
			err.Missing = append(err.Missing, "ValidatorAddress")
		}
		if ma.s&fieldBit__CommitSig_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__CommitSig_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_CommitSig__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_CommitSig__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _CommitSig__ReprKeyAssembler _CommitSig__ReprAssembler

func (_CommitSig__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.BeginMap(0)
}
func (_CommitSig__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_CommitSig__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignNull()
}
func (_CommitSig__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignBool(false)
}
func (_CommitSig__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignInt(0)
}
func (_CommitSig__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_CommitSig__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "BlockIDFlag":
		if ka.s&fieldBit__CommitSig_BlockIDFlag != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_BlockIDFlag_serial}
		}
		ka.s += fieldBit__CommitSig_BlockIDFlag
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "ValidatorAddress":
		if ka.s&fieldBit__CommitSig_ValidatorAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_ValidatorAddress_serial}
		}
		ka.s += fieldBit__CommitSig_ValidatorAddress
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Timestamp":
		if ka.s&fieldBit__CommitSig_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Timestamp_serial}
		}
		ka.s += fieldBit__CommitSig_Timestamp
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Signature":
		if ka.s&fieldBit__CommitSig_Signature != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__CommitSig_Signature_serial}
		}
		ka.s += fieldBit__CommitSig_Signature
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.CommitSig.Repr", Key: &_String{k}}
}
func (_CommitSig__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_CommitSig__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.CommitSig.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_CommitSig__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_CommitSig__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _ConsensusParams) FieldBlock() BlockParams {
	return &n.Block
}
func (n _ConsensusParams) FieldEvidence() EvidenceParams {
	return &n.Evidence
}
func (n _ConsensusParams) FieldValidator() ValidatorParams {
	return &n.Validator
}
func (n _ConsensusParams) FieldVersion() VersionParams {
	return &n.Version
}

type _ConsensusParams__Maybe struct {
	m schema.Maybe
	v ConsensusParams
}
type MaybeConsensusParams = *_ConsensusParams__Maybe

func (m MaybeConsensusParams) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeConsensusParams) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeConsensusParams) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeConsensusParams) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeConsensusParams) Must() ConsensusParams {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__ConsensusParams_Block     = _String{"Block"}
	fieldName__ConsensusParams_Evidence  = _String{"Evidence"}
	fieldName__ConsensusParams_Validator = _String{"Validator"}
	fieldName__ConsensusParams_Version   = _String{"Version"}
)
var _ ipld.Node = (ConsensusParams)(&_ConsensusParams{})
var _ schema.TypedNode = (ConsensusParams)(&_ConsensusParams{})

func (ConsensusParams) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n ConsensusParams) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Block":
		return &n.Block, nil
	case "Evidence":
		return &n.Evidence, nil
	case "Validator":
		return &n.Validator, nil
	case "Version":
		return &n.Version, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n ConsensusParams) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (ConsensusParams) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.ConsensusParams"}.LookupByIndex(0)
}
func (n ConsensusParams) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n ConsensusParams) MapIterator() ipld.MapIterator {
	return &_ConsensusParams__MapItr{n, 0}
}

type _ConsensusParams__MapItr struct {
	n   ConsensusParams
	idx int
}

func (itr *_ConsensusParams__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__ConsensusParams_Block
		v = &itr.n.Block
	case 1:
		k = &fieldName__ConsensusParams_Evidence
		v = &itr.n.Evidence
	case 2:
		k = &fieldName__ConsensusParams_Validator
		v = &itr.n.Validator
	case 3:
		k = &fieldName__ConsensusParams_Version
		v = &itr.n.Version
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ConsensusParams__MapItr) Done() bool {
	return itr.idx >= 4
}

func (ConsensusParams) ListIterator() ipld.ListIterator {
	return nil
}
func (ConsensusParams) Length() int64 {
	return 4
}
func (ConsensusParams) IsAbsent() bool {
	return false
}
func (ConsensusParams) IsNull() bool {
	return false
}
func (ConsensusParams) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.ConsensusParams"}.AsBool()
}
func (ConsensusParams) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.ConsensusParams"}.AsInt()
}
func (ConsensusParams) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.ConsensusParams"}.AsFloat()
}
func (ConsensusParams) AsString() (string, error) {
	return mixins.Map{"dagcosmos.ConsensusParams"}.AsString()
}
func (ConsensusParams) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.ConsensusParams"}.AsBytes()
}
func (ConsensusParams) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.ConsensusParams"}.AsLink()
}
func (ConsensusParams) Prototype() ipld.NodePrototype {
	return _ConsensusParams__Prototype{}
}

type _ConsensusParams__Prototype struct{}

func (_ConsensusParams__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _ConsensusParams__Builder
	nb.Reset()
	return &nb
}

type _ConsensusParams__Builder struct {
	_ConsensusParams__Assembler
}

func (nb *_ConsensusParams__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ConsensusParams__Builder) Reset() {
	var w _ConsensusParams
	var m schema.Maybe
	*nb = _ConsensusParams__Builder{_ConsensusParams__Assembler{w: &w, m: &m}}
}

type _ConsensusParams__Assembler struct {
	w     *_ConsensusParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm           schema.Maybe
	ca_Block     _BlockParams__Assembler
	ca_Evidence  _EvidenceParams__Assembler
	ca_Validator _ValidatorParams__Assembler
	ca_Version   _VersionParams__Assembler
}

func (na *_ConsensusParams__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Block.reset()
	na.ca_Evidence.reset()
	na.ca_Validator.reset()
	na.ca_Version.reset()
}

var (
	fieldBit__ConsensusParams_Block       = 1 << 0
	fieldBit__ConsensusParams_Evidence    = 1 << 1
	fieldBit__ConsensusParams_Validator   = 1 << 2
	fieldBit__ConsensusParams_Version     = 1 << 3
	fieldBits__ConsensusParams_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_ConsensusParams__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ConsensusParams{}
	}
	return na, nil
}
func (_ConsensusParams__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams"}.BeginList(0)
}
func (na *_ConsensusParams__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.ConsensusParams"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ConsensusParams__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams"}.AssignBool(false)
}
func (_ConsensusParams__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams"}.AssignInt(0)
}
func (_ConsensusParams__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams"}.AssignFloat(0)
}
func (_ConsensusParams__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams"}.AssignString("")
}
func (_ConsensusParams__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams"}.AssignBytes(nil)
}
func (_ConsensusParams__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams"}.AssignLink(nil)
}
func (na *_ConsensusParams__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ConsensusParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.ConsensusParams", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ConsensusParams__Assembler) Prototype() ipld.NodePrototype {
	return _ConsensusParams__Prototype{}
}
func (ma *_ConsensusParams__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Block.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Evidence.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Validator.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Version.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_ConsensusParams__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Block":
		if ma.s&fieldBit__ConsensusParams_Block != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Block}
		}
		ma.s += fieldBit__ConsensusParams_Block
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block, nil
	case "Evidence":
		if ma.s&fieldBit__ConsensusParams_Evidence != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Evidence}
		}
		ma.s += fieldBit__ConsensusParams_Evidence
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence, nil
	case "Validator":
		if ma.s&fieldBit__ConsensusParams_Validator != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Validator}
		}
		ma.s += fieldBit__ConsensusParams_Validator
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Validator.w = &ma.w.Validator
		ma.ca_Validator.m = &ma.cm
		return &ma.ca_Validator, nil
	case "Version":
		if ma.s&fieldBit__ConsensusParams_Version != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Version}
		}
		ma.s += fieldBit__ConsensusParams_Version
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.ConsensusParams", Key: &_String{k}}
}
func (ma *_ConsensusParams__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ConsensusParams__KeyAssembler)(ma)
}
func (ma *_ConsensusParams__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block
	case 1:
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence
	case 2:
		ma.ca_Validator.w = &ma.w.Validator
		ma.ca_Validator.m = &ma.cm
		return &ma.ca_Validator
	case 3:
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version
	default:
		panic("unreachable")
	}
}
func (ma *_ConsensusParams__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__ConsensusParams_sufficient != fieldBits__ConsensusParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__ConsensusParams_Block == 0 {
			err.Missing = append(err.Missing, "Block")
		}
		if ma.s&fieldBit__ConsensusParams_Evidence == 0 {
			err.Missing = append(err.Missing, "Evidence")
		}
		if ma.s&fieldBit__ConsensusParams_Validator == 0 {
			err.Missing = append(err.Missing, "Validator")
		}
		if ma.s&fieldBit__ConsensusParams_Version == 0 {
			err.Missing = append(err.Missing, "Version")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ConsensusParams__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ConsensusParams__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _ConsensusParams__KeyAssembler _ConsensusParams__Assembler

func (_ConsensusParams__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.KeyAssembler"}.BeginMap(0)
}
func (_ConsensusParams__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.KeyAssembler"}.BeginList(0)
}
func (na *_ConsensusParams__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.KeyAssembler"}.AssignNull()
}
func (_ConsensusParams__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.KeyAssembler"}.AssignBool(false)
}
func (_ConsensusParams__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.KeyAssembler"}.AssignInt(0)
}
func (_ConsensusParams__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ConsensusParams__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Block":
		if ka.s&fieldBit__ConsensusParams_Block != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Block}
		}
		ka.s += fieldBit__ConsensusParams_Block
		ka.state = maState_expectValue
		ka.f = 0
	case "Evidence":
		if ka.s&fieldBit__ConsensusParams_Evidence != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Evidence}
		}
		ka.s += fieldBit__ConsensusParams_Evidence
		ka.state = maState_expectValue
		ka.f = 1
	case "Validator":
		if ka.s&fieldBit__ConsensusParams_Validator != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Validator}
		}
		ka.s += fieldBit__ConsensusParams_Validator
		ka.state = maState_expectValue
		ka.f = 2
	case "Version":
		if ka.s&fieldBit__ConsensusParams_Version != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Version}
		}
		ka.s += fieldBit__ConsensusParams_Version
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.ConsensusParams", Key: &_String{k}}
	}
	return nil
}
func (_ConsensusParams__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.KeyAssembler"}.AssignBytes(nil)
}
func (_ConsensusParams__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ConsensusParams__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ConsensusParams__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ConsensusParams) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n ConsensusParams) Representation() ipld.Node {
	return (*_ConsensusParams__Repr)(n)
}

type _ConsensusParams__Repr _ConsensusParams

var (
	fieldName__ConsensusParams_Block_serial     = _String{"Block"}
	fieldName__ConsensusParams_Evidence_serial  = _String{"Evidence"}
	fieldName__ConsensusParams_Validator_serial = _String{"Validator"}
	fieldName__ConsensusParams_Version_serial   = _String{"Version"}
)
var _ ipld.Node = &_ConsensusParams__Repr{}

func (_ConsensusParams__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_ConsensusParams__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Block":
		return n.Block.Representation(), nil
	case "Evidence":
		return n.Evidence.Representation(), nil
	case "Validator":
		return n.Validator.Representation(), nil
	case "Version":
		return n.Version.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_ConsensusParams__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_ConsensusParams__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.ConsensusParams.Repr"}.LookupByIndex(0)
}
func (n _ConsensusParams__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_ConsensusParams__Repr) MapIterator() ipld.MapIterator {
	return &_ConsensusParams__ReprMapItr{n, 0}
}

type _ConsensusParams__ReprMapItr struct {
	n   *_ConsensusParams__Repr
	idx int
}

func (itr *_ConsensusParams__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__ConsensusParams_Block_serial
		v = itr.n.Block.Representation()
	case 1:
		k = &fieldName__ConsensusParams_Evidence_serial
		v = itr.n.Evidence.Representation()
	case 2:
		k = &fieldName__ConsensusParams_Validator_serial
		v = itr.n.Validator.Representation()
	case 3:
		k = &fieldName__ConsensusParams_Version_serial
		v = itr.n.Version.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ConsensusParams__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_ConsensusParams__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_ConsensusParams__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_ConsensusParams__Repr) IsAbsent() bool {
	return false
}
func (_ConsensusParams__Repr) IsNull() bool {
	return false
}
func (_ConsensusParams__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.ConsensusParams.Repr"}.AsBool()
}
func (_ConsensusParams__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.ConsensusParams.Repr"}.AsInt()
}
func (_ConsensusParams__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.ConsensusParams.Repr"}.AsFloat()
}
func (_ConsensusParams__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.ConsensusParams.Repr"}.AsString()
}
func (_ConsensusParams__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.ConsensusParams.Repr"}.AsBytes()
}
func (_ConsensusParams__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.ConsensusParams.Repr"}.AsLink()
}
func (_ConsensusParams__Repr) Prototype() ipld.NodePrototype {
	return _ConsensusParams__ReprPrototype{}
}

type _ConsensusParams__ReprPrototype struct{}

func (_ConsensusParams__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _ConsensusParams__ReprBuilder
	nb.Reset()
	return &nb
}

type _ConsensusParams__ReprBuilder struct {
	_ConsensusParams__ReprAssembler
}

func (nb *_ConsensusParams__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ConsensusParams__ReprBuilder) Reset() {
	var w _ConsensusParams
	var m schema.Maybe
	*nb = _ConsensusParams__ReprBuilder{_ConsensusParams__ReprAssembler{w: &w, m: &m}}
}

type _ConsensusParams__ReprAssembler struct {
	w     *_ConsensusParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm           schema.Maybe
	ca_Block     _BlockParams__ReprAssembler
	ca_Evidence  _EvidenceParams__ReprAssembler
	ca_Validator _ValidatorParams__ReprAssembler
	ca_Version   _VersionParams__ReprAssembler
}

func (na *_ConsensusParams__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Block.reset()
	na.ca_Evidence.reset()
	na.ca_Validator.reset()
	na.ca_Version.reset()
}
func (na *_ConsensusParams__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ConsensusParams{}
	}
	return na, nil
}
func (_ConsensusParams__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams.Repr"}.BeginList(0)
}
func (na *_ConsensusParams__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.ConsensusParams.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ConsensusParams__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams.Repr"}.AssignBool(false)
}
func (_ConsensusParams__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams.Repr"}.AssignInt(0)
}
func (_ConsensusParams__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams.Repr"}.AssignFloat(0)
}
func (_ConsensusParams__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams.Repr"}.AssignString("")
}
func (_ConsensusParams__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams.Repr"}.AssignBytes(nil)
}
func (_ConsensusParams__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.ConsensusParams.Repr"}.AssignLink(nil)
}
func (na *_ConsensusParams__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ConsensusParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.ConsensusParams.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ConsensusParams__ReprAssembler) Prototype() ipld.NodePrototype {
	return _ConsensusParams__ReprPrototype{}
}
func (ma *_ConsensusParams__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_ConsensusParams__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Block":
		if ma.s&fieldBit__ConsensusParams_Block != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Block_serial}
		}
		ma.s += fieldBit__ConsensusParams_Block
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block, nil
	case "Evidence":
		if ma.s&fieldBit__ConsensusParams_Evidence != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Evidence_serial}
		}
		ma.s += fieldBit__ConsensusParams_Evidence
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence, nil
	case "Validator":
		if ma.s&fieldBit__ConsensusParams_Validator != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Validator_serial}
		}
		ma.s += fieldBit__ConsensusParams_Validator
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Validator.w = &ma.w.Validator
		ma.ca_Validator.m = &ma.cm
		return &ma.ca_Validator, nil
	case "Version":
		if ma.s&fieldBit__ConsensusParams_Version != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Version_serial}
		}
		ma.s += fieldBit__ConsensusParams_Version
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.ConsensusParams.Repr", Key: &_String{k}}
}
func (ma *_ConsensusParams__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ConsensusParams__ReprKeyAssembler)(ma)
}
func (ma *_ConsensusParams__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block
	case 1:
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence
	case 2:
		ma.ca_Validator.w = &ma.w.Validator
		ma.ca_Validator.m = &ma.cm
		return &ma.ca_Validator
	case 3:
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version
	default:
		panic("unreachable")
	}
}
func (ma *_ConsensusParams__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__ConsensusParams_sufficient != fieldBits__ConsensusParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__ConsensusParams_Block == 0 {
			err.Missing = append(err.Missing, "Block")
		}
		if ma.s&fieldBit__ConsensusParams_Evidence == 0 {
			err.Missing = append(err.Missing, "Evidence")
		}
		if ma.s&fieldBit__ConsensusParams_Validator == 0 {
			err.Missing = append(err.Missing, "Validator")
		}
		if ma.s&fieldBit__ConsensusParams_Version == 0 {
			err.Missing = append(err.Missing, "Version")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ConsensusParams__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ConsensusParams__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _ConsensusParams__ReprKeyAssembler _ConsensusParams__ReprAssembler

func (_ConsensusParams__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.Repr.KeyAssembler"}.BeginMap(0)
}
func (_ConsensusParams__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_ConsensusParams__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.Repr.KeyAssembler"}.AssignNull()
}
func (_ConsensusParams__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.Repr.KeyAssembler"}.AssignBool(false)
}
func (_ConsensusParams__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.Repr.KeyAssembler"}.AssignInt(0)
}
func (_ConsensusParams__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ConsensusParams__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Block":
		if ka.s&fieldBit__ConsensusParams_Block != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Block_serial}
		}
		ka.s += fieldBit__ConsensusParams_Block
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Evidence":
		if ka.s&fieldBit__ConsensusParams_Evidence != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Evidence_serial}
		}
		ka.s += fieldBit__ConsensusParams_Evidence
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Validator":
		if ka.s&fieldBit__ConsensusParams_Validator != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Validator_serial}
		}
		ka.s += fieldBit__ConsensusParams_Validator
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Version":
		if ka.s&fieldBit__ConsensusParams_Version != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ConsensusParams_Version_serial}
		}
		ka.s += fieldBit__ConsensusParams_Version
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.ConsensusParams.Repr", Key: &_String{k}}
}
func (_ConsensusParams__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_ConsensusParams__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.ConsensusParams.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ConsensusParams__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ConsensusParams__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _Data) FieldTxs() Txs {
	return &n.Txs
}

type _Data__Maybe struct {
	m schema.Maybe
	v Data
}
type MaybeData = *_Data__Maybe

func (m MaybeData) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeData) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeData) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeData) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeData) Must() Data {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Data_Txs = _String{"Txs"}
)
var _ ipld.Node = (Data)(&_Data{})
var _ schema.TypedNode = (Data)(&_Data{})

func (Data) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Data) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Txs":
		return &n.Txs, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Data) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Data) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Data"}.LookupByIndex(0)
}
func (n Data) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Data) MapIterator() ipld.MapIterator {
	return &_Data__MapItr{n, 0}
}

type _Data__MapItr struct {
	n   Data
	idx int
}

func (itr *_Data__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Data_Txs
		v = &itr.n.Txs
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Data__MapItr) Done() bool {
	return itr.idx >= 1
}

func (Data) ListIterator() ipld.ListIterator {
	return nil
}
func (Data) Length() int64 {
	return 1
}
func (Data) IsAbsent() bool {
	return false
}
func (Data) IsNull() bool {
	return false
}
func (Data) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Data"}.AsBool()
}
func (Data) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Data"}.AsInt()
}
func (Data) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Data"}.AsFloat()
}
func (Data) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Data"}.AsString()
}
func (Data) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Data"}.AsBytes()
}
func (Data) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Data"}.AsLink()
}
func (Data) Prototype() ipld.NodePrototype {
	return _Data__Prototype{}
}

type _Data__Prototype struct{}

func (_Data__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Data__Builder
	nb.Reset()
	return &nb
}

type _Data__Builder struct {
	_Data__Assembler
}

func (nb *_Data__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Data__Builder) Reset() {
	var w _Data
	var m schema.Maybe
	*nb = _Data__Builder{_Data__Assembler{w: &w, m: &m}}
}

type _Data__Assembler struct {
	w     *_Data
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm     schema.Maybe
	ca_Txs _Txs__Assembler
}

func (na *_Data__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Txs.reset()
}

var (
	fieldBit__Data_Txs         = 1 << 0
	fieldBits__Data_sufficient = 0 + 1<<0
)

func (na *_Data__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Data{}
	}
	return na, nil
}
func (_Data__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Data"}.BeginList(0)
}
func (na *_Data__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Data"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Data__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignBool(false)
}
func (_Data__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignInt(0)
}
func (_Data__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignFloat(0)
}
func (_Data__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignString("")
}
func (_Data__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignBytes(nil)
}
func (_Data__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Data"}.AssignLink(nil)
}
func (na *_Data__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Data); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Data", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Data__Assembler) Prototype() ipld.NodePrototype {
	return _Data__Prototype{}
}
func (ma *_Data__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Txs.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Data__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Txs":
		if ma.s&fieldBit__Data_Txs != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Data_Txs}
		}
		ma.s += fieldBit__Data_Txs
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Txs.w = &ma.w.Txs
		ma.ca_Txs.m = &ma.cm
		return &ma.ca_Txs, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Data", Key: &_String{k}}
}
func (ma *_Data__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Data__KeyAssembler)(ma)
}
func (ma *_Data__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Txs.w = &ma.w.Txs
		ma.ca_Txs.m = &ma.cm
		return &ma.ca_Txs
	default:
		panic("unreachable")
	}
}
func (ma *_Data__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Data_sufficient != fieldBits__Data_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Data_Txs == 0 {
			err.Missing = append(err.Missing, "Txs")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Data__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Data__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Data__KeyAssembler _Data__Assembler

func (_Data__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.BeginMap(0)
}
func (_Data__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.BeginList(0)
}
func (na *_Data__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignNull()
}
func (_Data__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignBool(false)
}
func (_Data__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignInt(0)
}
func (_Data__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Data__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Txs":
		if ka.s&fieldBit__Data_Txs != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Data_Txs}
		}
		ka.s += fieldBit__Data_Txs
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Data", Key: &_String{k}}
	}
	return nil
}
func (_Data__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignBytes(nil)
}
func (_Data__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Data.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Data__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Data__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Data) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Data) Representation() ipld.Node {
	return (*_Data__Repr)(n)
}

type _Data__Repr _Data

var (
	fieldName__Data_Txs_serial = _String{"Txs"}
)
var _ ipld.Node = &_Data__Repr{}

func (_Data__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Data__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Txs":
		return n.Txs.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Data__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Data__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.LookupByIndex(0)
}
func (n _Data__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Data__Repr) MapIterator() ipld.MapIterator {
	return &_Data__ReprMapItr{n, 0}
}

type _Data__ReprMapItr struct {
	n   *_Data__Repr
	idx int
}

func (itr *_Data__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Data_Txs_serial
		v = itr.n.Txs.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Data__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_Data__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Data__Repr) Length() int64 {
	l := 1
	return int64(l)
}
func (_Data__Repr) IsAbsent() bool {
	return false
}
func (_Data__Repr) IsNull() bool {
	return false
}
func (_Data__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsBool()
}
func (_Data__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsInt()
}
func (_Data__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsFloat()
}
func (_Data__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsString()
}
func (_Data__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsBytes()
}
func (_Data__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Data.Repr"}.AsLink()
}
func (_Data__Repr) Prototype() ipld.NodePrototype {
	return _Data__ReprPrototype{}
}

type _Data__ReprPrototype struct{}

func (_Data__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Data__ReprBuilder
	nb.Reset()
	return &nb
}

type _Data__ReprBuilder struct {
	_Data__ReprAssembler
}

func (nb *_Data__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Data__ReprBuilder) Reset() {
	var w _Data
	var m schema.Maybe
	*nb = _Data__ReprBuilder{_Data__ReprAssembler{w: &w, m: &m}}
}

type _Data__ReprAssembler struct {
	w     *_Data
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm     schema.Maybe
	ca_Txs _Txs__ReprAssembler
}

func (na *_Data__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Txs.reset()
}
func (na *_Data__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Data{}
	}
	return na, nil
}
func (_Data__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.BeginList(0)
}
func (na *_Data__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Data.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Data__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignBool(false)
}
func (_Data__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignInt(0)
}
func (_Data__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignFloat(0)
}
func (_Data__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignString("")
}
func (_Data__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignBytes(nil)
}
func (_Data__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Data.Repr"}.AssignLink(nil)
}
func (na *_Data__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Data); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Data.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Data__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Data__ReprPrototype{}
}
func (ma *_Data__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Data__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Txs":
		if ma.s&fieldBit__Data_Txs != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Data_Txs_serial}
		}
		ma.s += fieldBit__Data_Txs
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Txs.w = &ma.w.Txs
		ma.ca_Txs.m = &ma.cm
		return &ma.ca_Txs, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Data.Repr", Key: &_String{k}}
}
func (ma *_Data__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Data__ReprKeyAssembler)(ma)
}
func (ma *_Data__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Txs.w = &ma.w.Txs
		ma.ca_Txs.m = &ma.cm
		return &ma.ca_Txs
	default:
		panic("unreachable")
	}
}
func (ma *_Data__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Data_sufficient != fieldBits__Data_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Data_Txs == 0 {
			err.Missing = append(err.Missing, "Txs")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Data__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Data__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Data__ReprKeyAssembler _Data__ReprAssembler

func (_Data__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Data__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Data__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignNull()
}
func (_Data__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Data__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Data__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Data__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Txs":
		if ka.s&fieldBit__Data_Txs != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Data_Txs_serial}
		}
		ka.s += fieldBit__Data_Txs
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Data.Repr", Key: &_String{k}}
}
func (_Data__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Data__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Data.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Data__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Data__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _DuplicateVoteEvidence) FieldVoteA() Vote {
	return &n.VoteA
}
func (n _DuplicateVoteEvidence) FieldVoteB() Vote {
	return &n.VoteB
}
func (n _DuplicateVoteEvidence) FieldTotalVotingPower() Int {
	return &n.TotalVotingPower
}
func (n _DuplicateVoteEvidence) FieldValidatorPower() Int {
	return &n.ValidatorPower
}
func (n _DuplicateVoteEvidence) FieldTimestamp() Time {
	return &n.Timestamp
}

type _DuplicateVoteEvidence__Maybe struct {
	m schema.Maybe
	v DuplicateVoteEvidence
}
type MaybeDuplicateVoteEvidence = *_DuplicateVoteEvidence__Maybe

func (m MaybeDuplicateVoteEvidence) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeDuplicateVoteEvidence) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeDuplicateVoteEvidence) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeDuplicateVoteEvidence) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeDuplicateVoteEvidence) Must() DuplicateVoteEvidence {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__DuplicateVoteEvidence_VoteA            = _String{"VoteA"}
	fieldName__DuplicateVoteEvidence_VoteB            = _String{"VoteB"}
	fieldName__DuplicateVoteEvidence_TotalVotingPower = _String{"TotalVotingPower"}
	fieldName__DuplicateVoteEvidence_ValidatorPower   = _String{"ValidatorPower"}
	fieldName__DuplicateVoteEvidence_Timestamp        = _String{"Timestamp"}
)
var _ ipld.Node = (DuplicateVoteEvidence)(&_DuplicateVoteEvidence{})
var _ schema.TypedNode = (DuplicateVoteEvidence)(&_DuplicateVoteEvidence{})

func (DuplicateVoteEvidence) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n DuplicateVoteEvidence) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "VoteA":
		return &n.VoteA, nil
	case "VoteB":
		return &n.VoteB, nil
	case "TotalVotingPower":
		return &n.TotalVotingPower, nil
	case "ValidatorPower":
		return &n.ValidatorPower, nil
	case "Timestamp":
		return &n.Timestamp, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n DuplicateVoteEvidence) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (DuplicateVoteEvidence) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.LookupByIndex(0)
}
func (n DuplicateVoteEvidence) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n DuplicateVoteEvidence) MapIterator() ipld.MapIterator {
	return &_DuplicateVoteEvidence__MapItr{n, 0}
}

type _DuplicateVoteEvidence__MapItr struct {
	n   DuplicateVoteEvidence
	idx int
}

func (itr *_DuplicateVoteEvidence__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__DuplicateVoteEvidence_VoteA
		v = &itr.n.VoteA
	case 1:
		k = &fieldName__DuplicateVoteEvidence_VoteB
		v = &itr.n.VoteB
	case 2:
		k = &fieldName__DuplicateVoteEvidence_TotalVotingPower
		v = &itr.n.TotalVotingPower
	case 3:
		k = &fieldName__DuplicateVoteEvidence_ValidatorPower
		v = &itr.n.ValidatorPower
	case 4:
		k = &fieldName__DuplicateVoteEvidence_Timestamp
		v = &itr.n.Timestamp
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_DuplicateVoteEvidence__MapItr) Done() bool {
	return itr.idx >= 5
}

func (DuplicateVoteEvidence) ListIterator() ipld.ListIterator {
	return nil
}
func (DuplicateVoteEvidence) Length() int64 {
	return 5
}
func (DuplicateVoteEvidence) IsAbsent() bool {
	return false
}
func (DuplicateVoteEvidence) IsNull() bool {
	return false
}
func (DuplicateVoteEvidence) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsBool()
}
func (DuplicateVoteEvidence) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsInt()
}
func (DuplicateVoteEvidence) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsFloat()
}
func (DuplicateVoteEvidence) AsString() (string, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsString()
}
func (DuplicateVoteEvidence) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsBytes()
}
func (DuplicateVoteEvidence) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence"}.AsLink()
}
func (DuplicateVoteEvidence) Prototype() ipld.NodePrototype {
	return _DuplicateVoteEvidence__Prototype{}
}

type _DuplicateVoteEvidence__Prototype struct{}

func (_DuplicateVoteEvidence__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _DuplicateVoteEvidence__Builder
	nb.Reset()
	return &nb
}

type _DuplicateVoteEvidence__Builder struct {
	_DuplicateVoteEvidence__Assembler
}

func (nb *_DuplicateVoteEvidence__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_DuplicateVoteEvidence__Builder) Reset() {
	var w _DuplicateVoteEvidence
	var m schema.Maybe
	*nb = _DuplicateVoteEvidence__Builder{_DuplicateVoteEvidence__Assembler{w: &w, m: &m}}
}

type _DuplicateVoteEvidence__Assembler struct {
	w     *_DuplicateVoteEvidence
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_VoteA            _Vote__Assembler
	ca_VoteB            _Vote__Assembler
	ca_TotalVotingPower _Int__Assembler
	ca_ValidatorPower   _Int__Assembler
	ca_Timestamp        _Time__Assembler
}

func (na *_DuplicateVoteEvidence__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_VoteA.reset()
	na.ca_VoteB.reset()
	na.ca_TotalVotingPower.reset()
	na.ca_ValidatorPower.reset()
	na.ca_Timestamp.reset()
}

var (
	fieldBit__DuplicateVoteEvidence_VoteA            = 1 << 0
	fieldBit__DuplicateVoteEvidence_VoteB            = 1 << 1
	fieldBit__DuplicateVoteEvidence_TotalVotingPower = 1 << 2
	fieldBit__DuplicateVoteEvidence_ValidatorPower   = 1 << 3
	fieldBit__DuplicateVoteEvidence_Timestamp        = 1 << 4
	fieldBits__DuplicateVoteEvidence_sufficient      = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4
)

func (na *_DuplicateVoteEvidence__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_DuplicateVoteEvidence{}
	}
	return na, nil
}
func (_DuplicateVoteEvidence__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.BeginList(0)
}
func (na *_DuplicateVoteEvidence__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_DuplicateVoteEvidence__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignBool(false)
}
func (_DuplicateVoteEvidence__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignInt(0)
}
func (_DuplicateVoteEvidence__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignFloat(0)
}
func (_DuplicateVoteEvidence__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignString("")
}
func (_DuplicateVoteEvidence__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignBytes(nil)
}
func (_DuplicateVoteEvidence__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence"}.AssignLink(nil)
}
func (na *_DuplicateVoteEvidence__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_DuplicateVoteEvidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.DuplicateVoteEvidence", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_DuplicateVoteEvidence__Assembler) Prototype() ipld.NodePrototype {
	return _DuplicateVoteEvidence__Prototype{}
}
func (ma *_DuplicateVoteEvidence__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_VoteA.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_VoteB.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_TotalVotingPower.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorPower.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Timestamp.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_DuplicateVoteEvidence__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "VoteA":
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteA != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteA}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_VoteA
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_VoteA.w = &ma.w.VoteA
		ma.ca_VoteA.m = &ma.cm
		return &ma.ca_VoteA, nil
	case "VoteB":
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteB != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteB}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_VoteB
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_VoteB.w = &ma.w.VoteB
		ma.ca_VoteB.m = &ma.cm
		return &ma.ca_VoteB, nil
	case "TotalVotingPower":
		if ma.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_TotalVotingPower}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_TotalVotingPower
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower, nil
	case "ValidatorPower":
		if ma.s&fieldBit__DuplicateVoteEvidence_ValidatorPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_ValidatorPower}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_ValidatorPower
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_ValidatorPower.w = &ma.w.ValidatorPower
		ma.ca_ValidatorPower.m = &ma.cm
		return &ma.ca_ValidatorPower, nil
	case "Timestamp":
		if ma.s&fieldBit__DuplicateVoteEvidence_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_Timestamp}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.DuplicateVoteEvidence", Key: &_String{k}}
}
func (ma *_DuplicateVoteEvidence__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_DuplicateVoteEvidence__KeyAssembler)(ma)
}
func (ma *_DuplicateVoteEvidence__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_VoteA.w = &ma.w.VoteA
		ma.ca_VoteA.m = &ma.cm
		return &ma.ca_VoteA
	case 1:
		ma.ca_VoteB.w = &ma.w.VoteB
		ma.ca_VoteB.m = &ma.cm
		return &ma.ca_VoteB
	case 2:
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower
	case 3:
		ma.ca_ValidatorPower.w = &ma.w.ValidatorPower
		ma.ca_ValidatorPower.m = &ma.cm
		return &ma.ca_ValidatorPower
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	default:
		panic("unreachable")
	}
}
func (ma *_DuplicateVoteEvidence__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__DuplicateVoteEvidence_sufficient != fieldBits__DuplicateVoteEvidence_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteA == 0 {
			err.Missing = append(err.Missing, "VoteA")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteB == 0 {
			err.Missing = append(err.Missing, "VoteB")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower == 0 {
			err.Missing = append(err.Missing, "TotalVotingPower")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_ValidatorPower == 0 {
			err.Missing = append(err.Missing, "ValidatorPower")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_DuplicateVoteEvidence__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_DuplicateVoteEvidence__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _DuplicateVoteEvidence__KeyAssembler _DuplicateVoteEvidence__Assembler

func (_DuplicateVoteEvidence__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.BeginMap(0)
}
func (_DuplicateVoteEvidence__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.BeginList(0)
}
func (na *_DuplicateVoteEvidence__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignNull()
}
func (_DuplicateVoteEvidence__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignBool(false)
}
func (_DuplicateVoteEvidence__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignInt(0)
}
func (_DuplicateVoteEvidence__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignFloat(0)
}
func (ka *_DuplicateVoteEvidence__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "VoteA":
		if ka.s&fieldBit__DuplicateVoteEvidence_VoteA != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteA}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_VoteA
		ka.state = maState_expectValue
		ka.f = 0
	case "VoteB":
		if ka.s&fieldBit__DuplicateVoteEvidence_VoteB != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteB}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_VoteB
		ka.state = maState_expectValue
		ka.f = 1
	case "TotalVotingPower":
		if ka.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_TotalVotingPower}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_TotalVotingPower
		ka.state = maState_expectValue
		ka.f = 2
	case "ValidatorPower":
		if ka.s&fieldBit__DuplicateVoteEvidence_ValidatorPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_ValidatorPower}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_ValidatorPower
		ka.state = maState_expectValue
		ka.f = 3
	case "Timestamp":
		if ka.s&fieldBit__DuplicateVoteEvidence_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_Timestamp}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.DuplicateVoteEvidence", Key: &_String{k}}
	}
	return nil
}
func (_DuplicateVoteEvidence__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignBytes(nil)
}
func (_DuplicateVoteEvidence__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.KeyAssembler"}.AssignLink(nil)
}
func (ka *_DuplicateVoteEvidence__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_DuplicateVoteEvidence__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (DuplicateVoteEvidence) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n DuplicateVoteEvidence) Representation() ipld.Node {
	return (*_DuplicateVoteEvidence__Repr)(n)
}

type _DuplicateVoteEvidence__Repr _DuplicateVoteEvidence

var (
	fieldName__DuplicateVoteEvidence_VoteA_serial            = _String{"VoteA"}
	fieldName__DuplicateVoteEvidence_VoteB_serial            = _String{"VoteB"}
	fieldName__DuplicateVoteEvidence_TotalVotingPower_serial = _String{"TotalVotingPower"}
	fieldName__DuplicateVoteEvidence_ValidatorPower_serial   = _String{"ValidatorPower"}
	fieldName__DuplicateVoteEvidence_Timestamp_serial        = _String{"Timestamp"}
)
var _ ipld.Node = &_DuplicateVoteEvidence__Repr{}

func (_DuplicateVoteEvidence__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_DuplicateVoteEvidence__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "VoteA":
		return n.VoteA.Representation(), nil
	case "VoteB":
		return n.VoteB.Representation(), nil
	case "TotalVotingPower":
		return n.TotalVotingPower.Representation(), nil
	case "ValidatorPower":
		return n.ValidatorPower.Representation(), nil
	case "Timestamp":
		return n.Timestamp.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_DuplicateVoteEvidence__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_DuplicateVoteEvidence__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.LookupByIndex(0)
}
func (n _DuplicateVoteEvidence__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_DuplicateVoteEvidence__Repr) MapIterator() ipld.MapIterator {
	return &_DuplicateVoteEvidence__ReprMapItr{n, 0}
}

type _DuplicateVoteEvidence__ReprMapItr struct {
	n   *_DuplicateVoteEvidence__Repr
	idx int
}

func (itr *_DuplicateVoteEvidence__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__DuplicateVoteEvidence_VoteA_serial
		v = itr.n.VoteA.Representation()
	case 1:
		k = &fieldName__DuplicateVoteEvidence_VoteB_serial
		v = itr.n.VoteB.Representation()
	case 2:
		k = &fieldName__DuplicateVoteEvidence_TotalVotingPower_serial
		v = itr.n.TotalVotingPower.Representation()
	case 3:
		k = &fieldName__DuplicateVoteEvidence_ValidatorPower_serial
		v = itr.n.ValidatorPower.Representation()
	case 4:
		k = &fieldName__DuplicateVoteEvidence_Timestamp_serial
		v = itr.n.Timestamp.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_DuplicateVoteEvidence__ReprMapItr) Done() bool {
	return itr.idx >= 5
}
func (_DuplicateVoteEvidence__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_DuplicateVoteEvidence__Repr) Length() int64 {
	l := 5
	return int64(l)
}
func (_DuplicateVoteEvidence__Repr) IsAbsent() bool {
	return false
}
func (_DuplicateVoteEvidence__Repr) IsNull() bool {
	return false
}
func (_DuplicateVoteEvidence__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsBool()
}
func (_DuplicateVoteEvidence__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsInt()
}
func (_DuplicateVoteEvidence__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsFloat()
}
func (_DuplicateVoteEvidence__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsString()
}
func (_DuplicateVoteEvidence__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsBytes()
}
func (_DuplicateVoteEvidence__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.DuplicateVoteEvidence.Repr"}.AsLink()
}
func (_DuplicateVoteEvidence__Repr) Prototype() ipld.NodePrototype {
	return _DuplicateVoteEvidence__ReprPrototype{}
}

type _DuplicateVoteEvidence__ReprPrototype struct{}

func (_DuplicateVoteEvidence__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _DuplicateVoteEvidence__ReprBuilder
	nb.Reset()
	return &nb
}

type _DuplicateVoteEvidence__ReprBuilder struct {
	_DuplicateVoteEvidence__ReprAssembler
}

func (nb *_DuplicateVoteEvidence__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_DuplicateVoteEvidence__ReprBuilder) Reset() {
	var w _DuplicateVoteEvidence
	var m schema.Maybe
	*nb = _DuplicateVoteEvidence__ReprBuilder{_DuplicateVoteEvidence__ReprAssembler{w: &w, m: &m}}
}

type _DuplicateVoteEvidence__ReprAssembler struct {
	w     *_DuplicateVoteEvidence
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_VoteA            _Vote__ReprAssembler
	ca_VoteB            _Vote__ReprAssembler
	ca_TotalVotingPower _Int__ReprAssembler
	ca_ValidatorPower   _Int__ReprAssembler
	ca_Timestamp        _Time__ReprAssembler
}

func (na *_DuplicateVoteEvidence__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_VoteA.reset()
	na.ca_VoteB.reset()
	na.ca_TotalVotingPower.reset()
	na.ca_ValidatorPower.reset()
	na.ca_Timestamp.reset()
}
func (na *_DuplicateVoteEvidence__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_DuplicateVoteEvidence{}
	}
	return na, nil
}
func (_DuplicateVoteEvidence__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.BeginList(0)
}
func (na *_DuplicateVoteEvidence__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignBool(false)
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignInt(0)
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignFloat(0)
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignString("")
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignBytes(nil)
}
func (_DuplicateVoteEvidence__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.DuplicateVoteEvidence.Repr"}.AssignLink(nil)
}
func (na *_DuplicateVoteEvidence__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_DuplicateVoteEvidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.DuplicateVoteEvidence.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_DuplicateVoteEvidence__ReprAssembler) Prototype() ipld.NodePrototype {
	return _DuplicateVoteEvidence__ReprPrototype{}
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "VoteA":
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteA != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteA_serial}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_VoteA
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_VoteA.w = &ma.w.VoteA
		ma.ca_VoteA.m = &ma.cm
		return &ma.ca_VoteA, nil
	case "VoteB":
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteB != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteB_serial}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_VoteB
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_VoteB.w = &ma.w.VoteB
		ma.ca_VoteB.m = &ma.cm
		return &ma.ca_VoteB, nil
	case "TotalVotingPower":
		if ma.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_TotalVotingPower_serial}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_TotalVotingPower
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower, nil
	case "ValidatorPower":
		if ma.s&fieldBit__DuplicateVoteEvidence_ValidatorPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_ValidatorPower_serial}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_ValidatorPower
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_ValidatorPower.w = &ma.w.ValidatorPower
		ma.ca_ValidatorPower.m = &ma.cm
		return &ma.ca_ValidatorPower, nil
	case "Timestamp":
		if ma.s&fieldBit__DuplicateVoteEvidence_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_Timestamp_serial}
		}
		ma.s += fieldBit__DuplicateVoteEvidence_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.DuplicateVoteEvidence.Repr", Key: &_String{k}}
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_DuplicateVoteEvidence__ReprKeyAssembler)(ma)
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_VoteA.w = &ma.w.VoteA
		ma.ca_VoteA.m = &ma.cm
		return &ma.ca_VoteA
	case 1:
		ma.ca_VoteB.w = &ma.w.VoteB
		ma.ca_VoteB.m = &ma.cm
		return &ma.ca_VoteB
	case 2:
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower
	case 3:
		ma.ca_ValidatorPower.w = &ma.w.ValidatorPower
		ma.ca_ValidatorPower.m = &ma.cm
		return &ma.ca_ValidatorPower
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	default:
		panic("unreachable")
	}
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__DuplicateVoteEvidence_sufficient != fieldBits__DuplicateVoteEvidence_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteA == 0 {
			err.Missing = append(err.Missing, "VoteA")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_VoteB == 0 {
			err.Missing = append(err.Missing, "VoteB")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower == 0 {
			err.Missing = append(err.Missing, "TotalVotingPower")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_ValidatorPower == 0 {
			err.Missing = append(err.Missing, "ValidatorPower")
		}
		if ma.s&fieldBit__DuplicateVoteEvidence_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_DuplicateVoteEvidence__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _DuplicateVoteEvidence__ReprKeyAssembler _DuplicateVoteEvidence__ReprAssembler

func (_DuplicateVoteEvidence__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.BeginMap(0)
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_DuplicateVoteEvidence__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignNull()
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignBool(false)
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignInt(0)
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_DuplicateVoteEvidence__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "VoteA":
		if ka.s&fieldBit__DuplicateVoteEvidence_VoteA != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteA_serial}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_VoteA
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "VoteB":
		if ka.s&fieldBit__DuplicateVoteEvidence_VoteB != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_VoteB_serial}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_VoteB
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "TotalVotingPower":
		if ka.s&fieldBit__DuplicateVoteEvidence_TotalVotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_TotalVotingPower_serial}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_TotalVotingPower
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "ValidatorPower":
		if ka.s&fieldBit__DuplicateVoteEvidence_ValidatorPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_ValidatorPower_serial}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_ValidatorPower
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Timestamp":
		if ka.s&fieldBit__DuplicateVoteEvidence_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__DuplicateVoteEvidence_Timestamp_serial}
		}
		ka.s += fieldBit__DuplicateVoteEvidence_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.DuplicateVoteEvidence.Repr", Key: &_String{k}}
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.DuplicateVoteEvidence.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_DuplicateVoteEvidence__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_DuplicateVoteEvidence__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Duration) Bytes() []byte {
	return n.x
}
func (_Duration__Prototype) FromBytes(v []byte) (Duration, error) {
	n := _Duration{v}
	return &n, nil
}

type _Duration__Maybe struct {
	m schema.Maybe
	v Duration
}
type MaybeDuration = *_Duration__Maybe

func (m MaybeDuration) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeDuration) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeDuration) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeDuration) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeDuration) Must() Duration {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Duration)(&_Duration{})
var _ schema.TypedNode = (Duration)(&_Duration{})

func (Duration) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Duration) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.LookupByString("")
}
func (Duration) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.LookupByNode(nil)
}
func (Duration) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.LookupByIndex(0)
}
func (Duration) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.LookupBySegment(seg)
}
func (Duration) MapIterator() ipld.MapIterator {
	return nil
}
func (Duration) ListIterator() ipld.ListIterator {
	return nil
}
func (Duration) Length() int64 {
	return -1
}
func (Duration) IsAbsent() bool {
	return false
}
func (Duration) IsNull() bool {
	return false
}
func (Duration) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.AsBool()
}
func (Duration) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.AsInt()
}
func (Duration) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.AsFloat()
}
func (Duration) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.AsString()
}
func (n Duration) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Duration) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Duration"}.AsLink()
}
func (Duration) Prototype() ipld.NodePrototype {
	return _Duration__Prototype{}
}

type _Duration__Prototype struct{}

func (_Duration__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Duration__Builder
	nb.Reset()
	return &nb
}

type _Duration__Builder struct {
	_Duration__Assembler
}

func (nb *_Duration__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Duration__Builder) Reset() {
	var w _Duration
	var m schema.Maybe
	*nb = _Duration__Builder{_Duration__Assembler{w: &w, m: &m}}
}

type _Duration__Assembler struct {
	w *_Duration
	m *schema.Maybe
}

func (na *_Duration__Assembler) reset() {}
func (_Duration__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.BeginMap(0)
}
func (_Duration__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.BeginList(0)
}
func (na *_Duration__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Duration__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignBool(false)
}
func (_Duration__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignInt(0)
}
func (_Duration__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignFloat(0)
}
func (_Duration__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignString("")
}
func (na *_Duration__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Duration{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Duration__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Duration"}.AssignLink(nil)
}
func (na *_Duration__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Duration); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Duration__Assembler) Prototype() ipld.NodePrototype {
	return _Duration__Prototype{}
}
func (Duration) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Duration) Representation() ipld.Node {
	return (*_Duration__Repr)(n)
}

type _Duration__Repr = _Duration

var _ ipld.Node = &_Duration__Repr{}

type _Duration__ReprPrototype = _Duration__Prototype
type _Duration__ReprAssembler = _Duration__Assembler

func (n _Evidence) AsInterface() _Evidence__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	default:
		panic("invalid union state; how did you create this object?")
	}
}

type _Evidence__Maybe struct {
	m schema.Maybe
	v Evidence
}
type MaybeEvidence = *_Evidence__Maybe

func (m MaybeEvidence) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeEvidence) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeEvidence) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeEvidence) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeEvidence) Must() Evidence {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	memberName__Evidence_DuplicateVoteEvidence     = _String{"DuplicateVoteEvidence"}
	memberName__Evidence_LightClientAttackEvidence = _String{"LightClientAttackEvidence"}
)
var _ ipld.Node = (Evidence)(&_Evidence{})
var _ schema.TypedNode = (Evidence)(&_Evidence{})

func (Evidence) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Evidence) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "DuplicateVoteEvidence":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "LightClientAttackEvidence":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Evidence) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Evidence) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Evidence"}.LookupByIndex(0)
}
func (n Evidence) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Evidence) MapIterator() ipld.MapIterator {
	return &_Evidence__MapItr{n, false}
}

type _Evidence__MapItr struct {
	n    Evidence
	done bool
}

func (itr *_Evidence__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__Evidence_DuplicateVoteEvidence, &itr.n.x1
	case 2:
		k, v = &memberName__Evidence_LightClientAttackEvidence, &itr.n.x2
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_Evidence__MapItr) Done() bool {
	return itr.done
}

func (Evidence) ListIterator() ipld.ListIterator {
	return nil
}
func (Evidence) Length() int64 {
	return 1
}
func (Evidence) IsAbsent() bool {
	return false
}
func (Evidence) IsNull() bool {
	return false
}
func (Evidence) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsBool()
}
func (Evidence) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsInt()
}
func (Evidence) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsFloat()
}
func (Evidence) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsString()
}
func (Evidence) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsBytes()
}
func (Evidence) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Evidence"}.AsLink()
}
func (Evidence) Prototype() ipld.NodePrototype {
	return _Evidence__Prototype{}
}

type _Evidence__Prototype struct{}

func (_Evidence__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Evidence__Builder
	nb.Reset()
	return &nb
}

type _Evidence__Builder struct {
	_Evidence__Assembler
}

func (nb *_Evidence__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Evidence__Builder) Reset() {
	var w _Evidence
	var m schema.Maybe
	*nb = _Evidence__Builder{_Evidence__Assembler{w: &w, m: &m}}
}

type _Evidence__Assembler struct {
	w     *_Evidence
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _DuplicateVoteEvidence__Assembler

	ca2 _LightClientAttackEvidence__Assembler
	ca  uint
}

func (na *_Evidence__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_Evidence__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Evidence{}
	}
	return na, nil
}
func (_Evidence__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.BeginList(0)
}
func (na *_Evidence__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Evidence__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignBool(false)
}
func (_Evidence__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignInt(0)
}
func (_Evidence__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignFloat(0)
}
func (_Evidence__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignString("")
}
func (_Evidence__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignBytes(nil)
}
func (_Evidence__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Evidence"}.AssignLink(nil)
}
func (na *_Evidence__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Evidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Evidence", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Evidence__Assembler) Prototype() ipld.NodePrototype {
	return _Evidence__Prototype{}
}
func (ma *_Evidence__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_Evidence__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "DuplicateVoteEvidence":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "LightClientAttackEvidence":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Evidence", Key: &_String{k}}
}
func (ma *_Evidence__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Evidence__KeyAssembler)(ma)
}
func (ma *_Evidence__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_Evidence__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Evidence__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Evidence__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "DuplicateVoteEvidence":
		return _DuplicateVoteEvidence__Prototype{}
	case "LightClientAttackEvidence":
		return _LightClientAttackEvidence__Prototype{}
	default:
		return nil
	}
}

type _Evidence__KeyAssembler _Evidence__Assembler

func (_Evidence__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.BeginMap(0)
}
func (_Evidence__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.BeginList(0)
}
func (na *_Evidence__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignNull()
}
func (_Evidence__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignBool(false)
}
func (_Evidence__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignInt(0)
}
func (_Evidence__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Evidence__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "DuplicateVoteEvidence":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "LightClientAttackEvidence":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Evidence", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_Evidence__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignBytes(nil)
}
func (_Evidence__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Evidence__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Evidence__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Evidence) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Evidence) Representation() ipld.Node {
	return (*_Evidence__Repr)(n)
}

type _Evidence__Repr _Evidence

var (
	memberName__Evidence_DuplicateVoteEvidence_serial     = _String{"duplicate"}
	memberName__Evidence_LightClientAttackEvidence_serial = _String{"light"}
)
var _ ipld.Node = &_Evidence__Repr{}

func (_Evidence__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Evidence__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "duplicate":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "light":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Evidence__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Evidence__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.LookupByIndex(0)
}
func (n _Evidence__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Evidence__Repr) MapIterator() ipld.MapIterator {
	return &_Evidence__ReprMapItr{n, false}
}

type _Evidence__ReprMapItr struct {
	n    *_Evidence__Repr
	done bool
}

func (itr *_Evidence__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__Evidence_DuplicateVoteEvidence_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__Evidence_LightClientAttackEvidence_serial, itr.n.x2.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_Evidence__ReprMapItr) Done() bool {
	return itr.done
}

func (_Evidence__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_Evidence__Repr) Length() int64 {
	return 1
}
func (_Evidence__Repr) IsAbsent() bool {
	return false
}
func (_Evidence__Repr) IsNull() bool {
	return false
}
func (_Evidence__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsBool()
}
func (_Evidence__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsInt()
}
func (_Evidence__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsFloat()
}
func (_Evidence__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsString()
}
func (_Evidence__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsBytes()
}
func (_Evidence__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Evidence.Repr"}.AsLink()
}
func (_Evidence__Repr) Prototype() ipld.NodePrototype {
	return _Evidence__ReprPrototype{}
}

type _Evidence__ReprPrototype struct{}

func (_Evidence__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Evidence__ReprBuilder
	nb.Reset()
	return &nb
}

type _Evidence__ReprBuilder struct {
	_Evidence__ReprAssembler
}

func (nb *_Evidence__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Evidence__ReprBuilder) Reset() {
	var w _Evidence
	var m schema.Maybe
	*nb = _Evidence__ReprBuilder{_Evidence__ReprAssembler{w: &w, m: &m}}
}

type _Evidence__ReprAssembler struct {
	w     *_Evidence
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _DuplicateVoteEvidence__ReprAssembler

	ca2 _LightClientAttackEvidence__ReprAssembler
	ca  uint
}

func (na *_Evidence__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_Evidence__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Evidence{}
	}
	return na, nil
}
func (_Evidence__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.BeginList(0)
}
func (na *_Evidence__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Evidence.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Evidence__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignBool(false)
}
func (_Evidence__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignInt(0)
}
func (_Evidence__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignFloat(0)
}
func (_Evidence__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignString("")
}
func (_Evidence__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignBytes(nil)
}
func (_Evidence__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Evidence.Repr"}.AssignLink(nil)
}
func (na *_Evidence__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Evidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Evidence.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Evidence__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Evidence__ReprPrototype{}
}
func (ma *_Evidence__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_Evidence__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "duplicate":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "light":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Evidence.Repr", Key: &_String{k}}
}
func (ma *_Evidence__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Evidence__ReprKeyAssembler)(ma)
}
func (ma *_Evidence__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_Evidence__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Evidence__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Evidence__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "DuplicateVoteEvidence":
		return _DuplicateVoteEvidence__ReprPrototype{}
	case "LightClientAttackEvidence":
		return _LightClientAttackEvidence__ReprPrototype{}
	default:
		return nil
	}
}

type _Evidence__ReprKeyAssembler _Evidence__ReprAssembler

func (_Evidence__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Evidence__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Evidence__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignNull()
}
func (_Evidence__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Evidence__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Evidence__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Evidence__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dagcosmos.Evidence.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "duplicate":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "light":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Evidence.Repr", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_Evidence__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Evidence__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Evidence.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Evidence__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Evidence__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _EvidenceData) FieldEvidence() EvidenceList {
	return &n.Evidence
}

type _EvidenceData__Maybe struct {
	m schema.Maybe
	v EvidenceData
}
type MaybeEvidenceData = *_EvidenceData__Maybe

func (m MaybeEvidenceData) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeEvidenceData) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeEvidenceData) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeEvidenceData) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeEvidenceData) Must() EvidenceData {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__EvidenceData_Evidence = _String{"Evidence"}
)
var _ ipld.Node = (EvidenceData)(&_EvidenceData{})
var _ schema.TypedNode = (EvidenceData)(&_EvidenceData{})

func (EvidenceData) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n EvidenceData) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Evidence":
		return &n.Evidence, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n EvidenceData) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (EvidenceData) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.LookupByIndex(0)
}
func (n EvidenceData) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n EvidenceData) MapIterator() ipld.MapIterator {
	return &_EvidenceData__MapItr{n, 0}
}

type _EvidenceData__MapItr struct {
	n   EvidenceData
	idx int
}

func (itr *_EvidenceData__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__EvidenceData_Evidence
		v = &itr.n.Evidence
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_EvidenceData__MapItr) Done() bool {
	return itr.idx >= 1
}

func (EvidenceData) ListIterator() ipld.ListIterator {
	return nil
}
func (EvidenceData) Length() int64 {
	return 1
}
func (EvidenceData) IsAbsent() bool {
	return false
}
func (EvidenceData) IsNull() bool {
	return false
}
func (EvidenceData) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsBool()
}
func (EvidenceData) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsInt()
}
func (EvidenceData) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsFloat()
}
func (EvidenceData) AsString() (string, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsString()
}
func (EvidenceData) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsBytes()
}
func (EvidenceData) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.EvidenceData"}.AsLink()
}
func (EvidenceData) Prototype() ipld.NodePrototype {
	return _EvidenceData__Prototype{}
}

type _EvidenceData__Prototype struct{}

func (_EvidenceData__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _EvidenceData__Builder
	nb.Reset()
	return &nb
}

type _EvidenceData__Builder struct {
	_EvidenceData__Assembler
}

func (nb *_EvidenceData__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EvidenceData__Builder) Reset() {
	var w _EvidenceData
	var m schema.Maybe
	*nb = _EvidenceData__Builder{_EvidenceData__Assembler{w: &w, m: &m}}
}

type _EvidenceData__Assembler struct {
	w     *_EvidenceData
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm          schema.Maybe
	ca_Evidence _EvidenceList__Assembler
}

func (na *_EvidenceData__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Evidence.reset()
}

var (
	fieldBit__EvidenceData_Evidence    = 1 << 0
	fieldBits__EvidenceData_sufficient = 0 + 1<<0
)

func (na *_EvidenceData__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_EvidenceData{}
	}
	return na, nil
}
func (_EvidenceData__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.BeginList(0)
}
func (na *_EvidenceData__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EvidenceData__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignBool(false)
}
func (_EvidenceData__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignInt(0)
}
func (_EvidenceData__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignFloat(0)
}
func (_EvidenceData__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignString("")
}
func (_EvidenceData__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignBytes(nil)
}
func (_EvidenceData__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData"}.AssignLink(nil)
}
func (na *_EvidenceData__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EvidenceData); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.EvidenceData", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EvidenceData__Assembler) Prototype() ipld.NodePrototype {
	return _EvidenceData__Prototype{}
}
func (ma *_EvidenceData__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Evidence.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceData__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Evidence":
		if ma.s&fieldBit__EvidenceData_Evidence != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceData_Evidence}
		}
		ma.s += fieldBit__EvidenceData_Evidence
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceData", Key: &_String{k}}
}
func (ma *_EvidenceData__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_EvidenceData__KeyAssembler)(ma)
}
func (ma *_EvidenceData__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceData__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__EvidenceData_sufficient != fieldBits__EvidenceData_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__EvidenceData_Evidence == 0 {
			err.Missing = append(err.Missing, "Evidence")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EvidenceData__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_EvidenceData__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _EvidenceData__KeyAssembler _EvidenceData__Assembler

func (_EvidenceData__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.BeginMap(0)
}
func (_EvidenceData__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.BeginList(0)
}
func (na *_EvidenceData__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignNull()
}
func (_EvidenceData__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignBool(false)
}
func (_EvidenceData__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignInt(0)
}
func (_EvidenceData__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignFloat(0)
}
func (ka *_EvidenceData__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Evidence":
		if ka.s&fieldBit__EvidenceData_Evidence != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceData_Evidence}
		}
		ka.s += fieldBit__EvidenceData_Evidence
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceData", Key: &_String{k}}
	}
	return nil
}
func (_EvidenceData__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignBytes(nil)
}
func (_EvidenceData__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.KeyAssembler"}.AssignLink(nil)
}
func (ka *_EvidenceData__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_EvidenceData__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (EvidenceData) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n EvidenceData) Representation() ipld.Node {
	return (*_EvidenceData__Repr)(n)
}

type _EvidenceData__Repr _EvidenceData

var (
	fieldName__EvidenceData_Evidence_serial = _String{"Evidence"}
)
var _ ipld.Node = &_EvidenceData__Repr{}

func (_EvidenceData__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_EvidenceData__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Evidence":
		return n.Evidence.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_EvidenceData__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_EvidenceData__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.LookupByIndex(0)
}
func (n _EvidenceData__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_EvidenceData__Repr) MapIterator() ipld.MapIterator {
	return &_EvidenceData__ReprMapItr{n, 0}
}

type _EvidenceData__ReprMapItr struct {
	n   *_EvidenceData__Repr
	idx int
}

func (itr *_EvidenceData__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__EvidenceData_Evidence_serial
		v = itr.n.Evidence.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_EvidenceData__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_EvidenceData__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_EvidenceData__Repr) Length() int64 {
	l := 1
	return int64(l)
}
func (_EvidenceData__Repr) IsAbsent() bool {
	return false
}
func (_EvidenceData__Repr) IsNull() bool {
	return false
}
func (_EvidenceData__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsBool()
}
func (_EvidenceData__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsInt()
}
func (_EvidenceData__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsFloat()
}
func (_EvidenceData__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsString()
}
func (_EvidenceData__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsBytes()
}
func (_EvidenceData__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.EvidenceData.Repr"}.AsLink()
}
func (_EvidenceData__Repr) Prototype() ipld.NodePrototype {
	return _EvidenceData__ReprPrototype{}
}

type _EvidenceData__ReprPrototype struct{}

func (_EvidenceData__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _EvidenceData__ReprBuilder
	nb.Reset()
	return &nb
}

type _EvidenceData__ReprBuilder struct {
	_EvidenceData__ReprAssembler
}

func (nb *_EvidenceData__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EvidenceData__ReprBuilder) Reset() {
	var w _EvidenceData
	var m schema.Maybe
	*nb = _EvidenceData__ReprBuilder{_EvidenceData__ReprAssembler{w: &w, m: &m}}
}

type _EvidenceData__ReprAssembler struct {
	w     *_EvidenceData
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm          schema.Maybe
	ca_Evidence _EvidenceList__ReprAssembler
}

func (na *_EvidenceData__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Evidence.reset()
}
func (na *_EvidenceData__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_EvidenceData{}
	}
	return na, nil
}
func (_EvidenceData__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.BeginList(0)
}
func (na *_EvidenceData__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EvidenceData__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignBool(false)
}
func (_EvidenceData__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignInt(0)
}
func (_EvidenceData__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignFloat(0)
}
func (_EvidenceData__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignString("")
}
func (_EvidenceData__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignBytes(nil)
}
func (_EvidenceData__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceData.Repr"}.AssignLink(nil)
}
func (na *_EvidenceData__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EvidenceData); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.EvidenceData.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EvidenceData__ReprAssembler) Prototype() ipld.NodePrototype {
	return _EvidenceData__ReprPrototype{}
}
func (ma *_EvidenceData__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceData__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Evidence":
		if ma.s&fieldBit__EvidenceData_Evidence != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceData_Evidence_serial}
		}
		ma.s += fieldBit__EvidenceData_Evidence
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceData.Repr", Key: &_String{k}}
}
func (ma *_EvidenceData__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_EvidenceData__ReprKeyAssembler)(ma)
}
func (ma *_EvidenceData__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Evidence.w = &ma.w.Evidence
		ma.ca_Evidence.m = &ma.cm
		return &ma.ca_Evidence
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceData__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__EvidenceData_sufficient != fieldBits__EvidenceData_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__EvidenceData_Evidence == 0 {
			err.Missing = append(err.Missing, "Evidence")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EvidenceData__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_EvidenceData__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _EvidenceData__ReprKeyAssembler _EvidenceData__ReprAssembler

func (_EvidenceData__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.BeginMap(0)
}
func (_EvidenceData__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_EvidenceData__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignNull()
}
func (_EvidenceData__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignBool(false)
}
func (_EvidenceData__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignInt(0)
}
func (_EvidenceData__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_EvidenceData__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Evidence":
		if ka.s&fieldBit__EvidenceData_Evidence != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceData_Evidence_serial}
		}
		ka.s += fieldBit__EvidenceData_Evidence
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceData.Repr", Key: &_String{k}}
}
func (_EvidenceData__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_EvidenceData__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceData.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_EvidenceData__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_EvidenceData__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_EvidenceList) Lookup(idx int64) Evidence {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_EvidenceList) LookupMaybe(idx int64) MaybeEvidence {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Evidence__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _EvidenceList__valueAbsent = _Evidence__Maybe{m: schema.Maybe_Absent}

func (n EvidenceList) Iterator() *EvidenceList__Itr {
	return &EvidenceList__Itr{n, 0}
}

type EvidenceList__Itr struct {
	n   EvidenceList
	idx int
}

func (itr *EvidenceList__Itr) Next() (idx int64, v Evidence) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *EvidenceList__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _EvidenceList__Maybe struct {
	m schema.Maybe
	v EvidenceList
}
type MaybeEvidenceList = *_EvidenceList__Maybe

func (m MaybeEvidenceList) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeEvidenceList) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeEvidenceList) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeEvidenceList) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeEvidenceList) Must() EvidenceList {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (EvidenceList)(&_EvidenceList{})
var _ schema.TypedNode = (EvidenceList)(&_EvidenceList{})

func (EvidenceList) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (EvidenceList) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.LookupByString("")
}
func (n EvidenceList) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n EvidenceList) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n EvidenceList) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.EvidenceList", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (EvidenceList) MapIterator() ipld.MapIterator {
	return nil
}
func (n EvidenceList) ListIterator() ipld.ListIterator {
	return &_EvidenceList__ListItr{n, 0}
}

type _EvidenceList__ListItr struct {
	n   EvidenceList
	idx int
}

func (itr *_EvidenceList__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_EvidenceList__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n EvidenceList) Length() int64 {
	return int64(len(n.x))
}
func (EvidenceList) IsAbsent() bool {
	return false
}
func (EvidenceList) IsNull() bool {
	return false
}
func (EvidenceList) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsBool()
}
func (EvidenceList) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsInt()
}
func (EvidenceList) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsFloat()
}
func (EvidenceList) AsString() (string, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsString()
}
func (EvidenceList) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsBytes()
}
func (EvidenceList) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.EvidenceList"}.AsLink()
}
func (EvidenceList) Prototype() ipld.NodePrototype {
	return _EvidenceList__Prototype{}
}

type _EvidenceList__Prototype struct{}

func (_EvidenceList__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _EvidenceList__Builder
	nb.Reset()
	return &nb
}

type _EvidenceList__Builder struct {
	_EvidenceList__Assembler
}

func (nb *_EvidenceList__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EvidenceList__Builder) Reset() {
	var w _EvidenceList
	var m schema.Maybe
	*nb = _EvidenceList__Builder{_EvidenceList__Assembler{w: &w, m: &m}}
}

type _EvidenceList__Assembler struct {
	w     *_EvidenceList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Evidence__Assembler
}

func (na *_EvidenceList__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_EvidenceList__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.BeginMap(0)
}
func (na *_EvidenceList__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_EvidenceList{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Evidence, 0, sizeHint)
	}
	return na, nil
}
func (na *_EvidenceList__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EvidenceList__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignBool(false)
}
func (_EvidenceList__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignInt(0)
}
func (_EvidenceList__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignFloat(0)
}
func (_EvidenceList__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignString("")
}
func (_EvidenceList__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignBytes(nil)
}
func (_EvidenceList__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList"}.AssignLink(nil)
}
func (na *_EvidenceList__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EvidenceList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.EvidenceList", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EvidenceList__Assembler) Prototype() ipld.NodePrototype {
	return _EvidenceList__Prototype{}
}
func (la *_EvidenceList__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_EvidenceList__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Evidence{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_EvidenceList__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_EvidenceList__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Evidence__Prototype{}
}
func (EvidenceList) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n EvidenceList) Representation() ipld.Node {
	return (*_EvidenceList__Repr)(n)
}

type _EvidenceList__Repr _EvidenceList

var _ ipld.Node = &_EvidenceList__Repr{}

func (_EvidenceList__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_EvidenceList__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.LookupByString("")
}
func (nr *_EvidenceList__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (EvidenceList)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Evidence).Representation(), nil
}
func (nr *_EvidenceList__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (EvidenceList)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Evidence).Representation(), nil
}
func (n _EvidenceList__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.EvidenceList.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_EvidenceList__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_EvidenceList__Repr) ListIterator() ipld.ListIterator {
	return &_EvidenceList__ReprListItr{(EvidenceList)(nr), 0}
}

type _EvidenceList__ReprListItr _EvidenceList__ListItr

func (itr *_EvidenceList__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_EvidenceList__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Evidence).Representation(), nil
}
func (itr *_EvidenceList__ReprListItr) Done() bool {
	return (*_EvidenceList__ListItr)(itr).Done()
}

func (rn *_EvidenceList__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_EvidenceList__Repr) IsAbsent() bool {
	return false
}
func (_EvidenceList__Repr) IsNull() bool {
	return false
}
func (_EvidenceList__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsBool()
}
func (_EvidenceList__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsInt()
}
func (_EvidenceList__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsFloat()
}
func (_EvidenceList__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsString()
}
func (_EvidenceList__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsBytes()
}
func (_EvidenceList__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.EvidenceList.Repr"}.AsLink()
}
func (_EvidenceList__Repr) Prototype() ipld.NodePrototype {
	return _EvidenceList__ReprPrototype{}
}

type _EvidenceList__ReprPrototype struct{}

func (_EvidenceList__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _EvidenceList__ReprBuilder
	nb.Reset()
	return &nb
}

type _EvidenceList__ReprBuilder struct {
	_EvidenceList__ReprAssembler
}

func (nb *_EvidenceList__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EvidenceList__ReprBuilder) Reset() {
	var w _EvidenceList
	var m schema.Maybe
	*nb = _EvidenceList__ReprBuilder{_EvidenceList__ReprAssembler{w: &w, m: &m}}
}

type _EvidenceList__ReprAssembler struct {
	w     *_EvidenceList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Evidence__ReprAssembler
}

func (na *_EvidenceList__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_EvidenceList__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.BeginMap(0)
}
func (na *_EvidenceList__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_EvidenceList{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Evidence, 0, sizeHint)
	}
	return na, nil
}
func (na *_EvidenceList__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EvidenceList__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignBool(false)
}
func (_EvidenceList__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignInt(0)
}
func (_EvidenceList__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignFloat(0)
}
func (_EvidenceList__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignString("")
}
func (_EvidenceList__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignBytes(nil)
}
func (_EvidenceList__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.EvidenceList.Repr"}.AssignLink(nil)
}
func (na *_EvidenceList__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EvidenceList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.EvidenceList.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EvidenceList__ReprAssembler) Prototype() ipld.NodePrototype {
	return _EvidenceList__ReprPrototype{}
}
func (la *_EvidenceList__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_EvidenceList__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Evidence{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_EvidenceList__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_EvidenceList__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Evidence__ReprPrototype{}
}

func (n _EvidenceParams) FieldMaxAgeNumBlocks() Int {
	return &n.MaxAgeNumBlocks
}
func (n _EvidenceParams) FieldMaxAgeDuration() Duration {
	return &n.MaxAgeDuration
}
func (n _EvidenceParams) FieldMaxBytes() Int {
	return &n.MaxBytes
}

type _EvidenceParams__Maybe struct {
	m schema.Maybe
	v EvidenceParams
}
type MaybeEvidenceParams = *_EvidenceParams__Maybe

func (m MaybeEvidenceParams) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeEvidenceParams) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeEvidenceParams) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeEvidenceParams) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeEvidenceParams) Must() EvidenceParams {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__EvidenceParams_MaxAgeNumBlocks = _String{"MaxAgeNumBlocks"}
	fieldName__EvidenceParams_MaxAgeDuration  = _String{"MaxAgeDuration"}
	fieldName__EvidenceParams_MaxBytes        = _String{"MaxBytes"}
)
var _ ipld.Node = (EvidenceParams)(&_EvidenceParams{})
var _ schema.TypedNode = (EvidenceParams)(&_EvidenceParams{})

func (EvidenceParams) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n EvidenceParams) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "MaxAgeNumBlocks":
		return &n.MaxAgeNumBlocks, nil
	case "MaxAgeDuration":
		return &n.MaxAgeDuration, nil
	case "MaxBytes":
		return &n.MaxBytes, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n EvidenceParams) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (EvidenceParams) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.EvidenceParams"}.LookupByIndex(0)
}
func (n EvidenceParams) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n EvidenceParams) MapIterator() ipld.MapIterator {
	return &_EvidenceParams__MapItr{n, 0}
}

type _EvidenceParams__MapItr struct {
	n   EvidenceParams
	idx int
}

func (itr *_EvidenceParams__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__EvidenceParams_MaxAgeNumBlocks
		v = &itr.n.MaxAgeNumBlocks
	case 1:
		k = &fieldName__EvidenceParams_MaxAgeDuration
		v = &itr.n.MaxAgeDuration
	case 2:
		k = &fieldName__EvidenceParams_MaxBytes
		v = &itr.n.MaxBytes
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_EvidenceParams__MapItr) Done() bool {
	return itr.idx >= 3
}

func (EvidenceParams) ListIterator() ipld.ListIterator {
	return nil
}
func (EvidenceParams) Length() int64 {
	return 3
}
func (EvidenceParams) IsAbsent() bool {
	return false
}
func (EvidenceParams) IsNull() bool {
	return false
}
func (EvidenceParams) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.EvidenceParams"}.AsBool()
}
func (EvidenceParams) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.EvidenceParams"}.AsInt()
}
func (EvidenceParams) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.EvidenceParams"}.AsFloat()
}
func (EvidenceParams) AsString() (string, error) {
	return mixins.Map{"dagcosmos.EvidenceParams"}.AsString()
}
func (EvidenceParams) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.EvidenceParams"}.AsBytes()
}
func (EvidenceParams) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.EvidenceParams"}.AsLink()
}
func (EvidenceParams) Prototype() ipld.NodePrototype {
	return _EvidenceParams__Prototype{}
}

type _EvidenceParams__Prototype struct{}

func (_EvidenceParams__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _EvidenceParams__Builder
	nb.Reset()
	return &nb
}

type _EvidenceParams__Builder struct {
	_EvidenceParams__Assembler
}

func (nb *_EvidenceParams__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EvidenceParams__Builder) Reset() {
	var w _EvidenceParams
	var m schema.Maybe
	*nb = _EvidenceParams__Builder{_EvidenceParams__Assembler{w: &w, m: &m}}
}

type _EvidenceParams__Assembler struct {
	w     *_EvidenceParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                 schema.Maybe
	ca_MaxAgeNumBlocks _Int__Assembler
	ca_MaxAgeDuration  _Duration__Assembler
	ca_MaxBytes        _Int__Assembler
}

func (na *_EvidenceParams__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_MaxAgeNumBlocks.reset()
	na.ca_MaxAgeDuration.reset()
	na.ca_MaxBytes.reset()
}

var (
	fieldBit__EvidenceParams_MaxAgeNumBlocks = 1 << 0
	fieldBit__EvidenceParams_MaxAgeDuration  = 1 << 1
	fieldBit__EvidenceParams_MaxBytes        = 1 << 2
	fieldBits__EvidenceParams_sufficient     = 0 + 1<<0 + 1<<1 + 1<<2
)

func (na *_EvidenceParams__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_EvidenceParams{}
	}
	return na, nil
}
func (_EvidenceParams__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams"}.BeginList(0)
}
func (na *_EvidenceParams__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.EvidenceParams"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EvidenceParams__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams"}.AssignBool(false)
}
func (_EvidenceParams__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams"}.AssignInt(0)
}
func (_EvidenceParams__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams"}.AssignFloat(0)
}
func (_EvidenceParams__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams"}.AssignString("")
}
func (_EvidenceParams__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams"}.AssignBytes(nil)
}
func (_EvidenceParams__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams"}.AssignLink(nil)
}
func (na *_EvidenceParams__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EvidenceParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.EvidenceParams", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EvidenceParams__Assembler) Prototype() ipld.NodePrototype {
	return _EvidenceParams__Prototype{}
}
func (ma *_EvidenceParams__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_MaxAgeNumBlocks.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_MaxAgeDuration.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_MaxBytes.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceParams__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "MaxAgeNumBlocks":
		if ma.s&fieldBit__EvidenceParams_MaxAgeNumBlocks != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxAgeNumBlocks}
		}
		ma.s += fieldBit__EvidenceParams_MaxAgeNumBlocks
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_MaxAgeNumBlocks.w = &ma.w.MaxAgeNumBlocks
		ma.ca_MaxAgeNumBlocks.m = &ma.cm
		return &ma.ca_MaxAgeNumBlocks, nil
	case "MaxAgeDuration":
		if ma.s&fieldBit__EvidenceParams_MaxAgeDuration != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxAgeDuration}
		}
		ma.s += fieldBit__EvidenceParams_MaxAgeDuration
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_MaxAgeDuration.w = &ma.w.MaxAgeDuration
		ma.ca_MaxAgeDuration.m = &ma.cm
		return &ma.ca_MaxAgeDuration, nil
	case "MaxBytes":
		if ma.s&fieldBit__EvidenceParams_MaxBytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxBytes}
		}
		ma.s += fieldBit__EvidenceParams_MaxBytes
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_MaxBytes.w = &ma.w.MaxBytes
		ma.ca_MaxBytes.m = &ma.cm
		return &ma.ca_MaxBytes, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceParams", Key: &_String{k}}
}
func (ma *_EvidenceParams__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_EvidenceParams__KeyAssembler)(ma)
}
func (ma *_EvidenceParams__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_MaxAgeNumBlocks.w = &ma.w.MaxAgeNumBlocks
		ma.ca_MaxAgeNumBlocks.m = &ma.cm
		return &ma.ca_MaxAgeNumBlocks
	case 1:
		ma.ca_MaxAgeDuration.w = &ma.w.MaxAgeDuration
		ma.ca_MaxAgeDuration.m = &ma.cm
		return &ma.ca_MaxAgeDuration
	case 2:
		ma.ca_MaxBytes.w = &ma.w.MaxBytes
		ma.ca_MaxBytes.m = &ma.cm
		return &ma.ca_MaxBytes
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceParams__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__EvidenceParams_sufficient != fieldBits__EvidenceParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__EvidenceParams_MaxAgeNumBlocks == 0 {
			err.Missing = append(err.Missing, "MaxAgeNumBlocks")
		}
		if ma.s&fieldBit__EvidenceParams_MaxAgeDuration == 0 {
			err.Missing = append(err.Missing, "MaxAgeDuration")
		}
		if ma.s&fieldBit__EvidenceParams_MaxBytes == 0 {
			err.Missing = append(err.Missing, "MaxBytes")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EvidenceParams__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_EvidenceParams__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _EvidenceParams__KeyAssembler _EvidenceParams__Assembler

func (_EvidenceParams__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.KeyAssembler"}.BeginMap(0)
}
func (_EvidenceParams__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.KeyAssembler"}.BeginList(0)
}
func (na *_EvidenceParams__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.KeyAssembler"}.AssignNull()
}
func (_EvidenceParams__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.KeyAssembler"}.AssignBool(false)
}
func (_EvidenceParams__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.KeyAssembler"}.AssignInt(0)
}
func (_EvidenceParams__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.KeyAssembler"}.AssignFloat(0)
}
func (ka *_EvidenceParams__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "MaxAgeNumBlocks":
		if ka.s&fieldBit__EvidenceParams_MaxAgeNumBlocks != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxAgeNumBlocks}
		}
		ka.s += fieldBit__EvidenceParams_MaxAgeNumBlocks
		ka.state = maState_expectValue
		ka.f = 0
	case "MaxAgeDuration":
		if ka.s&fieldBit__EvidenceParams_MaxAgeDuration != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxAgeDuration}
		}
		ka.s += fieldBit__EvidenceParams_MaxAgeDuration
		ka.state = maState_expectValue
		ka.f = 1
	case "MaxBytes":
		if ka.s&fieldBit__EvidenceParams_MaxBytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxBytes}
		}
		ka.s += fieldBit__EvidenceParams_MaxBytes
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceParams", Key: &_String{k}}
	}
	return nil
}
func (_EvidenceParams__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.KeyAssembler"}.AssignBytes(nil)
}
func (_EvidenceParams__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.KeyAssembler"}.AssignLink(nil)
}
func (ka *_EvidenceParams__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_EvidenceParams__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (EvidenceParams) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n EvidenceParams) Representation() ipld.Node {
	return (*_EvidenceParams__Repr)(n)
}

type _EvidenceParams__Repr _EvidenceParams

var (
	fieldName__EvidenceParams_MaxAgeNumBlocks_serial = _String{"MaxAgeNumBlocks"}
	fieldName__EvidenceParams_MaxAgeDuration_serial  = _String{"MaxAgeDuration"}
	fieldName__EvidenceParams_MaxBytes_serial        = _String{"MaxBytes"}
)
var _ ipld.Node = &_EvidenceParams__Repr{}

func (_EvidenceParams__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_EvidenceParams__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "MaxAgeNumBlocks":
		return n.MaxAgeNumBlocks.Representation(), nil
	case "MaxAgeDuration":
		return n.MaxAgeDuration.Representation(), nil
	case "MaxBytes":
		return n.MaxBytes.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_EvidenceParams__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_EvidenceParams__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.EvidenceParams.Repr"}.LookupByIndex(0)
}
func (n _EvidenceParams__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_EvidenceParams__Repr) MapIterator() ipld.MapIterator {
	return &_EvidenceParams__ReprMapItr{n, 0}
}

type _EvidenceParams__ReprMapItr struct {
	n   *_EvidenceParams__Repr
	idx int
}

func (itr *_EvidenceParams__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__EvidenceParams_MaxAgeNumBlocks_serial
		v = itr.n.MaxAgeNumBlocks.Representation()
	case 1:
		k = &fieldName__EvidenceParams_MaxAgeDuration_serial
		v = itr.n.MaxAgeDuration.Representation()
	case 2:
		k = &fieldName__EvidenceParams_MaxBytes_serial
		v = itr.n.MaxBytes.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_EvidenceParams__ReprMapItr) Done() bool {
	return itr.idx >= 3
}
func (_EvidenceParams__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_EvidenceParams__Repr) Length() int64 {
	l := 3
	return int64(l)
}
func (_EvidenceParams__Repr) IsAbsent() bool {
	return false
}
func (_EvidenceParams__Repr) IsNull() bool {
	return false
}
func (_EvidenceParams__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.EvidenceParams.Repr"}.AsBool()
}
func (_EvidenceParams__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.EvidenceParams.Repr"}.AsInt()
}
func (_EvidenceParams__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.EvidenceParams.Repr"}.AsFloat()
}
func (_EvidenceParams__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.EvidenceParams.Repr"}.AsString()
}
func (_EvidenceParams__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.EvidenceParams.Repr"}.AsBytes()
}
func (_EvidenceParams__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.EvidenceParams.Repr"}.AsLink()
}
func (_EvidenceParams__Repr) Prototype() ipld.NodePrototype {
	return _EvidenceParams__ReprPrototype{}
}

type _EvidenceParams__ReprPrototype struct{}

func (_EvidenceParams__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _EvidenceParams__ReprBuilder
	nb.Reset()
	return &nb
}

type _EvidenceParams__ReprBuilder struct {
	_EvidenceParams__ReprAssembler
}

func (nb *_EvidenceParams__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_EvidenceParams__ReprBuilder) Reset() {
	var w _EvidenceParams
	var m schema.Maybe
	*nb = _EvidenceParams__ReprBuilder{_EvidenceParams__ReprAssembler{w: &w, m: &m}}
}

type _EvidenceParams__ReprAssembler struct {
	w     *_EvidenceParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                 schema.Maybe
	ca_MaxAgeNumBlocks _Int__ReprAssembler
	ca_MaxAgeDuration  _Duration__ReprAssembler
	ca_MaxBytes        _Int__ReprAssembler
}

func (na *_EvidenceParams__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_MaxAgeNumBlocks.reset()
	na.ca_MaxAgeDuration.reset()
	na.ca_MaxBytes.reset()
}
func (na *_EvidenceParams__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_EvidenceParams{}
	}
	return na, nil
}
func (_EvidenceParams__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams.Repr"}.BeginList(0)
}
func (na *_EvidenceParams__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.EvidenceParams.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_EvidenceParams__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams.Repr"}.AssignBool(false)
}
func (_EvidenceParams__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams.Repr"}.AssignInt(0)
}
func (_EvidenceParams__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams.Repr"}.AssignFloat(0)
}
func (_EvidenceParams__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams.Repr"}.AssignString("")
}
func (_EvidenceParams__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams.Repr"}.AssignBytes(nil)
}
func (_EvidenceParams__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.EvidenceParams.Repr"}.AssignLink(nil)
}
func (na *_EvidenceParams__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_EvidenceParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.EvidenceParams.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_EvidenceParams__ReprAssembler) Prototype() ipld.NodePrototype {
	return _EvidenceParams__ReprPrototype{}
}
func (ma *_EvidenceParams__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceParams__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "MaxAgeNumBlocks":
		if ma.s&fieldBit__EvidenceParams_MaxAgeNumBlocks != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxAgeNumBlocks_serial}
		}
		ma.s += fieldBit__EvidenceParams_MaxAgeNumBlocks
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_MaxAgeNumBlocks.w = &ma.w.MaxAgeNumBlocks
		ma.ca_MaxAgeNumBlocks.m = &ma.cm
		return &ma.ca_MaxAgeNumBlocks, nil
	case "MaxAgeDuration":
		if ma.s&fieldBit__EvidenceParams_MaxAgeDuration != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxAgeDuration_serial}
		}
		ma.s += fieldBit__EvidenceParams_MaxAgeDuration
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_MaxAgeDuration.w = &ma.w.MaxAgeDuration
		ma.ca_MaxAgeDuration.m = &ma.cm
		return &ma.ca_MaxAgeDuration, nil
	case "MaxBytes":
		if ma.s&fieldBit__EvidenceParams_MaxBytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxBytes_serial}
		}
		ma.s += fieldBit__EvidenceParams_MaxBytes
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_MaxBytes.w = &ma.w.MaxBytes
		ma.ca_MaxBytes.m = &ma.cm
		return &ma.ca_MaxBytes, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceParams.Repr", Key: &_String{k}}
}
func (ma *_EvidenceParams__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_EvidenceParams__ReprKeyAssembler)(ma)
}
func (ma *_EvidenceParams__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_MaxAgeNumBlocks.w = &ma.w.MaxAgeNumBlocks
		ma.ca_MaxAgeNumBlocks.m = &ma.cm
		return &ma.ca_MaxAgeNumBlocks
	case 1:
		ma.ca_MaxAgeDuration.w = &ma.w.MaxAgeDuration
		ma.ca_MaxAgeDuration.m = &ma.cm
		return &ma.ca_MaxAgeDuration
	case 2:
		ma.ca_MaxBytes.w = &ma.w.MaxBytes
		ma.ca_MaxBytes.m = &ma.cm
		return &ma.ca_MaxBytes
	default:
		panic("unreachable")
	}
}
func (ma *_EvidenceParams__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__EvidenceParams_sufficient != fieldBits__EvidenceParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__EvidenceParams_MaxAgeNumBlocks == 0 {
			err.Missing = append(err.Missing, "MaxAgeNumBlocks")
		}
		if ma.s&fieldBit__EvidenceParams_MaxAgeDuration == 0 {
			err.Missing = append(err.Missing, "MaxAgeDuration")
		}
		if ma.s&fieldBit__EvidenceParams_MaxBytes == 0 {
			err.Missing = append(err.Missing, "MaxBytes")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_EvidenceParams__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_EvidenceParams__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _EvidenceParams__ReprKeyAssembler _EvidenceParams__ReprAssembler

func (_EvidenceParams__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.Repr.KeyAssembler"}.BeginMap(0)
}
func (_EvidenceParams__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_EvidenceParams__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.Repr.KeyAssembler"}.AssignNull()
}
func (_EvidenceParams__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.Repr.KeyAssembler"}.AssignBool(false)
}
func (_EvidenceParams__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.Repr.KeyAssembler"}.AssignInt(0)
}
func (_EvidenceParams__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_EvidenceParams__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "MaxAgeNumBlocks":
		if ka.s&fieldBit__EvidenceParams_MaxAgeNumBlocks != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxAgeNumBlocks_serial}
		}
		ka.s += fieldBit__EvidenceParams_MaxAgeNumBlocks
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "MaxAgeDuration":
		if ka.s&fieldBit__EvidenceParams_MaxAgeDuration != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxAgeDuration_serial}
		}
		ka.s += fieldBit__EvidenceParams_MaxAgeDuration
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "MaxBytes":
		if ka.s&fieldBit__EvidenceParams_MaxBytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__EvidenceParams_MaxBytes_serial}
		}
		ka.s += fieldBit__EvidenceParams_MaxBytes
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.EvidenceParams.Repr", Key: &_String{k}}
}
func (_EvidenceParams__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_EvidenceParams__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.EvidenceParams.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_EvidenceParams__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_EvidenceParams__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Hash) Bytes() []byte {
	return n.x
}
func (_Hash__Prototype) FromBytes(v []byte) (Hash, error) {
	n := _Hash{v}
	return &n, nil
}

type _Hash__Maybe struct {
	m schema.Maybe
	v Hash
}
type MaybeHash = *_Hash__Maybe

func (m MaybeHash) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHash) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHash) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHash) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHash) Must() Hash {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Hash)(&_Hash{})
var _ schema.TypedNode = (Hash)(&_Hash{})

func (Hash) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Hash) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.LookupByString("")
}
func (Hash) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.LookupByNode(nil)
}
func (Hash) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.LookupByIndex(0)
}
func (Hash) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.LookupBySegment(seg)
}
func (Hash) MapIterator() ipld.MapIterator {
	return nil
}
func (Hash) ListIterator() ipld.ListIterator {
	return nil
}
func (Hash) Length() int64 {
	return -1
}
func (Hash) IsAbsent() bool {
	return false
}
func (Hash) IsNull() bool {
	return false
}
func (Hash) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.AsBool()
}
func (Hash) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.AsInt()
}
func (Hash) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.AsFloat()
}
func (Hash) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.AsString()
}
func (n Hash) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Hash) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Hash"}.AsLink()
}
func (Hash) Prototype() ipld.NodePrototype {
	return _Hash__Prototype{}
}

type _Hash__Prototype struct{}

func (_Hash__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Hash__Builder
	nb.Reset()
	return &nb
}

type _Hash__Builder struct {
	_Hash__Assembler
}

func (nb *_Hash__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Hash__Builder) Reset() {
	var w _Hash
	var m schema.Maybe
	*nb = _Hash__Builder{_Hash__Assembler{w: &w, m: &m}}
}

type _Hash__Assembler struct {
	w *_Hash
	m *schema.Maybe
}

func (na *_Hash__Assembler) reset() {}
func (_Hash__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.BeginMap(0)
}
func (_Hash__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.BeginList(0)
}
func (na *_Hash__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Hash__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignBool(false)
}
func (_Hash__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignInt(0)
}
func (_Hash__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignFloat(0)
}
func (_Hash__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignString("")
}
func (na *_Hash__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Hash{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Hash__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Hash"}.AssignLink(nil)
}
func (na *_Hash__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Hash); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Hash__Assembler) Prototype() ipld.NodePrototype {
	return _Hash__Prototype{}
}
func (Hash) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Hash) Representation() ipld.Node {
	return (*_Hash__Repr)(n)
}

type _Hash__Repr = _Hash

var _ ipld.Node = &_Hash__Repr{}

type _Hash__ReprPrototype = _Hash__Prototype
type _Hash__ReprAssembler = _Hash__Assembler

func (n _HashedParams) FieldBlockMaxBytes() Int {
	return &n.BlockMaxBytes
}
func (n _HashedParams) FieldBlockMaxGas() Int {
	return &n.BlockMaxGas
}

type _HashedParams__Maybe struct {
	m schema.Maybe
	v HashedParams
}
type MaybeHashedParams = *_HashedParams__Maybe

func (m MaybeHashedParams) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHashedParams) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHashedParams) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHashedParams) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHashedParams) Must() HashedParams {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__HashedParams_BlockMaxBytes = _String{"BlockMaxBytes"}
	fieldName__HashedParams_BlockMaxGas   = _String{"BlockMaxGas"}
)
var _ ipld.Node = (HashedParams)(&_HashedParams{})
var _ schema.TypedNode = (HashedParams)(&_HashedParams{})

func (HashedParams) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n HashedParams) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "BlockMaxBytes":
		return &n.BlockMaxBytes, nil
	case "BlockMaxGas":
		return &n.BlockMaxGas, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n HashedParams) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (HashedParams) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.LookupByIndex(0)
}
func (n HashedParams) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n HashedParams) MapIterator() ipld.MapIterator {
	return &_HashedParams__MapItr{n, 0}
}

type _HashedParams__MapItr struct {
	n   HashedParams
	idx int
}

func (itr *_HashedParams__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__HashedParams_BlockMaxBytes
		v = &itr.n.BlockMaxBytes
	case 1:
		k = &fieldName__HashedParams_BlockMaxGas
		v = &itr.n.BlockMaxGas
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_HashedParams__MapItr) Done() bool {
	return itr.idx >= 2
}

func (HashedParams) ListIterator() ipld.ListIterator {
	return nil
}
func (HashedParams) Length() int64 {
	return 2
}
func (HashedParams) IsAbsent() bool {
	return false
}
func (HashedParams) IsNull() bool {
	return false
}
func (HashedParams) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsBool()
}
func (HashedParams) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsInt()
}
func (HashedParams) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsFloat()
}
func (HashedParams) AsString() (string, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsString()
}
func (HashedParams) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsBytes()
}
func (HashedParams) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.HashedParams"}.AsLink()
}
func (HashedParams) Prototype() ipld.NodePrototype {
	return _HashedParams__Prototype{}
}

type _HashedParams__Prototype struct{}

func (_HashedParams__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _HashedParams__Builder
	nb.Reset()
	return &nb
}

type _HashedParams__Builder struct {
	_HashedParams__Assembler
}

func (nb *_HashedParams__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_HashedParams__Builder) Reset() {
	var w _HashedParams
	var m schema.Maybe
	*nb = _HashedParams__Builder{_HashedParams__Assembler{w: &w, m: &m}}
}

type _HashedParams__Assembler struct {
	w     *_HashedParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm               schema.Maybe
	ca_BlockMaxBytes _Int__Assembler
	ca_BlockMaxGas   _Int__Assembler
}

func (na *_HashedParams__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_BlockMaxBytes.reset()
	na.ca_BlockMaxGas.reset()
}

var (
	fieldBit__HashedParams_BlockMaxBytes = 1 << 0
	fieldBit__HashedParams_BlockMaxGas   = 1 << 1
	fieldBits__HashedParams_sufficient   = 0 + 1<<0 + 1<<1
)

func (na *_HashedParams__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_HashedParams{}
	}
	return na, nil
}
func (_HashedParams__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.BeginList(0)
}
func (na *_HashedParams__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_HashedParams__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignBool(false)
}
func (_HashedParams__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignInt(0)
}
func (_HashedParams__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignFloat(0)
}
func (_HashedParams__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignString("")
}
func (_HashedParams__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignBytes(nil)
}
func (_HashedParams__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams"}.AssignLink(nil)
}
func (na *_HashedParams__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_HashedParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.HashedParams", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_HashedParams__Assembler) Prototype() ipld.NodePrototype {
	return _HashedParams__Prototype{}
}
func (ma *_HashedParams__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockMaxBytes.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockMaxGas.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_HashedParams__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "BlockMaxBytes":
		if ma.s&fieldBit__HashedParams_BlockMaxBytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxBytes}
		}
		ma.s += fieldBit__HashedParams_BlockMaxBytes
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_BlockMaxBytes.w = &ma.w.BlockMaxBytes
		ma.ca_BlockMaxBytes.m = &ma.cm
		return &ma.ca_BlockMaxBytes, nil
	case "BlockMaxGas":
		if ma.s&fieldBit__HashedParams_BlockMaxGas != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxGas}
		}
		ma.s += fieldBit__HashedParams_BlockMaxGas
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_BlockMaxGas.w = &ma.w.BlockMaxGas
		ma.ca_BlockMaxGas.m = &ma.cm
		return &ma.ca_BlockMaxGas, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.HashedParams", Key: &_String{k}}
}
func (ma *_HashedParams__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_HashedParams__KeyAssembler)(ma)
}
func (ma *_HashedParams__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_BlockMaxBytes.w = &ma.w.BlockMaxBytes
		ma.ca_BlockMaxBytes.m = &ma.cm
		return &ma.ca_BlockMaxBytes
	case 1:
		ma.ca_BlockMaxGas.w = &ma.w.BlockMaxGas
		ma.ca_BlockMaxGas.m = &ma.cm
		return &ma.ca_BlockMaxGas
	default:
		panic("unreachable")
	}
}
func (ma *_HashedParams__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__HashedParams_sufficient != fieldBits__HashedParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__HashedParams_BlockMaxBytes == 0 {
			err.Missing = append(err.Missing, "BlockMaxBytes")
		}
		if ma.s&fieldBit__HashedParams_BlockMaxGas == 0 {
			err.Missing = append(err.Missing, "BlockMaxGas")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_HashedParams__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_HashedParams__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _HashedParams__KeyAssembler _HashedParams__Assembler

func (_HashedParams__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.BeginMap(0)
}
func (_HashedParams__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.BeginList(0)
}
func (na *_HashedParams__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignNull()
}
func (_HashedParams__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignBool(false)
}
func (_HashedParams__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignInt(0)
}
func (_HashedParams__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignFloat(0)
}
func (ka *_HashedParams__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "BlockMaxBytes":
		if ka.s&fieldBit__HashedParams_BlockMaxBytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxBytes}
		}
		ka.s += fieldBit__HashedParams_BlockMaxBytes
		ka.state = maState_expectValue
		ka.f = 0
	case "BlockMaxGas":
		if ka.s&fieldBit__HashedParams_BlockMaxGas != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxGas}
		}
		ka.s += fieldBit__HashedParams_BlockMaxGas
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.HashedParams", Key: &_String{k}}
	}
	return nil
}
func (_HashedParams__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignBytes(nil)
}
func (_HashedParams__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.KeyAssembler"}.AssignLink(nil)
}
func (ka *_HashedParams__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_HashedParams__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (HashedParams) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n HashedParams) Representation() ipld.Node {
	return (*_HashedParams__Repr)(n)
}

type _HashedParams__Repr _HashedParams

var (
	fieldName__HashedParams_BlockMaxBytes_serial = _String{"BlockMaxBytes"}
	fieldName__HashedParams_BlockMaxGas_serial   = _String{"BlockMaxGas"}
)
var _ ipld.Node = &_HashedParams__Repr{}

func (_HashedParams__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_HashedParams__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "BlockMaxBytes":
		return n.BlockMaxBytes.Representation(), nil
	case "BlockMaxGas":
		return n.BlockMaxGas.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_HashedParams__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_HashedParams__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.LookupByIndex(0)
}
func (n _HashedParams__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_HashedParams__Repr) MapIterator() ipld.MapIterator {
	return &_HashedParams__ReprMapItr{n, 0}
}

type _HashedParams__ReprMapItr struct {
	n   *_HashedParams__Repr
	idx int
}

func (itr *_HashedParams__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__HashedParams_BlockMaxBytes_serial
		v = itr.n.BlockMaxBytes.Representation()
	case 1:
		k = &fieldName__HashedParams_BlockMaxGas_serial
		v = itr.n.BlockMaxGas.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_HashedParams__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_HashedParams__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_HashedParams__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_HashedParams__Repr) IsAbsent() bool {
	return false
}
func (_HashedParams__Repr) IsNull() bool {
	return false
}
func (_HashedParams__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsBool()
}
func (_HashedParams__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsInt()
}
func (_HashedParams__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsFloat()
}
func (_HashedParams__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsString()
}
func (_HashedParams__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsBytes()
}
func (_HashedParams__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.HashedParams.Repr"}.AsLink()
}
func (_HashedParams__Repr) Prototype() ipld.NodePrototype {
	return _HashedParams__ReprPrototype{}
}

type _HashedParams__ReprPrototype struct{}

func (_HashedParams__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _HashedParams__ReprBuilder
	nb.Reset()
	return &nb
}

type _HashedParams__ReprBuilder struct {
	_HashedParams__ReprAssembler
}

func (nb *_HashedParams__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_HashedParams__ReprBuilder) Reset() {
	var w _HashedParams
	var m schema.Maybe
	*nb = _HashedParams__ReprBuilder{_HashedParams__ReprAssembler{w: &w, m: &m}}
}

type _HashedParams__ReprAssembler struct {
	w     *_HashedParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm               schema.Maybe
	ca_BlockMaxBytes _Int__ReprAssembler
	ca_BlockMaxGas   _Int__ReprAssembler
}

func (na *_HashedParams__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_BlockMaxBytes.reset()
	na.ca_BlockMaxGas.reset()
}
func (na *_HashedParams__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_HashedParams{}
	}
	return na, nil
}
func (_HashedParams__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.BeginList(0)
}
func (na *_HashedParams__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.HashedParams.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_HashedParams__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignBool(false)
}
func (_HashedParams__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignInt(0)
}
func (_HashedParams__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignFloat(0)
}
func (_HashedParams__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignString("")
}
func (_HashedParams__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignBytes(nil)
}
func (_HashedParams__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.HashedParams.Repr"}.AssignLink(nil)
}
func (na *_HashedParams__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_HashedParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.HashedParams.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_HashedParams__ReprAssembler) Prototype() ipld.NodePrototype {
	return _HashedParams__ReprPrototype{}
}
func (ma *_HashedParams__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_HashedParams__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "BlockMaxBytes":
		if ma.s&fieldBit__HashedParams_BlockMaxBytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxBytes_serial}
		}
		ma.s += fieldBit__HashedParams_BlockMaxBytes
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_BlockMaxBytes.w = &ma.w.BlockMaxBytes
		ma.ca_BlockMaxBytes.m = &ma.cm
		return &ma.ca_BlockMaxBytes, nil
	case "BlockMaxGas":
		if ma.s&fieldBit__HashedParams_BlockMaxGas != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxGas_serial}
		}
		ma.s += fieldBit__HashedParams_BlockMaxGas
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_BlockMaxGas.w = &ma.w.BlockMaxGas
		ma.ca_BlockMaxGas.m = &ma.cm
		return &ma.ca_BlockMaxGas, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.HashedParams.Repr", Key: &_String{k}}
}
func (ma *_HashedParams__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_HashedParams__ReprKeyAssembler)(ma)
}
func (ma *_HashedParams__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_BlockMaxBytes.w = &ma.w.BlockMaxBytes
		ma.ca_BlockMaxBytes.m = &ma.cm
		return &ma.ca_BlockMaxBytes
	case 1:
		ma.ca_BlockMaxGas.w = &ma.w.BlockMaxGas
		ma.ca_BlockMaxGas.m = &ma.cm
		return &ma.ca_BlockMaxGas
	default:
		panic("unreachable")
	}
}
func (ma *_HashedParams__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__HashedParams_sufficient != fieldBits__HashedParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__HashedParams_BlockMaxBytes == 0 {
			err.Missing = append(err.Missing, "BlockMaxBytes")
		}
		if ma.s&fieldBit__HashedParams_BlockMaxGas == 0 {
			err.Missing = append(err.Missing, "BlockMaxGas")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_HashedParams__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_HashedParams__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _HashedParams__ReprKeyAssembler _HashedParams__ReprAssembler

func (_HashedParams__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.BeginMap(0)
}
func (_HashedParams__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_HashedParams__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignNull()
}
func (_HashedParams__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignBool(false)
}
func (_HashedParams__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignInt(0)
}
func (_HashedParams__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_HashedParams__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "BlockMaxBytes":
		if ka.s&fieldBit__HashedParams_BlockMaxBytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxBytes_serial}
		}
		ka.s += fieldBit__HashedParams_BlockMaxBytes
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "BlockMaxGas":
		if ka.s&fieldBit__HashedParams_BlockMaxGas != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__HashedParams_BlockMaxGas_serial}
		}
		ka.s += fieldBit__HashedParams_BlockMaxGas
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.HashedParams.Repr", Key: &_String{k}}
}
func (_HashedParams__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_HashedParams__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.HashedParams.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_HashedParams__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_HashedParams__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _Header) FieldVersion() Version {
	return &n.Version
}
func (n _Header) FieldChainID() String {
	return &n.ChainID
}
func (n _Header) FieldHeight() Int {
	return &n.Height
}
func (n _Header) FieldTime() Time {
	return &n.Time
}
func (n _Header) FieldLastBlockID() BlockID {
	return &n.LastBlockID
}
func (n _Header) FieldLastCommitHash() Link {
	return &n.LastCommitHash
}
func (n _Header) FieldDataHash() Link {
	return &n.DataHash
}
func (n _Header) FieldValidatorsHash() Link {
	return &n.ValidatorsHash
}
func (n _Header) FieldNextValidatorsHash() Link {
	return &n.NextValidatorsHash
}
func (n _Header) FieldConsensusHash() Link {
	return &n.ConsensusHash
}
func (n _Header) FieldAppHash() Link {
	return &n.AppHash
}
func (n _Header) FieldLastResultsHash() Link {
	return &n.LastResultsHash
}
func (n _Header) FieldEvidenceHash() Link {
	return &n.EvidenceHash
}
func (n _Header) FieldProposerAddress() Address {
	return &n.ProposerAddress
}

type _Header__Maybe struct {
	m schema.Maybe
	v Header
}
type MaybeHeader = *_Header__Maybe

func (m MaybeHeader) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHeader) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHeader) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHeader) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHeader) Must() Header {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Header_Version            = _String{"Version"}
	fieldName__Header_ChainID            = _String{"ChainID"}
	fieldName__Header_Height             = _String{"Height"}
	fieldName__Header_Time               = _String{"Time"}
	fieldName__Header_LastBlockID        = _String{"LastBlockID"}
	fieldName__Header_LastCommitHash     = _String{"LastCommitHash"}
	fieldName__Header_DataHash           = _String{"DataHash"}
	fieldName__Header_ValidatorsHash     = _String{"ValidatorsHash"}
	fieldName__Header_NextValidatorsHash = _String{"NextValidatorsHash"}
	fieldName__Header_ConsensusHash      = _String{"ConsensusHash"}
	fieldName__Header_AppHash            = _String{"AppHash"}
	fieldName__Header_LastResultsHash    = _String{"LastResultsHash"}
	fieldName__Header_EvidenceHash       = _String{"EvidenceHash"}
	fieldName__Header_ProposerAddress    = _String{"ProposerAddress"}
)
var _ ipld.Node = (Header)(&_Header{})
var _ schema.TypedNode = (Header)(&_Header{})

func (Header) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Header) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Version":
		return &n.Version, nil
	case "ChainID":
		return &n.ChainID, nil
	case "Height":
		return &n.Height, nil
	case "Time":
		return &n.Time, nil
	case "LastBlockID":
		return &n.LastBlockID, nil
	case "LastCommitHash":
		return &n.LastCommitHash, nil
	case "DataHash":
		return &n.DataHash, nil
	case "ValidatorsHash":
		return &n.ValidatorsHash, nil
	case "NextValidatorsHash":
		return &n.NextValidatorsHash, nil
	case "ConsensusHash":
		return &n.ConsensusHash, nil
	case "AppHash":
		return &n.AppHash, nil
	case "LastResultsHash":
		return &n.LastResultsHash, nil
	case "EvidenceHash":
		return &n.EvidenceHash, nil
	case "ProposerAddress":
		return &n.ProposerAddress, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Header) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Header) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Header"}.LookupByIndex(0)
}
func (n Header) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Header) MapIterator() ipld.MapIterator {
	return &_Header__MapItr{n, 0}
}

type _Header__MapItr struct {
	n   Header
	idx int
}

func (itr *_Header__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 14 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Header_Version
		v = &itr.n.Version
	case 1:
		k = &fieldName__Header_ChainID
		v = &itr.n.ChainID
	case 2:
		k = &fieldName__Header_Height
		v = &itr.n.Height
	case 3:
		k = &fieldName__Header_Time
		v = &itr.n.Time
	case 4:
		k = &fieldName__Header_LastBlockID
		v = &itr.n.LastBlockID
	case 5:
		k = &fieldName__Header_LastCommitHash
		v = &itr.n.LastCommitHash
	case 6:
		k = &fieldName__Header_DataHash
		v = &itr.n.DataHash
	case 7:
		k = &fieldName__Header_ValidatorsHash
		v = &itr.n.ValidatorsHash
	case 8:
		k = &fieldName__Header_NextValidatorsHash
		v = &itr.n.NextValidatorsHash
	case 9:
		k = &fieldName__Header_ConsensusHash
		v = &itr.n.ConsensusHash
	case 10:
		k = &fieldName__Header_AppHash
		v = &itr.n.AppHash
	case 11:
		k = &fieldName__Header_LastResultsHash
		v = &itr.n.LastResultsHash
	case 12:
		k = &fieldName__Header_EvidenceHash
		v = &itr.n.EvidenceHash
	case 13:
		k = &fieldName__Header_ProposerAddress
		v = &itr.n.ProposerAddress
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Header__MapItr) Done() bool {
	return itr.idx >= 14
}

func (Header) ListIterator() ipld.ListIterator {
	return nil
}
func (Header) Length() int64 {
	return 14
}
func (Header) IsAbsent() bool {
	return false
}
func (Header) IsNull() bool {
	return false
}
func (Header) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Header"}.AsBool()
}
func (Header) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Header"}.AsInt()
}
func (Header) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Header"}.AsFloat()
}
func (Header) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Header"}.AsString()
}
func (Header) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Header"}.AsBytes()
}
func (Header) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Header"}.AsLink()
}
func (Header) Prototype() ipld.NodePrototype {
	return _Header__Prototype{}
}

type _Header__Prototype struct{}

func (_Header__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Header__Builder
	nb.Reset()
	return &nb
}

type _Header__Builder struct {
	_Header__Assembler
}

func (nb *_Header__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Header__Builder) Reset() {
	var w _Header
	var m schema.Maybe
	*nb = _Header__Builder{_Header__Assembler{w: &w, m: &m}}
}

type _Header__Assembler struct {
	w     *_Header
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                    schema.Maybe
	ca_Version            _Version__Assembler
	ca_ChainID            _String__Assembler
	ca_Height             _Int__Assembler
	ca_Time               _Time__Assembler
	ca_LastBlockID        _BlockID__Assembler
	ca_LastCommitHash     _Link__Assembler
	ca_DataHash           _Link__Assembler
	ca_ValidatorsHash     _Link__Assembler
	ca_NextValidatorsHash _Link__Assembler
	ca_ConsensusHash      _Link__Assembler
	ca_AppHash            _Link__Assembler
	ca_LastResultsHash    _Link__Assembler
	ca_EvidenceHash       _Link__Assembler
	ca_ProposerAddress    _Address__Assembler
}

func (na *_Header__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Version.reset()
	na.ca_ChainID.reset()
	na.ca_Height.reset()
	na.ca_Time.reset()
	na.ca_LastBlockID.reset()
	na.ca_LastCommitHash.reset()
	na.ca_DataHash.reset()
	na.ca_ValidatorsHash.reset()
	na.ca_NextValidatorsHash.reset()
	na.ca_ConsensusHash.reset()
	na.ca_AppHash.reset()
	na.ca_LastResultsHash.reset()
	na.ca_EvidenceHash.reset()
	na.ca_ProposerAddress.reset()
}

var (
	fieldBit__Header_Version            = 1 << 0
	fieldBit__Header_ChainID            = 1 << 1
	fieldBit__Header_Height             = 1 << 2
	fieldBit__Header_Time               = 1 << 3
	fieldBit__Header_LastBlockID        = 1 << 4
	fieldBit__Header_LastCommitHash     = 1 << 5
	fieldBit__Header_DataHash           = 1 << 6
	fieldBit__Header_ValidatorsHash     = 1 << 7
	fieldBit__Header_NextValidatorsHash = 1 << 8
	fieldBit__Header_ConsensusHash      = 1 << 9
	fieldBit__Header_AppHash            = 1 << 10
	fieldBit__Header_LastResultsHash    = 1 << 11
	fieldBit__Header_EvidenceHash       = 1 << 12
	fieldBit__Header_ProposerAddress    = 1 << 13
	fieldBits__Header_sufficient        = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6 + 1<<7 + 1<<8 + 1<<9 + 1<<10 + 1<<11 + 1<<12 + 1<<13
)

func (na *_Header__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Header{}
	}
	return na, nil
}
func (_Header__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Header"}.BeginList(0)
}
func (na *_Header__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Header"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Header__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignBool(false)
}
func (_Header__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignInt(0)
}
func (_Header__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignFloat(0)
}
func (_Header__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignString("")
}
func (_Header__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignBytes(nil)
}
func (_Header__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Header"}.AssignLink(nil)
}
func (na *_Header__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Header); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Header", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Header__Assembler) Prototype() ipld.NodePrototype {
	return _Header__Prototype{}
}
func (ma *_Header__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Version.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ChainID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Height.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Time.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_LastBlockID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_LastCommitHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_DataHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorsHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_NextValidatorsHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ConsensusHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_AppHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_LastResultsHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_EvidenceHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ProposerAddress.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Header__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Version":
		if ma.s&fieldBit__Header_Version != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Version}
		}
		ma.s += fieldBit__Header_Version
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version, nil
	case "ChainID":
		if ma.s&fieldBit__Header_ChainID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ChainID}
		}
		ma.s += fieldBit__Header_ChainID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID, nil
	case "Height":
		if ma.s&fieldBit__Header_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Height}
		}
		ma.s += fieldBit__Header_Height
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Time":
		if ma.s&fieldBit__Header_Time != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time}
		}
		ma.s += fieldBit__Header_Time
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time, nil
	case "LastBlockID":
		if ma.s&fieldBit__Header_LastBlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastBlockID}
		}
		ma.s += fieldBit__Header_LastBlockID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_LastBlockID.w = &ma.w.LastBlockID
		ma.ca_LastBlockID.m = &ma.cm
		return &ma.ca_LastBlockID, nil
	case "LastCommitHash":
		if ma.s&fieldBit__Header_LastCommitHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastCommitHash}
		}
		ma.s += fieldBit__Header_LastCommitHash
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_LastCommitHash.w = &ma.w.LastCommitHash
		ma.ca_LastCommitHash.m = &ma.cm
		return &ma.ca_LastCommitHash, nil
	case "DataHash":
		if ma.s&fieldBit__Header_DataHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_DataHash}
		}
		ma.s += fieldBit__Header_DataHash
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_DataHash.w = &ma.w.DataHash
		ma.ca_DataHash.m = &ma.cm
		return &ma.ca_DataHash, nil
	case "ValidatorsHash":
		if ma.s&fieldBit__Header_ValidatorsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ValidatorsHash}
		}
		ma.s += fieldBit__Header_ValidatorsHash
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_ValidatorsHash.w = &ma.w.ValidatorsHash
		ma.ca_ValidatorsHash.m = &ma.cm
		return &ma.ca_ValidatorsHash, nil
	case "NextValidatorsHash":
		if ma.s&fieldBit__Header_NextValidatorsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_NextValidatorsHash}
		}
		ma.s += fieldBit__Header_NextValidatorsHash
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_NextValidatorsHash.w = &ma.w.NextValidatorsHash
		ma.ca_NextValidatorsHash.m = &ma.cm
		return &ma.ca_NextValidatorsHash, nil
	case "ConsensusHash":
		if ma.s&fieldBit__Header_ConsensusHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ConsensusHash}
		}
		ma.s += fieldBit__Header_ConsensusHash
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_ConsensusHash.w = &ma.w.ConsensusHash
		ma.ca_ConsensusHash.m = &ma.cm
		return &ma.ca_ConsensusHash, nil
	case "AppHash":
		if ma.s&fieldBit__Header_AppHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_AppHash}
		}
		ma.s += fieldBit__Header_AppHash
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_AppHash.w = &ma.w.AppHash
		ma.ca_AppHash.m = &ma.cm
		return &ma.ca_AppHash, nil
	case "LastResultsHash":
		if ma.s&fieldBit__Header_LastResultsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastResultsHash}
		}
		ma.s += fieldBit__Header_LastResultsHash
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_LastResultsHash.w = &ma.w.LastResultsHash
		ma.ca_LastResultsHash.m = &ma.cm
		return &ma.ca_LastResultsHash, nil
	case "EvidenceHash":
		if ma.s&fieldBit__Header_EvidenceHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_EvidenceHash}
		}
		ma.s += fieldBit__Header_EvidenceHash
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_EvidenceHash.w = &ma.w.EvidenceHash
		ma.ca_EvidenceHash.m = &ma.cm
		return &ma.ca_EvidenceHash, nil
	case "ProposerAddress":
		if ma.s&fieldBit__Header_ProposerAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ProposerAddress}
		}
		ma.s += fieldBit__Header_ProposerAddress
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_ProposerAddress.w = &ma.w.ProposerAddress
		ma.ca_ProposerAddress.m = &ma.cm
		return &ma.ca_ProposerAddress, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Header", Key: &_String{k}}
}
func (ma *_Header__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Header__KeyAssembler)(ma)
}
func (ma *_Header__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version
	case 1:
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID
	case 2:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 3:
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time
	case 4:
		ma.ca_LastBlockID.w = &ma.w.LastBlockID
		ma.ca_LastBlockID.m = &ma.cm
		return &ma.ca_LastBlockID
	case 5:
		ma.ca_LastCommitHash.w = &ma.w.LastCommitHash
		ma.ca_LastCommitHash.m = &ma.cm
		return &ma.ca_LastCommitHash
	case 6:
		ma.ca_DataHash.w = &ma.w.DataHash
		ma.ca_DataHash.m = &ma.cm
		return &ma.ca_DataHash
	case 7:
		ma.ca_ValidatorsHash.w = &ma.w.ValidatorsHash
		ma.ca_ValidatorsHash.m = &ma.cm
		return &ma.ca_ValidatorsHash
	case 8:
		ma.ca_NextValidatorsHash.w = &ma.w.NextValidatorsHash
		ma.ca_NextValidatorsHash.m = &ma.cm
		return &ma.ca_NextValidatorsHash
	case 9:
		ma.ca_ConsensusHash.w = &ma.w.ConsensusHash
		ma.ca_ConsensusHash.m = &ma.cm
		return &ma.ca_ConsensusHash
	case 10:
		ma.ca_AppHash.w = &ma.w.AppHash
		ma.ca_AppHash.m = &ma.cm
		return &ma.ca_AppHash
	case 11:
		ma.ca_LastResultsHash.w = &ma.w.LastResultsHash
		ma.ca_LastResultsHash.m = &ma.cm
		return &ma.ca_LastResultsHash
	case 12:
		ma.ca_EvidenceHash.w = &ma.w.EvidenceHash
		ma.ca_EvidenceHash.m = &ma.cm
		return &ma.ca_EvidenceHash
	case 13:
		ma.ca_ProposerAddress.w = &ma.w.ProposerAddress
		ma.ca_ProposerAddress.m = &ma.cm
		return &ma.ca_ProposerAddress
	default:
		panic("unreachable")
	}
}
func (ma *_Header__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Header_sufficient != fieldBits__Header_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Header_Version == 0 {
			err.Missing = append(err.Missing, "Version")
		}
		if ma.s&fieldBit__Header_ChainID == 0 {
			err.Missing = append(err.Missing, "ChainID")
		}
		if ma.s&fieldBit__Header_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Header_Time == 0 {
			err.Missing = append(err.Missing, "Time")
		}
		if ma.s&fieldBit__Header_LastBlockID == 0 {
			err.Missing = append(err.Missing, "LastBlockID")
		}
		if ma.s&fieldBit__Header_LastCommitHash == 0 {
			err.Missing = append(err.Missing, "LastCommitHash")
		}
		if ma.s&fieldBit__Header_DataHash == 0 {
			err.Missing = append(err.Missing, "DataHash")
		}
		if ma.s&fieldBit__Header_ValidatorsHash == 0 {
			err.Missing = append(err.Missing, "ValidatorsHash")
		}
		if ma.s&fieldBit__Header_NextValidatorsHash == 0 {
			err.Missing = append(err.Missing, "NextValidatorsHash")
		}
		if ma.s&fieldBit__Header_ConsensusHash == 0 {
			err.Missing = append(err.Missing, "ConsensusHash")
		}
		if ma.s&fieldBit__Header_AppHash == 0 {
			err.Missing = append(err.Missing, "AppHash")
		}
		if ma.s&fieldBit__Header_LastResultsHash == 0 {
			err.Missing = append(err.Missing, "LastResultsHash")
		}
		if ma.s&fieldBit__Header_EvidenceHash == 0 {
			err.Missing = append(err.Missing, "EvidenceHash")
		}
		if ma.s&fieldBit__Header_ProposerAddress == 0 {
			err.Missing = append(err.Missing, "ProposerAddress")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Header__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Header__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Header__KeyAssembler _Header__Assembler

func (_Header__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.BeginMap(0)
}
func (_Header__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.BeginList(0)
}
func (na *_Header__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignNull()
}
func (_Header__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignBool(false)
}
func (_Header__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignInt(0)
}
func (_Header__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Header__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Version":
		if ka.s&fieldBit__Header_Version != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Version}
		}
		ka.s += fieldBit__Header_Version
		ka.state = maState_expectValue
		ka.f = 0
	case "ChainID":
		if ka.s&fieldBit__Header_ChainID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ChainID}
		}
		ka.s += fieldBit__Header_ChainID
		ka.state = maState_expectValue
		ka.f = 1
	case "Height":
		if ka.s&fieldBit__Header_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Height}
		}
		ka.s += fieldBit__Header_Height
		ka.state = maState_expectValue
		ka.f = 2
	case "Time":
		if ka.s&fieldBit__Header_Time != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time}
		}
		ka.s += fieldBit__Header_Time
		ka.state = maState_expectValue
		ka.f = 3
	case "LastBlockID":
		if ka.s&fieldBit__Header_LastBlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastBlockID}
		}
		ka.s += fieldBit__Header_LastBlockID
		ka.state = maState_expectValue
		ka.f = 4
	case "LastCommitHash":
		if ka.s&fieldBit__Header_LastCommitHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastCommitHash}
		}
		ka.s += fieldBit__Header_LastCommitHash
		ka.state = maState_expectValue
		ka.f = 5
	case "DataHash":
		if ka.s&fieldBit__Header_DataHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_DataHash}
		}
		ka.s += fieldBit__Header_DataHash
		ka.state = maState_expectValue
		ka.f = 6
	case "ValidatorsHash":
		if ka.s&fieldBit__Header_ValidatorsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ValidatorsHash}
		}
		ka.s += fieldBit__Header_ValidatorsHash
		ka.state = maState_expectValue
		ka.f = 7
	case "NextValidatorsHash":
		if ka.s&fieldBit__Header_NextValidatorsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_NextValidatorsHash}
		}
		ka.s += fieldBit__Header_NextValidatorsHash
		ka.state = maState_expectValue
		ka.f = 8
	case "ConsensusHash":
		if ka.s&fieldBit__Header_ConsensusHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ConsensusHash}
		}
		ka.s += fieldBit__Header_ConsensusHash
		ka.state = maState_expectValue
		ka.f = 9
	case "AppHash":
		if ka.s&fieldBit__Header_AppHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_AppHash}
		}
		ka.s += fieldBit__Header_AppHash
		ka.state = maState_expectValue
		ka.f = 10
	case "LastResultsHash":
		if ka.s&fieldBit__Header_LastResultsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastResultsHash}
		}
		ka.s += fieldBit__Header_LastResultsHash
		ka.state = maState_expectValue
		ka.f = 11
	case "EvidenceHash":
		if ka.s&fieldBit__Header_EvidenceHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_EvidenceHash}
		}
		ka.s += fieldBit__Header_EvidenceHash
		ka.state = maState_expectValue
		ka.f = 12
	case "ProposerAddress":
		if ka.s&fieldBit__Header_ProposerAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ProposerAddress}
		}
		ka.s += fieldBit__Header_ProposerAddress
		ka.state = maState_expectValue
		ka.f = 13
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Header", Key: &_String{k}}
	}
	return nil
}
func (_Header__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignBytes(nil)
}
func (_Header__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Header.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Header__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Header__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Header) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Header) Representation() ipld.Node {
	return (*_Header__Repr)(n)
}

type _Header__Repr _Header

var (
	fieldName__Header_Version_serial            = _String{"Version"}
	fieldName__Header_ChainID_serial            = _String{"ChainID"}
	fieldName__Header_Height_serial             = _String{"Height"}
	fieldName__Header_Time_serial               = _String{"Time"}
	fieldName__Header_LastBlockID_serial        = _String{"LastBlockID"}
	fieldName__Header_LastCommitHash_serial     = _String{"LastCommitHash"}
	fieldName__Header_DataHash_serial           = _String{"DataHash"}
	fieldName__Header_ValidatorsHash_serial     = _String{"ValidatorsHash"}
	fieldName__Header_NextValidatorsHash_serial = _String{"NextValidatorsHash"}
	fieldName__Header_ConsensusHash_serial      = _String{"ConsensusHash"}
	fieldName__Header_AppHash_serial            = _String{"AppHash"}
	fieldName__Header_LastResultsHash_serial    = _String{"LastResultsHash"}
	fieldName__Header_EvidenceHash_serial       = _String{"EvidenceHash"}
	fieldName__Header_ProposerAddress_serial    = _String{"ProposerAddress"}
)
var _ ipld.Node = &_Header__Repr{}

func (_Header__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Header__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Version":
		return n.Version.Representation(), nil
	case "ChainID":
		return n.ChainID.Representation(), nil
	case "Height":
		return n.Height.Representation(), nil
	case "Time":
		return n.Time.Representation(), nil
	case "LastBlockID":
		return n.LastBlockID.Representation(), nil
	case "LastCommitHash":
		return n.LastCommitHash.Representation(), nil
	case "DataHash":
		return n.DataHash.Representation(), nil
	case "ValidatorsHash":
		return n.ValidatorsHash.Representation(), nil
	case "NextValidatorsHash":
		return n.NextValidatorsHash.Representation(), nil
	case "ConsensusHash":
		return n.ConsensusHash.Representation(), nil
	case "AppHash":
		return n.AppHash.Representation(), nil
	case "LastResultsHash":
		return n.LastResultsHash.Representation(), nil
	case "EvidenceHash":
		return n.EvidenceHash.Representation(), nil
	case "ProposerAddress":
		return n.ProposerAddress.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Header__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Header__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.LookupByIndex(0)
}
func (n _Header__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Header__Repr) MapIterator() ipld.MapIterator {
	return &_Header__ReprMapItr{n, 0}
}

type _Header__ReprMapItr struct {
	n   *_Header__Repr
	idx int
}

func (itr *_Header__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 14 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Header_Version_serial
		v = itr.n.Version.Representation()
	case 1:
		k = &fieldName__Header_ChainID_serial
		v = itr.n.ChainID.Representation()
	case 2:
		k = &fieldName__Header_Height_serial
		v = itr.n.Height.Representation()
	case 3:
		k = &fieldName__Header_Time_serial
		v = itr.n.Time.Representation()
	case 4:
		k = &fieldName__Header_LastBlockID_serial
		v = itr.n.LastBlockID.Representation()
	case 5:
		k = &fieldName__Header_LastCommitHash_serial
		v = itr.n.LastCommitHash.Representation()
	case 6:
		k = &fieldName__Header_DataHash_serial
		v = itr.n.DataHash.Representation()
	case 7:
		k = &fieldName__Header_ValidatorsHash_serial
		v = itr.n.ValidatorsHash.Representation()
	case 8:
		k = &fieldName__Header_NextValidatorsHash_serial
		v = itr.n.NextValidatorsHash.Representation()
	case 9:
		k = &fieldName__Header_ConsensusHash_serial
		v = itr.n.ConsensusHash.Representation()
	case 10:
		k = &fieldName__Header_AppHash_serial
		v = itr.n.AppHash.Representation()
	case 11:
		k = &fieldName__Header_LastResultsHash_serial
		v = itr.n.LastResultsHash.Representation()
	case 12:
		k = &fieldName__Header_EvidenceHash_serial
		v = itr.n.EvidenceHash.Representation()
	case 13:
		k = &fieldName__Header_ProposerAddress_serial
		v = itr.n.ProposerAddress.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Header__ReprMapItr) Done() bool {
	return itr.idx >= 14
}
func (_Header__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Header__Repr) Length() int64 {
	l := 14
	return int64(l)
}
func (_Header__Repr) IsAbsent() bool {
	return false
}
func (_Header__Repr) IsNull() bool {
	return false
}
func (_Header__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsBool()
}
func (_Header__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsInt()
}
func (_Header__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsFloat()
}
func (_Header__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsString()
}
func (_Header__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsBytes()
}
func (_Header__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Header.Repr"}.AsLink()
}
func (_Header__Repr) Prototype() ipld.NodePrototype {
	return _Header__ReprPrototype{}
}

type _Header__ReprPrototype struct{}

func (_Header__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Header__ReprBuilder
	nb.Reset()
	return &nb
}

type _Header__ReprBuilder struct {
	_Header__ReprAssembler
}

func (nb *_Header__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Header__ReprBuilder) Reset() {
	var w _Header
	var m schema.Maybe
	*nb = _Header__ReprBuilder{_Header__ReprAssembler{w: &w, m: &m}}
}

type _Header__ReprAssembler struct {
	w     *_Header
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                    schema.Maybe
	ca_Version            _Version__ReprAssembler
	ca_ChainID            _String__ReprAssembler
	ca_Height             _Int__ReprAssembler
	ca_Time               _Time__ReprAssembler
	ca_LastBlockID        _BlockID__ReprAssembler
	ca_LastCommitHash     _Link__ReprAssembler
	ca_DataHash           _Link__ReprAssembler
	ca_ValidatorsHash     _Link__ReprAssembler
	ca_NextValidatorsHash _Link__ReprAssembler
	ca_ConsensusHash      _Link__ReprAssembler
	ca_AppHash            _Link__ReprAssembler
	ca_LastResultsHash    _Link__ReprAssembler
	ca_EvidenceHash       _Link__ReprAssembler
	ca_ProposerAddress    _Address__ReprAssembler
}

func (na *_Header__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Version.reset()
	na.ca_ChainID.reset()
	na.ca_Height.reset()
	na.ca_Time.reset()
	na.ca_LastBlockID.reset()
	na.ca_LastCommitHash.reset()
	na.ca_DataHash.reset()
	na.ca_ValidatorsHash.reset()
	na.ca_NextValidatorsHash.reset()
	na.ca_ConsensusHash.reset()
	na.ca_AppHash.reset()
	na.ca_LastResultsHash.reset()
	na.ca_EvidenceHash.reset()
	na.ca_ProposerAddress.reset()
}
func (na *_Header__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Header{}
	}
	return na, nil
}
func (_Header__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.BeginList(0)
}
func (na *_Header__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Header.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Header__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignBool(false)
}
func (_Header__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignInt(0)
}
func (_Header__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignFloat(0)
}
func (_Header__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignString("")
}
func (_Header__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignBytes(nil)
}
func (_Header__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Header.Repr"}.AssignLink(nil)
}
func (na *_Header__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Header); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Header.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Header__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Header__ReprPrototype{}
}
func (ma *_Header__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Header__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Version":
		if ma.s&fieldBit__Header_Version != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Version_serial}
		}
		ma.s += fieldBit__Header_Version
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version, nil
	case "ChainID":
		if ma.s&fieldBit__Header_ChainID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ChainID_serial}
		}
		ma.s += fieldBit__Header_ChainID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID, nil
	case "Height":
		if ma.s&fieldBit__Header_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Height_serial}
		}
		ma.s += fieldBit__Header_Height
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Time":
		if ma.s&fieldBit__Header_Time != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time_serial}
		}
		ma.s += fieldBit__Header_Time
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time, nil
	case "LastBlockID":
		if ma.s&fieldBit__Header_LastBlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastBlockID_serial}
		}
		ma.s += fieldBit__Header_LastBlockID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_LastBlockID.w = &ma.w.LastBlockID
		ma.ca_LastBlockID.m = &ma.cm
		return &ma.ca_LastBlockID, nil
	case "LastCommitHash":
		if ma.s&fieldBit__Header_LastCommitHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastCommitHash_serial}
		}
		ma.s += fieldBit__Header_LastCommitHash
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_LastCommitHash.w = &ma.w.LastCommitHash
		ma.ca_LastCommitHash.m = &ma.cm
		return &ma.ca_LastCommitHash, nil
	case "DataHash":
		if ma.s&fieldBit__Header_DataHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_DataHash_serial}
		}
		ma.s += fieldBit__Header_DataHash
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_DataHash.w = &ma.w.DataHash
		ma.ca_DataHash.m = &ma.cm
		return &ma.ca_DataHash, nil
	case "ValidatorsHash":
		if ma.s&fieldBit__Header_ValidatorsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ValidatorsHash_serial}
		}
		ma.s += fieldBit__Header_ValidatorsHash
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_ValidatorsHash.w = &ma.w.ValidatorsHash
		ma.ca_ValidatorsHash.m = &ma.cm
		return &ma.ca_ValidatorsHash, nil
	case "NextValidatorsHash":
		if ma.s&fieldBit__Header_NextValidatorsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_NextValidatorsHash_serial}
		}
		ma.s += fieldBit__Header_NextValidatorsHash
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_NextValidatorsHash.w = &ma.w.NextValidatorsHash
		ma.ca_NextValidatorsHash.m = &ma.cm
		return &ma.ca_NextValidatorsHash, nil
	case "ConsensusHash":
		if ma.s&fieldBit__Header_ConsensusHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ConsensusHash_serial}
		}
		ma.s += fieldBit__Header_ConsensusHash
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_ConsensusHash.w = &ma.w.ConsensusHash
		ma.ca_ConsensusHash.m = &ma.cm
		return &ma.ca_ConsensusHash, nil
	case "AppHash":
		if ma.s&fieldBit__Header_AppHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_AppHash_serial}
		}
		ma.s += fieldBit__Header_AppHash
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_AppHash.w = &ma.w.AppHash
		ma.ca_AppHash.m = &ma.cm
		return &ma.ca_AppHash, nil
	case "LastResultsHash":
		if ma.s&fieldBit__Header_LastResultsHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastResultsHash_serial}
		}
		ma.s += fieldBit__Header_LastResultsHash
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_LastResultsHash.w = &ma.w.LastResultsHash
		ma.ca_LastResultsHash.m = &ma.cm
		return &ma.ca_LastResultsHash, nil
	case "EvidenceHash":
		if ma.s&fieldBit__Header_EvidenceHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_EvidenceHash_serial}
		}
		ma.s += fieldBit__Header_EvidenceHash
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_EvidenceHash.w = &ma.w.EvidenceHash
		ma.ca_EvidenceHash.m = &ma.cm
		return &ma.ca_EvidenceHash, nil
	case "ProposerAddress":
		if ma.s&fieldBit__Header_ProposerAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ProposerAddress_serial}
		}
		ma.s += fieldBit__Header_ProposerAddress
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_ProposerAddress.w = &ma.w.ProposerAddress
		ma.ca_ProposerAddress.m = &ma.cm
		return &ma.ca_ProposerAddress, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Header.Repr", Key: &_String{k}}
}
func (ma *_Header__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Header__ReprKeyAssembler)(ma)
}
func (ma *_Header__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Version.w = &ma.w.Version
		ma.ca_Version.m = &ma.cm
		return &ma.ca_Version
	case 1:
		ma.ca_ChainID.w = &ma.w.ChainID
		ma.ca_ChainID.m = &ma.cm
		return &ma.ca_ChainID
	case 2:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 3:
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time
	case 4:
		ma.ca_LastBlockID.w = &ma.w.LastBlockID
		ma.ca_LastBlockID.m = &ma.cm
		return &ma.ca_LastBlockID
	case 5:
		ma.ca_LastCommitHash.w = &ma.w.LastCommitHash
		ma.ca_LastCommitHash.m = &ma.cm
		return &ma.ca_LastCommitHash
	case 6:
		ma.ca_DataHash.w = &ma.w.DataHash
		ma.ca_DataHash.m = &ma.cm
		return &ma.ca_DataHash
	case 7:
		ma.ca_ValidatorsHash.w = &ma.w.ValidatorsHash
		ma.ca_ValidatorsHash.m = &ma.cm
		return &ma.ca_ValidatorsHash
	case 8:
		ma.ca_NextValidatorsHash.w = &ma.w.NextValidatorsHash
		ma.ca_NextValidatorsHash.m = &ma.cm
		return &ma.ca_NextValidatorsHash
	case 9:
		ma.ca_ConsensusHash.w = &ma.w.ConsensusHash
		ma.ca_ConsensusHash.m = &ma.cm
		return &ma.ca_ConsensusHash
	case 10:
		ma.ca_AppHash.w = &ma.w.AppHash
		ma.ca_AppHash.m = &ma.cm
		return &ma.ca_AppHash
	case 11:
		ma.ca_LastResultsHash.w = &ma.w.LastResultsHash
		ma.ca_LastResultsHash.m = &ma.cm
		return &ma.ca_LastResultsHash
	case 12:
		ma.ca_EvidenceHash.w = &ma.w.EvidenceHash
		ma.ca_EvidenceHash.m = &ma.cm
		return &ma.ca_EvidenceHash
	case 13:
		ma.ca_ProposerAddress.w = &ma.w.ProposerAddress
		ma.ca_ProposerAddress.m = &ma.cm
		return &ma.ca_ProposerAddress
	default:
		panic("unreachable")
	}
}
func (ma *_Header__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Header_sufficient != fieldBits__Header_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Header_Version == 0 {
			err.Missing = append(err.Missing, "Version")
		}
		if ma.s&fieldBit__Header_ChainID == 0 {
			err.Missing = append(err.Missing, "ChainID")
		}
		if ma.s&fieldBit__Header_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Header_Time == 0 {
			err.Missing = append(err.Missing, "Time")
		}
		if ma.s&fieldBit__Header_LastBlockID == 0 {
			err.Missing = append(err.Missing, "LastBlockID")
		}
		if ma.s&fieldBit__Header_LastCommitHash == 0 {
			err.Missing = append(err.Missing, "LastCommitHash")
		}
		if ma.s&fieldBit__Header_DataHash == 0 {
			err.Missing = append(err.Missing, "DataHash")
		}
		if ma.s&fieldBit__Header_ValidatorsHash == 0 {
			err.Missing = append(err.Missing, "ValidatorsHash")
		}
		if ma.s&fieldBit__Header_NextValidatorsHash == 0 {
			err.Missing = append(err.Missing, "NextValidatorsHash")
		}
		if ma.s&fieldBit__Header_ConsensusHash == 0 {
			err.Missing = append(err.Missing, "ConsensusHash")
		}
		if ma.s&fieldBit__Header_AppHash == 0 {
			err.Missing = append(err.Missing, "AppHash")
		}
		if ma.s&fieldBit__Header_LastResultsHash == 0 {
			err.Missing = append(err.Missing, "LastResultsHash")
		}
		if ma.s&fieldBit__Header_EvidenceHash == 0 {
			err.Missing = append(err.Missing, "EvidenceHash")
		}
		if ma.s&fieldBit__Header_ProposerAddress == 0 {
			err.Missing = append(err.Missing, "ProposerAddress")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Header__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Header__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Header__ReprKeyAssembler _Header__ReprAssembler

func (_Header__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Header__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Header__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignNull()
}
func (_Header__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Header__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Header__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Header__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Version":
		if ka.s&fieldBit__Header_Version != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Version_serial}
		}
		ka.s += fieldBit__Header_Version
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "ChainID":
		if ka.s&fieldBit__Header_ChainID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ChainID_serial}
		}
		ka.s += fieldBit__Header_ChainID
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Height":
		if ka.s&fieldBit__Header_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Height_serial}
		}
		ka.s += fieldBit__Header_Height
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Time":
		if ka.s&fieldBit__Header_Time != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time_serial}
		}
		ka.s += fieldBit__Header_Time
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "LastBlockID":
		if ka.s&fieldBit__Header_LastBlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastBlockID_serial}
		}
		ka.s += fieldBit__Header_LastBlockID
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "LastCommitHash":
		if ka.s&fieldBit__Header_LastCommitHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastCommitHash_serial}
		}
		ka.s += fieldBit__Header_LastCommitHash
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "DataHash":
		if ka.s&fieldBit__Header_DataHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_DataHash_serial}
		}
		ka.s += fieldBit__Header_DataHash
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	case "ValidatorsHash":
		if ka.s&fieldBit__Header_ValidatorsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ValidatorsHash_serial}
		}
		ka.s += fieldBit__Header_ValidatorsHash
		ka.state = maState_expectValue
		ka.f = 7
		return nil
	case "NextValidatorsHash":
		if ka.s&fieldBit__Header_NextValidatorsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_NextValidatorsHash_serial}
		}
		ka.s += fieldBit__Header_NextValidatorsHash
		ka.state = maState_expectValue
		ka.f = 8
		return nil
	case "ConsensusHash":
		if ka.s&fieldBit__Header_ConsensusHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ConsensusHash_serial}
		}
		ka.s += fieldBit__Header_ConsensusHash
		ka.state = maState_expectValue
		ka.f = 9
		return nil
	case "AppHash":
		if ka.s&fieldBit__Header_AppHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_AppHash_serial}
		}
		ka.s += fieldBit__Header_AppHash
		ka.state = maState_expectValue
		ka.f = 10
		return nil
	case "LastResultsHash":
		if ka.s&fieldBit__Header_LastResultsHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_LastResultsHash_serial}
		}
		ka.s += fieldBit__Header_LastResultsHash
		ka.state = maState_expectValue
		ka.f = 11
		return nil
	case "EvidenceHash":
		if ka.s&fieldBit__Header_EvidenceHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_EvidenceHash_serial}
		}
		ka.s += fieldBit__Header_EvidenceHash
		ka.state = maState_expectValue
		ka.f = 12
		return nil
	case "ProposerAddress":
		if ka.s&fieldBit__Header_ProposerAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ProposerAddress_serial}
		}
		ka.s += fieldBit__Header_ProposerAddress
		ka.state = maState_expectValue
		ka.f = 13
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Header.Repr", Key: &_String{k}}
}
func (_Header__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Header__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Header.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Header__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Header__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n HexBytes) Bytes() []byte {
	return n.x
}
func (_HexBytes__Prototype) FromBytes(v []byte) (HexBytes, error) {
	n := _HexBytes{v}
	return &n, nil
}

type _HexBytes__Maybe struct {
	m schema.Maybe
	v HexBytes
}
type MaybeHexBytes = *_HexBytes__Maybe

func (m MaybeHexBytes) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHexBytes) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHexBytes) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHexBytes) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHexBytes) Must() HexBytes {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (HexBytes)(&_HexBytes{})
var _ schema.TypedNode = (HexBytes)(&_HexBytes{})

func (HexBytes) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (HexBytes) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.LookupByString("")
}
func (HexBytes) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.LookupByNode(nil)
}
func (HexBytes) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.LookupByIndex(0)
}
func (HexBytes) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.LookupBySegment(seg)
}
func (HexBytes) MapIterator() ipld.MapIterator {
	return nil
}
func (HexBytes) ListIterator() ipld.ListIterator {
	return nil
}
func (HexBytes) Length() int64 {
	return -1
}
func (HexBytes) IsAbsent() bool {
	return false
}
func (HexBytes) IsNull() bool {
	return false
}
func (HexBytes) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.AsBool()
}
func (HexBytes) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.AsInt()
}
func (HexBytes) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.AsFloat()
}
func (HexBytes) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.AsString()
}
func (n HexBytes) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (HexBytes) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.HexBytes"}.AsLink()
}
func (HexBytes) Prototype() ipld.NodePrototype {
	return _HexBytes__Prototype{}
}

type _HexBytes__Prototype struct{}

func (_HexBytes__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _HexBytes__Builder
	nb.Reset()
	return &nb
}

type _HexBytes__Builder struct {
	_HexBytes__Assembler
}

func (nb *_HexBytes__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_HexBytes__Builder) Reset() {
	var w _HexBytes
	var m schema.Maybe
	*nb = _HexBytes__Builder{_HexBytes__Assembler{w: &w, m: &m}}
}

type _HexBytes__Assembler struct {
	w *_HexBytes
	m *schema.Maybe
}

func (na *_HexBytes__Assembler) reset() {}
func (_HexBytes__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.BeginMap(0)
}
func (_HexBytes__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.BeginList(0)
}
func (na *_HexBytes__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_HexBytes__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignBool(false)
}
func (_HexBytes__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignInt(0)
}
func (_HexBytes__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignFloat(0)
}
func (_HexBytes__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignString("")
}
func (na *_HexBytes__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_HexBytes{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_HexBytes__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.HexBytes"}.AssignLink(nil)
}
func (na *_HexBytes__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_HexBytes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_HexBytes__Assembler) Prototype() ipld.NodePrototype {
	return _HexBytes__Prototype{}
}
func (HexBytes) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n HexBytes) Representation() ipld.Node {
	return (*_HexBytes__Repr)(n)
}

type _HexBytes__Repr = _HexBytes

var _ ipld.Node = &_HexBytes__Repr{}

type _HexBytes__ReprPrototype = _HexBytes__Prototype
type _HexBytes__ReprAssembler = _HexBytes__Assembler

func (n Int) Int() int64 {
	return n.x
}
func (_Int__Prototype) FromInt(v int64) (Int, error) {
	n := _Int{v}
	return &n, nil
}

type _Int__Maybe struct {
	m schema.Maybe
	v Int
}
type MaybeInt = *_Int__Maybe

func (m MaybeInt) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeInt) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeInt) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeInt) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeInt) Must() Int {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Int)(&_Int{})
var _ schema.TypedNode = (Int)(&_Int{})

func (Int) Kind() ipld.Kind {
	return ipld.Kind_Int
}
func (Int) LookupByString(string) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.Int"}.LookupByString("")
}
func (Int) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.Int"}.LookupByNode(nil)
}
func (Int) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.Int"}.LookupByIndex(0)
}
func (Int) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.Int"}.LookupBySegment(seg)
}
func (Int) MapIterator() ipld.MapIterator {
	return nil
}
func (Int) ListIterator() ipld.ListIterator {
	return nil
}
func (Int) Length() int64 {
	return -1
}
func (Int) IsAbsent() bool {
	return false
}
func (Int) IsNull() bool {
	return false
}
func (Int) AsBool() (bool, error) {
	return mixins.Int{"dagcosmos.Int"}.AsBool()
}
func (n Int) AsInt() (int64, error) {
	return n.x, nil
}
func (Int) AsFloat() (float64, error) {
	return mixins.Int{"dagcosmos.Int"}.AsFloat()
}
func (Int) AsString() (string, error) {
	return mixins.Int{"dagcosmos.Int"}.AsString()
}
func (Int) AsBytes() ([]byte, error) {
	return mixins.Int{"dagcosmos.Int"}.AsBytes()
}
func (Int) AsLink() (ipld.Link, error) {
	return mixins.Int{"dagcosmos.Int"}.AsLink()
}
func (Int) Prototype() ipld.NodePrototype {
	return _Int__Prototype{}
}

type _Int__Prototype struct{}

func (_Int__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Int__Builder
	nb.Reset()
	return &nb
}

type _Int__Builder struct {
	_Int__Assembler
}

func (nb *_Int__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Int__Builder) Reset() {
	var w _Int
	var m schema.Maybe
	*nb = _Int__Builder{_Int__Assembler{w: &w, m: &m}}
}

type _Int__Assembler struct {
	w *_Int
	m *schema.Maybe
}

func (na *_Int__Assembler) reset() {}
func (_Int__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.Int"}.BeginMap(0)
}
func (_Int__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.Int"}.BeginList(0)
}
func (na *_Int__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.IntAssembler{"dagcosmos.Int"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Int__Assembler) AssignBool(bool) error {
	return mixins.IntAssembler{"dagcosmos.Int"}.AssignBool(false)
}
func (na *_Int__Assembler) AssignInt(v int64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Int{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Int__Assembler) AssignFloat(float64) error {
	return mixins.IntAssembler{"dagcosmos.Int"}.AssignFloat(0)
}
func (_Int__Assembler) AssignString(string) error {
	return mixins.IntAssembler{"dagcosmos.Int"}.AssignString("")
}
func (_Int__Assembler) AssignBytes([]byte) error {
	return mixins.IntAssembler{"dagcosmos.Int"}.AssignBytes(nil)
}
func (_Int__Assembler) AssignLink(ipld.Link) error {
	return mixins.IntAssembler{"dagcosmos.Int"}.AssignLink(nil)
}
func (na *_Int__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Int); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsInt(); err != nil {
		return err
	} else {
		return na.AssignInt(v2)
	}
}
func (_Int__Assembler) Prototype() ipld.NodePrototype {
	return _Int__Prototype{}
}
func (Int) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Int) Representation() ipld.Node {
	return (*_Int__Repr)(n)
}

type _Int__Repr = _Int

var _ ipld.Node = &_Int__Repr{}

type _Int__ReprPrototype = _Int__Prototype
type _Int__ReprAssembler = _Int__Assembler

func (n _LightBlock) FieldSignedHeader() SignedHeader {
	return &n.SignedHeader
}
func (n _LightBlock) FieldValidatorSet() ValidatorSet {
	return &n.ValidatorSet
}

type _LightBlock__Maybe struct {
	m schema.Maybe
	v LightBlock
}
type MaybeLightBlock = *_LightBlock__Maybe

func (m MaybeLightBlock) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLightBlock) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLightBlock) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLightBlock) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLightBlock) Must() LightBlock {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__LightBlock_SignedHeader = _String{"SignedHeader"}
	fieldName__LightBlock_ValidatorSet = _String{"ValidatorSet"}
)
var _ ipld.Node = (LightBlock)(&_LightBlock{})
var _ schema.TypedNode = (LightBlock)(&_LightBlock{})

func (LightBlock) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n LightBlock) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "SignedHeader":
		return &n.SignedHeader, nil
	case "ValidatorSet":
		return &n.ValidatorSet, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n LightBlock) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (LightBlock) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.LookupByIndex(0)
}
func (n LightBlock) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n LightBlock) MapIterator() ipld.MapIterator {
	return &_LightBlock__MapItr{n, 0}
}

type _LightBlock__MapItr struct {
	n   LightBlock
	idx int
}

func (itr *_LightBlock__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__LightBlock_SignedHeader
		v = &itr.n.SignedHeader
	case 1:
		k = &fieldName__LightBlock_ValidatorSet
		v = &itr.n.ValidatorSet
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_LightBlock__MapItr) Done() bool {
	return itr.idx >= 2
}

func (LightBlock) ListIterator() ipld.ListIterator {
	return nil
}
func (LightBlock) Length() int64 {
	return 2
}
func (LightBlock) IsAbsent() bool {
	return false
}
func (LightBlock) IsNull() bool {
	return false
}
func (LightBlock) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsBool()
}
func (LightBlock) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsInt()
}
func (LightBlock) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsFloat()
}
func (LightBlock) AsString() (string, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsString()
}
func (LightBlock) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsBytes()
}
func (LightBlock) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.LightBlock"}.AsLink()
}
func (LightBlock) Prototype() ipld.NodePrototype {
	return _LightBlock__Prototype{}
}

type _LightBlock__Prototype struct{}

func (_LightBlock__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _LightBlock__Builder
	nb.Reset()
	return &nb
}

type _LightBlock__Builder struct {
	_LightBlock__Assembler
}

func (nb *_LightBlock__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_LightBlock__Builder) Reset() {
	var w _LightBlock
	var m schema.Maybe
	*nb = _LightBlock__Builder{_LightBlock__Assembler{w: &w, m: &m}}
}

type _LightBlock__Assembler struct {
	w     *_LightBlock
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_SignedHeader _SignedHeader__Assembler
	ca_ValidatorSet _ValidatorSet__Assembler
}

func (na *_LightBlock__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_SignedHeader.reset()
	na.ca_ValidatorSet.reset()
}

var (
	fieldBit__LightBlock_SignedHeader = 1 << 0
	fieldBit__LightBlock_ValidatorSet = 1 << 1
	fieldBits__LightBlock_sufficient  = 0 + 1<<0 + 1<<1
)

func (na *_LightBlock__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_LightBlock{}
	}
	return na, nil
}
func (_LightBlock__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.BeginList(0)
}
func (na *_LightBlock__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_LightBlock__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignBool(false)
}
func (_LightBlock__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignInt(0)
}
func (_LightBlock__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignFloat(0)
}
func (_LightBlock__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignString("")
}
func (_LightBlock__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignBytes(nil)
}
func (_LightBlock__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock"}.AssignLink(nil)
}
func (na *_LightBlock__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_LightBlock); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.LightBlock", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_LightBlock__Assembler) Prototype() ipld.NodePrototype {
	return _LightBlock__Prototype{}
}
func (ma *_LightBlock__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_SignedHeader.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorSet.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_LightBlock__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "SignedHeader":
		if ma.s&fieldBit__LightBlock_SignedHeader != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_SignedHeader}
		}
		ma.s += fieldBit__LightBlock_SignedHeader
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_SignedHeader.w = &ma.w.SignedHeader
		ma.ca_SignedHeader.m = &ma.cm
		return &ma.ca_SignedHeader, nil
	case "ValidatorSet":
		if ma.s&fieldBit__LightBlock_ValidatorSet != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_ValidatorSet}
		}
		ma.s += fieldBit__LightBlock_ValidatorSet
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ValidatorSet.w = &ma.w.ValidatorSet
		ma.ca_ValidatorSet.m = &ma.cm
		return &ma.ca_ValidatorSet, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.LightBlock", Key: &_String{k}}
}
func (ma *_LightBlock__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_LightBlock__KeyAssembler)(ma)
}
func (ma *_LightBlock__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_SignedHeader.w = &ma.w.SignedHeader
		ma.ca_SignedHeader.m = &ma.cm
		return &ma.ca_SignedHeader
	case 1:
		ma.ca_ValidatorSet.w = &ma.w.ValidatorSet
		ma.ca_ValidatorSet.m = &ma.cm
		return &ma.ca_ValidatorSet
	default:
		panic("unreachable")
	}
}
func (ma *_LightBlock__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__LightBlock_sufficient != fieldBits__LightBlock_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__LightBlock_SignedHeader == 0 {
			err.Missing = append(err.Missing, "SignedHeader")
		}
		if ma.s&fieldBit__LightBlock_ValidatorSet == 0 {
			err.Missing = append(err.Missing, "ValidatorSet")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_LightBlock__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_LightBlock__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _LightBlock__KeyAssembler _LightBlock__Assembler

func (_LightBlock__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.BeginMap(0)
}
func (_LightBlock__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.BeginList(0)
}
func (na *_LightBlock__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignNull()
}
func (_LightBlock__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignBool(false)
}
func (_LightBlock__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignInt(0)
}
func (_LightBlock__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignFloat(0)
}
func (ka *_LightBlock__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "SignedHeader":
		if ka.s&fieldBit__LightBlock_SignedHeader != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_SignedHeader}
		}
		ka.s += fieldBit__LightBlock_SignedHeader
		ka.state = maState_expectValue
		ka.f = 0
	case "ValidatorSet":
		if ka.s&fieldBit__LightBlock_ValidatorSet != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_ValidatorSet}
		}
		ka.s += fieldBit__LightBlock_ValidatorSet
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.LightBlock", Key: &_String{k}}
	}
	return nil
}
func (_LightBlock__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignBytes(nil)
}
func (_LightBlock__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.KeyAssembler"}.AssignLink(nil)
}
func (ka *_LightBlock__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_LightBlock__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (LightBlock) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n LightBlock) Representation() ipld.Node {
	return (*_LightBlock__Repr)(n)
}

type _LightBlock__Repr _LightBlock

var (
	fieldName__LightBlock_SignedHeader_serial = _String{"SignedHeader"}
	fieldName__LightBlock_ValidatorSet_serial = _String{"ValidatorSet"}
)
var _ ipld.Node = &_LightBlock__Repr{}

func (_LightBlock__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_LightBlock__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "SignedHeader":
		return n.SignedHeader.Representation(), nil
	case "ValidatorSet":
		return n.ValidatorSet.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_LightBlock__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_LightBlock__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.LookupByIndex(0)
}
func (n _LightBlock__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_LightBlock__Repr) MapIterator() ipld.MapIterator {
	return &_LightBlock__ReprMapItr{n, 0}
}

type _LightBlock__ReprMapItr struct {
	n   *_LightBlock__Repr
	idx int
}

func (itr *_LightBlock__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__LightBlock_SignedHeader_serial
		v = itr.n.SignedHeader.Representation()
	case 1:
		k = &fieldName__LightBlock_ValidatorSet_serial
		v = itr.n.ValidatorSet.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_LightBlock__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_LightBlock__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_LightBlock__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_LightBlock__Repr) IsAbsent() bool {
	return false
}
func (_LightBlock__Repr) IsNull() bool {
	return false
}
func (_LightBlock__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsBool()
}
func (_LightBlock__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsInt()
}
func (_LightBlock__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsFloat()
}
func (_LightBlock__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsString()
}
func (_LightBlock__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsBytes()
}
func (_LightBlock__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.LightBlock.Repr"}.AsLink()
}
func (_LightBlock__Repr) Prototype() ipld.NodePrototype {
	return _LightBlock__ReprPrototype{}
}

type _LightBlock__ReprPrototype struct{}

func (_LightBlock__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _LightBlock__ReprBuilder
	nb.Reset()
	return &nb
}

type _LightBlock__ReprBuilder struct {
	_LightBlock__ReprAssembler
}

func (nb *_LightBlock__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_LightBlock__ReprBuilder) Reset() {
	var w _LightBlock
	var m schema.Maybe
	*nb = _LightBlock__ReprBuilder{_LightBlock__ReprAssembler{w: &w, m: &m}}
}

type _LightBlock__ReprAssembler struct {
	w     *_LightBlock
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_SignedHeader _SignedHeader__ReprAssembler
	ca_ValidatorSet _ValidatorSet__ReprAssembler
}

func (na *_LightBlock__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_SignedHeader.reset()
	na.ca_ValidatorSet.reset()
}
func (na *_LightBlock__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_LightBlock{}
	}
	return na, nil
}
func (_LightBlock__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.BeginList(0)
}
func (na *_LightBlock__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.LightBlock.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_LightBlock__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignBool(false)
}
func (_LightBlock__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignInt(0)
}
func (_LightBlock__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignFloat(0)
}
func (_LightBlock__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignString("")
}
func (_LightBlock__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignBytes(nil)
}
func (_LightBlock__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.LightBlock.Repr"}.AssignLink(nil)
}
func (na *_LightBlock__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_LightBlock); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.LightBlock.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_LightBlock__ReprAssembler) Prototype() ipld.NodePrototype {
	return _LightBlock__ReprPrototype{}
}
func (ma *_LightBlock__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_LightBlock__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "SignedHeader":
		if ma.s&fieldBit__LightBlock_SignedHeader != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_SignedHeader_serial}
		}
		ma.s += fieldBit__LightBlock_SignedHeader
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_SignedHeader.w = &ma.w.SignedHeader
		ma.ca_SignedHeader.m = &ma.cm
		return &ma.ca_SignedHeader, nil
	case "ValidatorSet":
		if ma.s&fieldBit__LightBlock_ValidatorSet != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_ValidatorSet_serial}
		}
		ma.s += fieldBit__LightBlock_ValidatorSet
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ValidatorSet.w = &ma.w.ValidatorSet
		ma.ca_ValidatorSet.m = &ma.cm
		return &ma.ca_ValidatorSet, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.LightBlock.Repr", Key: &_String{k}}
}
func (ma *_LightBlock__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_LightBlock__ReprKeyAssembler)(ma)
}
func (ma *_LightBlock__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_SignedHeader.w = &ma.w.SignedHeader
		ma.ca_SignedHeader.m = &ma.cm
		return &ma.ca_SignedHeader
	case 1:
		ma.ca_ValidatorSet.w = &ma.w.ValidatorSet
		ma.ca_ValidatorSet.m = &ma.cm
		return &ma.ca_ValidatorSet
	default:
		panic("unreachable")
	}
}
func (ma *_LightBlock__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__LightBlock_sufficient != fieldBits__LightBlock_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__LightBlock_SignedHeader == 0 {
			err.Missing = append(err.Missing, "SignedHeader")
		}
		if ma.s&fieldBit__LightBlock_ValidatorSet == 0 {
			err.Missing = append(err.Missing, "ValidatorSet")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_LightBlock__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_LightBlock__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _LightBlock__ReprKeyAssembler _LightBlock__ReprAssembler

func (_LightBlock__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.BeginMap(0)
}
func (_LightBlock__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_LightBlock__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignNull()
}
func (_LightBlock__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignBool(false)
}
func (_LightBlock__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignInt(0)
}
func (_LightBlock__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_LightBlock__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "SignedHeader":
		if ka.s&fieldBit__LightBlock_SignedHeader != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_SignedHeader_serial}
		}
		ka.s += fieldBit__LightBlock_SignedHeader
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "ValidatorSet":
		if ka.s&fieldBit__LightBlock_ValidatorSet != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightBlock_ValidatorSet_serial}
		}
		ka.s += fieldBit__LightBlock_ValidatorSet
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.LightBlock.Repr", Key: &_String{k}}
}
func (_LightBlock__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_LightBlock__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.LightBlock.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_LightBlock__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_LightBlock__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _LightClientAttackEvidence) FieldConflictingBlock() LightBlock {
	return &n.ConflictingBlock
}
func (n _LightClientAttackEvidence) FieldCommonHeight() Int {
	return &n.CommonHeight
}
func (n _LightClientAttackEvidence) FieldByzantineValidators() Validators {
	return &n.ByzantineValidators
}
func (n _LightClientAttackEvidence) FieldTotalVotingPower() Int {
	return &n.TotalVotingPower
}
func (n _LightClientAttackEvidence) FieldTimestamp() Time {
	return &n.Timestamp
}

type _LightClientAttackEvidence__Maybe struct {
	m schema.Maybe
	v LightClientAttackEvidence
}
type MaybeLightClientAttackEvidence = *_LightClientAttackEvidence__Maybe

func (m MaybeLightClientAttackEvidence) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLightClientAttackEvidence) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLightClientAttackEvidence) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLightClientAttackEvidence) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLightClientAttackEvidence) Must() LightClientAttackEvidence {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__LightClientAttackEvidence_ConflictingBlock    = _String{"ConflictingBlock"}
	fieldName__LightClientAttackEvidence_CommonHeight        = _String{"CommonHeight"}
	fieldName__LightClientAttackEvidence_ByzantineValidators = _String{"ByzantineValidators"}
	fieldName__LightClientAttackEvidence_TotalVotingPower    = _String{"TotalVotingPower"}
	fieldName__LightClientAttackEvidence_Timestamp           = _String{"Timestamp"}
)
var _ ipld.Node = (LightClientAttackEvidence)(&_LightClientAttackEvidence{})
var _ schema.TypedNode = (LightClientAttackEvidence)(&_LightClientAttackEvidence{})

func (LightClientAttackEvidence) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n LightClientAttackEvidence) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "ConflictingBlock":
		return &n.ConflictingBlock, nil
	case "CommonHeight":
		return &n.CommonHeight, nil
	case "ByzantineValidators":
		return &n.ByzantineValidators, nil
	case "TotalVotingPower":
		return &n.TotalVotingPower, nil
	case "Timestamp":
		return &n.Timestamp, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n LightClientAttackEvidence) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (LightClientAttackEvidence) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.LookupByIndex(0)
}
func (n LightClientAttackEvidence) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n LightClientAttackEvidence) MapIterator() ipld.MapIterator {
	return &_LightClientAttackEvidence__MapItr{n, 0}
}

type _LightClientAttackEvidence__MapItr struct {
	n   LightClientAttackEvidence
	idx int
}

func (itr *_LightClientAttackEvidence__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__LightClientAttackEvidence_ConflictingBlock
		v = &itr.n.ConflictingBlock
	case 1:
		k = &fieldName__LightClientAttackEvidence_CommonHeight
		v = &itr.n.CommonHeight
	case 2:
		k = &fieldName__LightClientAttackEvidence_ByzantineValidators
		v = &itr.n.ByzantineValidators
	case 3:
		k = &fieldName__LightClientAttackEvidence_TotalVotingPower
		v = &itr.n.TotalVotingPower
	case 4:
		k = &fieldName__LightClientAttackEvidence_Timestamp
		v = &itr.n.Timestamp
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_LightClientAttackEvidence__MapItr) Done() bool {
	return itr.idx >= 5
}

func (LightClientAttackEvidence) ListIterator() ipld.ListIterator {
	return nil
}
func (LightClientAttackEvidence) Length() int64 {
	return 5
}
func (LightClientAttackEvidence) IsAbsent() bool {
	return false
}
func (LightClientAttackEvidence) IsNull() bool {
	return false
}
func (LightClientAttackEvidence) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsBool()
}
func (LightClientAttackEvidence) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsInt()
}
func (LightClientAttackEvidence) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsFloat()
}
func (LightClientAttackEvidence) AsString() (string, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsString()
}
func (LightClientAttackEvidence) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsBytes()
}
func (LightClientAttackEvidence) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence"}.AsLink()
}
func (LightClientAttackEvidence) Prototype() ipld.NodePrototype {
	return _LightClientAttackEvidence__Prototype{}
}

type _LightClientAttackEvidence__Prototype struct{}

func (_LightClientAttackEvidence__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _LightClientAttackEvidence__Builder
	nb.Reset()
	return &nb
}

type _LightClientAttackEvidence__Builder struct {
	_LightClientAttackEvidence__Assembler
}

func (nb *_LightClientAttackEvidence__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_LightClientAttackEvidence__Builder) Reset() {
	var w _LightClientAttackEvidence
	var m schema.Maybe
	*nb = _LightClientAttackEvidence__Builder{_LightClientAttackEvidence__Assembler{w: &w, m: &m}}
}

type _LightClientAttackEvidence__Assembler struct {
	w     *_LightClientAttackEvidence
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                     schema.Maybe
	ca_ConflictingBlock    _LightBlock__Assembler
	ca_CommonHeight        _Int__Assembler
	ca_ByzantineValidators _Validators__Assembler
	ca_TotalVotingPower    _Int__Assembler
	ca_Timestamp           _Time__Assembler
}

func (na *_LightClientAttackEvidence__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_ConflictingBlock.reset()
	na.ca_CommonHeight.reset()
	na.ca_ByzantineValidators.reset()
	na.ca_TotalVotingPower.reset()
	na.ca_Timestamp.reset()
}

var (
	fieldBit__LightClientAttackEvidence_ConflictingBlock    = 1 << 0
	fieldBit__LightClientAttackEvidence_CommonHeight        = 1 << 1
	fieldBit__LightClientAttackEvidence_ByzantineValidators = 1 << 2
	fieldBit__LightClientAttackEvidence_TotalVotingPower    = 1 << 3
	fieldBit__LightClientAttackEvidence_Timestamp           = 1 << 4
	fieldBits__LightClientAttackEvidence_sufficient         = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4
)

func (na *_LightClientAttackEvidence__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_LightClientAttackEvidence{}
	}
	return na, nil
}
func (_LightClientAttackEvidence__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.BeginList(0)
}
func (na *_LightClientAttackEvidence__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_LightClientAttackEvidence__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignBool(false)
}
func (_LightClientAttackEvidence__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignInt(0)
}
func (_LightClientAttackEvidence__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignFloat(0)
}
func (_LightClientAttackEvidence__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignString("")
}
func (_LightClientAttackEvidence__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignBytes(nil)
}
func (_LightClientAttackEvidence__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence"}.AssignLink(nil)
}
func (na *_LightClientAttackEvidence__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_LightClientAttackEvidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.LightClientAttackEvidence", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_LightClientAttackEvidence__Assembler) Prototype() ipld.NodePrototype {
	return _LightClientAttackEvidence__Prototype{}
}
func (ma *_LightClientAttackEvidence__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ConflictingBlock.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_CommonHeight.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ByzantineValidators.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_TotalVotingPower.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Timestamp.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_LightClientAttackEvidence__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "ConflictingBlock":
		if ma.s&fieldBit__LightClientAttackEvidence_ConflictingBlock != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ConflictingBlock}
		}
		ma.s += fieldBit__LightClientAttackEvidence_ConflictingBlock
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_ConflictingBlock.w = &ma.w.ConflictingBlock
		ma.ca_ConflictingBlock.m = &ma.cm
		return &ma.ca_ConflictingBlock, nil
	case "CommonHeight":
		if ma.s&fieldBit__LightClientAttackEvidence_CommonHeight != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_CommonHeight}
		}
		ma.s += fieldBit__LightClientAttackEvidence_CommonHeight
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_CommonHeight.w = &ma.w.CommonHeight
		ma.ca_CommonHeight.m = &ma.cm
		return &ma.ca_CommonHeight, nil
	case "ByzantineValidators":
		if ma.s&fieldBit__LightClientAttackEvidence_ByzantineValidators != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ByzantineValidators}
		}
		ma.s += fieldBit__LightClientAttackEvidence_ByzantineValidators
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_ByzantineValidators.w = &ma.w.ByzantineValidators
		ma.ca_ByzantineValidators.m = &ma.cm
		return &ma.ca_ByzantineValidators, nil
	case "TotalVotingPower":
		if ma.s&fieldBit__LightClientAttackEvidence_TotalVotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_TotalVotingPower}
		}
		ma.s += fieldBit__LightClientAttackEvidence_TotalVotingPower
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower, nil
	case "Timestamp":
		if ma.s&fieldBit__LightClientAttackEvidence_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_Timestamp}
		}
		ma.s += fieldBit__LightClientAttackEvidence_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.LightClientAttackEvidence", Key: &_String{k}}
}
func (ma *_LightClientAttackEvidence__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_LightClientAttackEvidence__KeyAssembler)(ma)
}
func (ma *_LightClientAttackEvidence__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_ConflictingBlock.w = &ma.w.ConflictingBlock
		ma.ca_ConflictingBlock.m = &ma.cm
		return &ma.ca_ConflictingBlock
	case 1:
		ma.ca_CommonHeight.w = &ma.w.CommonHeight
		ma.ca_CommonHeight.m = &ma.cm
		return &ma.ca_CommonHeight
	case 2:
		ma.ca_ByzantineValidators.w = &ma.w.ByzantineValidators
		ma.ca_ByzantineValidators.m = &ma.cm
		return &ma.ca_ByzantineValidators
	case 3:
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	default:
		panic("unreachable")
	}
}
func (ma *_LightClientAttackEvidence__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__LightClientAttackEvidence_sufficient != fieldBits__LightClientAttackEvidence_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__LightClientAttackEvidence_ConflictingBlock == 0 {
			err.Missing = append(err.Missing, "ConflictingBlock")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_CommonHeight == 0 {
			err.Missing = append(err.Missing, "CommonHeight")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_ByzantineValidators == 0 {
			err.Missing = append(err.Missing, "ByzantineValidators")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_TotalVotingPower == 0 {
			err.Missing = append(err.Missing, "TotalVotingPower")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_LightClientAttackEvidence__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_LightClientAttackEvidence__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _LightClientAttackEvidence__KeyAssembler _LightClientAttackEvidence__Assembler

func (_LightClientAttackEvidence__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.BeginMap(0)
}
func (_LightClientAttackEvidence__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.BeginList(0)
}
func (na *_LightClientAttackEvidence__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignNull()
}
func (_LightClientAttackEvidence__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignBool(false)
}
func (_LightClientAttackEvidence__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignInt(0)
}
func (_LightClientAttackEvidence__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignFloat(0)
}
func (ka *_LightClientAttackEvidence__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "ConflictingBlock":
		if ka.s&fieldBit__LightClientAttackEvidence_ConflictingBlock != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ConflictingBlock}
		}
		ka.s += fieldBit__LightClientAttackEvidence_ConflictingBlock
		ka.state = maState_expectValue
		ka.f = 0
	case "CommonHeight":
		if ka.s&fieldBit__LightClientAttackEvidence_CommonHeight != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_CommonHeight}
		}
		ka.s += fieldBit__LightClientAttackEvidence_CommonHeight
		ka.state = maState_expectValue
		ka.f = 1
	case "ByzantineValidators":
		if ka.s&fieldBit__LightClientAttackEvidence_ByzantineValidators != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ByzantineValidators}
		}
		ka.s += fieldBit__LightClientAttackEvidence_ByzantineValidators
		ka.state = maState_expectValue
		ka.f = 2
	case "TotalVotingPower":
		if ka.s&fieldBit__LightClientAttackEvidence_TotalVotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_TotalVotingPower}
		}
		ka.s += fieldBit__LightClientAttackEvidence_TotalVotingPower
		ka.state = maState_expectValue
		ka.f = 3
	case "Timestamp":
		if ka.s&fieldBit__LightClientAttackEvidence_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_Timestamp}
		}
		ka.s += fieldBit__LightClientAttackEvidence_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.LightClientAttackEvidence", Key: &_String{k}}
	}
	return nil
}
func (_LightClientAttackEvidence__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignBytes(nil)
}
func (_LightClientAttackEvidence__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.KeyAssembler"}.AssignLink(nil)
}
func (ka *_LightClientAttackEvidence__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_LightClientAttackEvidence__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (LightClientAttackEvidence) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n LightClientAttackEvidence) Representation() ipld.Node {
	return (*_LightClientAttackEvidence__Repr)(n)
}

type _LightClientAttackEvidence__Repr _LightClientAttackEvidence

var (
	fieldName__LightClientAttackEvidence_ConflictingBlock_serial    = _String{"ConflictingBlock"}
	fieldName__LightClientAttackEvidence_CommonHeight_serial        = _String{"CommonHeight"}
	fieldName__LightClientAttackEvidence_ByzantineValidators_serial = _String{"ByzantineValidators"}
	fieldName__LightClientAttackEvidence_TotalVotingPower_serial    = _String{"TotalVotingPower"}
	fieldName__LightClientAttackEvidence_Timestamp_serial           = _String{"Timestamp"}
)
var _ ipld.Node = &_LightClientAttackEvidence__Repr{}

func (_LightClientAttackEvidence__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_LightClientAttackEvidence__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "ConflictingBlock":
		return n.ConflictingBlock.Representation(), nil
	case "CommonHeight":
		return n.CommonHeight.Representation(), nil
	case "ByzantineValidators":
		return n.ByzantineValidators.Representation(), nil
	case "TotalVotingPower":
		return n.TotalVotingPower.Representation(), nil
	case "Timestamp":
		return n.Timestamp.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_LightClientAttackEvidence__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_LightClientAttackEvidence__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.LookupByIndex(0)
}
func (n _LightClientAttackEvidence__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_LightClientAttackEvidence__Repr) MapIterator() ipld.MapIterator {
	return &_LightClientAttackEvidence__ReprMapItr{n, 0}
}

type _LightClientAttackEvidence__ReprMapItr struct {
	n   *_LightClientAttackEvidence__Repr
	idx int
}

func (itr *_LightClientAttackEvidence__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__LightClientAttackEvidence_ConflictingBlock_serial
		v = itr.n.ConflictingBlock.Representation()
	case 1:
		k = &fieldName__LightClientAttackEvidence_CommonHeight_serial
		v = itr.n.CommonHeight.Representation()
	case 2:
		k = &fieldName__LightClientAttackEvidence_ByzantineValidators_serial
		v = itr.n.ByzantineValidators.Representation()
	case 3:
		k = &fieldName__LightClientAttackEvidence_TotalVotingPower_serial
		v = itr.n.TotalVotingPower.Representation()
	case 4:
		k = &fieldName__LightClientAttackEvidence_Timestamp_serial
		v = itr.n.Timestamp.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_LightClientAttackEvidence__ReprMapItr) Done() bool {
	return itr.idx >= 5
}
func (_LightClientAttackEvidence__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_LightClientAttackEvidence__Repr) Length() int64 {
	l := 5
	return int64(l)
}
func (_LightClientAttackEvidence__Repr) IsAbsent() bool {
	return false
}
func (_LightClientAttackEvidence__Repr) IsNull() bool {
	return false
}
func (_LightClientAttackEvidence__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsBool()
}
func (_LightClientAttackEvidence__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsInt()
}
func (_LightClientAttackEvidence__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsFloat()
}
func (_LightClientAttackEvidence__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsString()
}
func (_LightClientAttackEvidence__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsBytes()
}
func (_LightClientAttackEvidence__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.LightClientAttackEvidence.Repr"}.AsLink()
}
func (_LightClientAttackEvidence__Repr) Prototype() ipld.NodePrototype {
	return _LightClientAttackEvidence__ReprPrototype{}
}

type _LightClientAttackEvidence__ReprPrototype struct{}

func (_LightClientAttackEvidence__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _LightClientAttackEvidence__ReprBuilder
	nb.Reset()
	return &nb
}

type _LightClientAttackEvidence__ReprBuilder struct {
	_LightClientAttackEvidence__ReprAssembler
}

func (nb *_LightClientAttackEvidence__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_LightClientAttackEvidence__ReprBuilder) Reset() {
	var w _LightClientAttackEvidence
	var m schema.Maybe
	*nb = _LightClientAttackEvidence__ReprBuilder{_LightClientAttackEvidence__ReprAssembler{w: &w, m: &m}}
}

type _LightClientAttackEvidence__ReprAssembler struct {
	w     *_LightClientAttackEvidence
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                     schema.Maybe
	ca_ConflictingBlock    _LightBlock__ReprAssembler
	ca_CommonHeight        _Int__ReprAssembler
	ca_ByzantineValidators _Validators__ReprAssembler
	ca_TotalVotingPower    _Int__ReprAssembler
	ca_Timestamp           _Time__ReprAssembler
}

func (na *_LightClientAttackEvidence__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_ConflictingBlock.reset()
	na.ca_CommonHeight.reset()
	na.ca_ByzantineValidators.reset()
	na.ca_TotalVotingPower.reset()
	na.ca_Timestamp.reset()
}
func (na *_LightClientAttackEvidence__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_LightClientAttackEvidence{}
	}
	return na, nil
}
func (_LightClientAttackEvidence__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.BeginList(0)
}
func (na *_LightClientAttackEvidence__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_LightClientAttackEvidence__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignBool(false)
}
func (_LightClientAttackEvidence__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignInt(0)
}
func (_LightClientAttackEvidence__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignFloat(0)
}
func (_LightClientAttackEvidence__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignString("")
}
func (_LightClientAttackEvidence__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignBytes(nil)
}
func (_LightClientAttackEvidence__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.LightClientAttackEvidence.Repr"}.AssignLink(nil)
}
func (na *_LightClientAttackEvidence__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_LightClientAttackEvidence); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.LightClientAttackEvidence.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_LightClientAttackEvidence__ReprAssembler) Prototype() ipld.NodePrototype {
	return _LightClientAttackEvidence__ReprPrototype{}
}
func (ma *_LightClientAttackEvidence__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_LightClientAttackEvidence__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "ConflictingBlock":
		if ma.s&fieldBit__LightClientAttackEvidence_ConflictingBlock != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ConflictingBlock_serial}
		}
		ma.s += fieldBit__LightClientAttackEvidence_ConflictingBlock
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_ConflictingBlock.w = &ma.w.ConflictingBlock
		ma.ca_ConflictingBlock.m = &ma.cm
		return &ma.ca_ConflictingBlock, nil
	case "CommonHeight":
		if ma.s&fieldBit__LightClientAttackEvidence_CommonHeight != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_CommonHeight_serial}
		}
		ma.s += fieldBit__LightClientAttackEvidence_CommonHeight
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_CommonHeight.w = &ma.w.CommonHeight
		ma.ca_CommonHeight.m = &ma.cm
		return &ma.ca_CommonHeight, nil
	case "ByzantineValidators":
		if ma.s&fieldBit__LightClientAttackEvidence_ByzantineValidators != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ByzantineValidators_serial}
		}
		ma.s += fieldBit__LightClientAttackEvidence_ByzantineValidators
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_ByzantineValidators.w = &ma.w.ByzantineValidators
		ma.ca_ByzantineValidators.m = &ma.cm
		return &ma.ca_ByzantineValidators, nil
	case "TotalVotingPower":
		if ma.s&fieldBit__LightClientAttackEvidence_TotalVotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_TotalVotingPower_serial}
		}
		ma.s += fieldBit__LightClientAttackEvidence_TotalVotingPower
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower, nil
	case "Timestamp":
		if ma.s&fieldBit__LightClientAttackEvidence_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_Timestamp_serial}
		}
		ma.s += fieldBit__LightClientAttackEvidence_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.LightClientAttackEvidence.Repr", Key: &_String{k}}
}
func (ma *_LightClientAttackEvidence__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_LightClientAttackEvidence__ReprKeyAssembler)(ma)
}
func (ma *_LightClientAttackEvidence__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_ConflictingBlock.w = &ma.w.ConflictingBlock
		ma.ca_ConflictingBlock.m = &ma.cm
		return &ma.ca_ConflictingBlock
	case 1:
		ma.ca_CommonHeight.w = &ma.w.CommonHeight
		ma.ca_CommonHeight.m = &ma.cm
		return &ma.ca_CommonHeight
	case 2:
		ma.ca_ByzantineValidators.w = &ma.w.ByzantineValidators
		ma.ca_ByzantineValidators.m = &ma.cm
		return &ma.ca_ByzantineValidators
	case 3:
		ma.ca_TotalVotingPower.w = &ma.w.TotalVotingPower
		ma.ca_TotalVotingPower.m = &ma.cm
		return &ma.ca_TotalVotingPower
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	default:
		panic("unreachable")
	}
}
func (ma *_LightClientAttackEvidence__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__LightClientAttackEvidence_sufficient != fieldBits__LightClientAttackEvidence_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__LightClientAttackEvidence_ConflictingBlock == 0 {
			err.Missing = append(err.Missing, "ConflictingBlock")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_CommonHeight == 0 {
			err.Missing = append(err.Missing, "CommonHeight")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_ByzantineValidators == 0 {
			err.Missing = append(err.Missing, "ByzantineValidators")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_TotalVotingPower == 0 {
			err.Missing = append(err.Missing, "TotalVotingPower")
		}
		if ma.s&fieldBit__LightClientAttackEvidence_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_LightClientAttackEvidence__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_LightClientAttackEvidence__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _LightClientAttackEvidence__ReprKeyAssembler _LightClientAttackEvidence__ReprAssembler

func (_LightClientAttackEvidence__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.BeginMap(0)
}
func (_LightClientAttackEvidence__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_LightClientAttackEvidence__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignNull()
}
func (_LightClientAttackEvidence__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignBool(false)
}
func (_LightClientAttackEvidence__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignInt(0)
}
func (_LightClientAttackEvidence__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_LightClientAttackEvidence__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "ConflictingBlock":
		if ka.s&fieldBit__LightClientAttackEvidence_ConflictingBlock != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ConflictingBlock_serial}
		}
		ka.s += fieldBit__LightClientAttackEvidence_ConflictingBlock
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "CommonHeight":
		if ka.s&fieldBit__LightClientAttackEvidence_CommonHeight != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_CommonHeight_serial}
		}
		ka.s += fieldBit__LightClientAttackEvidence_CommonHeight
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "ByzantineValidators":
		if ka.s&fieldBit__LightClientAttackEvidence_ByzantineValidators != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_ByzantineValidators_serial}
		}
		ka.s += fieldBit__LightClientAttackEvidence_ByzantineValidators
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "TotalVotingPower":
		if ka.s&fieldBit__LightClientAttackEvidence_TotalVotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_TotalVotingPower_serial}
		}
		ka.s += fieldBit__LightClientAttackEvidence_TotalVotingPower
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Timestamp":
		if ka.s&fieldBit__LightClientAttackEvidence_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__LightClientAttackEvidence_Timestamp_serial}
		}
		ka.s += fieldBit__LightClientAttackEvidence_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.LightClientAttackEvidence.Repr", Key: &_String{k}}
}
func (_LightClientAttackEvidence__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_LightClientAttackEvidence__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.LightClientAttackEvidence.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_LightClientAttackEvidence__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_LightClientAttackEvidence__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Link) Link() ipld.Link {
	return n.x
}
func (_Link__Prototype) FromLink(v ipld.Link) (Link, error) {
	n := _Link{v}
	return &n, nil
}

type _Link__Maybe struct {
	m schema.Maybe
	v Link
}
type MaybeLink = *_Link__Maybe

func (m MaybeLink) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLink) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLink) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLink) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLink) Must() Link {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Link)(&_Link{})
var _ schema.TypedNode = (Link)(&_Link{})

func (Link) Kind() ipld.Kind {
	return ipld.Kind_Link
}
func (Link) LookupByString(string) (ipld.Node, error) {
	return mixins.Link{"dagcosmos.Link"}.LookupByString("")
}
func (Link) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Link{"dagcosmos.Link"}.LookupByNode(nil)
}
func (Link) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Link{"dagcosmos.Link"}.LookupByIndex(0)
}
func (Link) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Link{"dagcosmos.Link"}.LookupBySegment(seg)
}
func (Link) MapIterator() ipld.MapIterator {
	return nil
}
func (Link) ListIterator() ipld.ListIterator {
	return nil
}
func (Link) Length() int64 {
	return -1
}
func (Link) IsAbsent() bool {
	return false
}
func (Link) IsNull() bool {
	return false
}
func (Link) AsBool() (bool, error) {
	return mixins.Link{"dagcosmos.Link"}.AsBool()
}
func (Link) AsInt() (int64, error) {
	return mixins.Link{"dagcosmos.Link"}.AsInt()
}
func (Link) AsFloat() (float64, error) {
	return mixins.Link{"dagcosmos.Link"}.AsFloat()
}
func (Link) AsString() (string, error) {
	return mixins.Link{"dagcosmos.Link"}.AsString()
}
func (Link) AsBytes() ([]byte, error) {
	return mixins.Link{"dagcosmos.Link"}.AsBytes()
}
func (n Link) AsLink() (ipld.Link, error) {
	return n.x, nil
}
func (Link) Prototype() ipld.NodePrototype {
	return _Link__Prototype{}
}

type _Link__Prototype struct{}

func (_Link__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Link__Builder
	nb.Reset()
	return &nb
}

type _Link__Builder struct {
	_Link__Assembler
}

func (nb *_Link__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Link__Builder) Reset() {
	var w _Link
	var m schema.Maybe
	*nb = _Link__Builder{_Link__Assembler{w: &w, m: &m}}
}

type _Link__Assembler struct {
	w *_Link
	m *schema.Maybe
}

func (na *_Link__Assembler) reset() {}
func (_Link__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.LinkAssembler{"dagcosmos.Link"}.BeginMap(0)
}
func (_Link__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.LinkAssembler{"dagcosmos.Link"}.BeginList(0)
}
func (na *_Link__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.LinkAssembler{"dagcosmos.Link"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Link__Assembler) AssignBool(bool) error {
	return mixins.LinkAssembler{"dagcosmos.Link"}.AssignBool(false)
}
func (_Link__Assembler) AssignInt(int64) error {
	return mixins.LinkAssembler{"dagcosmos.Link"}.AssignInt(0)
}
func (_Link__Assembler) AssignFloat(float64) error {
	return mixins.LinkAssembler{"dagcosmos.Link"}.AssignFloat(0)
}
func (_Link__Assembler) AssignString(string) error {
	return mixins.LinkAssembler{"dagcosmos.Link"}.AssignString("")
}
func (_Link__Assembler) AssignBytes([]byte) error {
	return mixins.LinkAssembler{"dagcosmos.Link"}.AssignBytes(nil)
}
func (na *_Link__Assembler) AssignLink(v ipld.Link) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Link{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (na *_Link__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Link); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsLink(); err != nil {
		return err
	} else {
		return na.AssignLink(v2)
	}
}
func (_Link__Assembler) Prototype() ipld.NodePrototype {
	return _Link__Prototype{}
}
func (Link) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Link) Representation() ipld.Node {
	return (*_Link__Repr)(n)
}

type _Link__Repr = _Link

var _ ipld.Node = &_Link__Repr{}

type _Link__ReprPrototype = _Link__Prototype
type _Link__ReprAssembler = _Link__Assembler

func (n _Part) FieldIndex() Uint {
	return &n.Index
}
func (n _Part) FieldBytes() HexBytes {
	return &n.Bytes
}
func (n _Part) FieldProof() Proof {
	return &n.Proof
}

type _Part__Maybe struct {
	m schema.Maybe
	v Part
}
type MaybePart = *_Part__Maybe

func (m MaybePart) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePart) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePart) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePart) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybePart) Must() Part {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Part_Index = _String{"Index"}
	fieldName__Part_Bytes = _String{"Bytes"}
	fieldName__Part_Proof = _String{"Proof"}
)
var _ ipld.Node = (Part)(&_Part{})
var _ schema.TypedNode = (Part)(&_Part{})

func (Part) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Part) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Index":
		return &n.Index, nil
	case "Bytes":
		return &n.Bytes, nil
	case "Proof":
		return &n.Proof, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Part) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Part) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Part"}.LookupByIndex(0)
}
func (n Part) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Part) MapIterator() ipld.MapIterator {
	return &_Part__MapItr{n, 0}
}

type _Part__MapItr struct {
	n   Part
	idx int
}

func (itr *_Part__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Part_Index
		v = &itr.n.Index
	case 1:
		k = &fieldName__Part_Bytes
		v = &itr.n.Bytes
	case 2:
		k = &fieldName__Part_Proof
		v = &itr.n.Proof
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Part__MapItr) Done() bool {
	return itr.idx >= 3
}

func (Part) ListIterator() ipld.ListIterator {
	return nil
}
func (Part) Length() int64 {
	return 3
}
func (Part) IsAbsent() bool {
	return false
}
func (Part) IsNull() bool {
	return false
}
func (Part) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Part"}.AsBool()
}
func (Part) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Part"}.AsInt()
}
func (Part) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Part"}.AsFloat()
}
func (Part) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Part"}.AsString()
}
func (Part) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Part"}.AsBytes()
}
func (Part) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Part"}.AsLink()
}
func (Part) Prototype() ipld.NodePrototype {
	return _Part__Prototype{}
}

type _Part__Prototype struct{}

func (_Part__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Part__Builder
	nb.Reset()
	return &nb
}

type _Part__Builder struct {
	_Part__Assembler
}

func (nb *_Part__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Part__Builder) Reset() {
	var w _Part
	var m schema.Maybe
	*nb = _Part__Builder{_Part__Assembler{w: &w, m: &m}}
}

type _Part__Assembler struct {
	w     *_Part
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Index _Uint__Assembler
	ca_Bytes _HexBytes__Assembler
	ca_Proof _Proof__Assembler
}

func (na *_Part__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Index.reset()
	na.ca_Bytes.reset()
	na.ca_Proof.reset()
}

var (
	fieldBit__Part_Index       = 1 << 0
	fieldBit__Part_Bytes       = 1 << 1
	fieldBit__Part_Proof       = 1 << 2
	fieldBits__Part_sufficient = 0 + 1<<0 + 1<<1 + 1<<2
)

func (na *_Part__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Part{}
	}
	return na, nil
}
func (_Part__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Part"}.BeginList(0)
}
func (na *_Part__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Part"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Part__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignBool(false)
}
func (_Part__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignInt(0)
}
func (_Part__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignFloat(0)
}
func (_Part__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignString("")
}
func (_Part__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignBytes(nil)
}
func (_Part__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Part"}.AssignLink(nil)
}
func (na *_Part__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Part); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Part", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Part__Assembler) Prototype() ipld.NodePrototype {
	return _Part__Prototype{}
}
func (ma *_Part__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Index.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Bytes.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Proof.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Part__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Index":
		if ma.s&fieldBit__Part_Index != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Index}
		}
		ma.s += fieldBit__Part_Index
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index, nil
	case "Bytes":
		if ma.s&fieldBit__Part_Bytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Bytes}
		}
		ma.s += fieldBit__Part_Bytes
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Bytes.w = &ma.w.Bytes
		ma.ca_Bytes.m = &ma.cm
		return &ma.ca_Bytes, nil
	case "Proof":
		if ma.s&fieldBit__Part_Proof != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Proof}
		}
		ma.s += fieldBit__Part_Proof
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Proof.w = &ma.w.Proof
		ma.ca_Proof.m = &ma.cm
		return &ma.ca_Proof, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Part", Key: &_String{k}}
}
func (ma *_Part__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Part__KeyAssembler)(ma)
}
func (ma *_Part__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index
	case 1:
		ma.ca_Bytes.w = &ma.w.Bytes
		ma.ca_Bytes.m = &ma.cm
		return &ma.ca_Bytes
	case 2:
		ma.ca_Proof.w = &ma.w.Proof
		ma.ca_Proof.m = &ma.cm
		return &ma.ca_Proof
	default:
		panic("unreachable")
	}
}
func (ma *_Part__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Part_sufficient != fieldBits__Part_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Part_Index == 0 {
			err.Missing = append(err.Missing, "Index")
		}
		if ma.s&fieldBit__Part_Bytes == 0 {
			err.Missing = append(err.Missing, "Bytes")
		}
		if ma.s&fieldBit__Part_Proof == 0 {
			err.Missing = append(err.Missing, "Proof")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Part__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Part__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Part__KeyAssembler _Part__Assembler

func (_Part__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.BeginMap(0)
}
func (_Part__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.BeginList(0)
}
func (na *_Part__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignNull()
}
func (_Part__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignBool(false)
}
func (_Part__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignInt(0)
}
func (_Part__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Part__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Index":
		if ka.s&fieldBit__Part_Index != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Index}
		}
		ka.s += fieldBit__Part_Index
		ka.state = maState_expectValue
		ka.f = 0
	case "Bytes":
		if ka.s&fieldBit__Part_Bytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Bytes}
		}
		ka.s += fieldBit__Part_Bytes
		ka.state = maState_expectValue
		ka.f = 1
	case "Proof":
		if ka.s&fieldBit__Part_Proof != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Proof}
		}
		ka.s += fieldBit__Part_Proof
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Part", Key: &_String{k}}
	}
	return nil
}
func (_Part__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignBytes(nil)
}
func (_Part__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Part.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Part__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Part__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Part) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Part) Representation() ipld.Node {
	return (*_Part__Repr)(n)
}

type _Part__Repr _Part

var (
	fieldName__Part_Index_serial = _String{"Index"}
	fieldName__Part_Bytes_serial = _String{"Bytes"}
	fieldName__Part_Proof_serial = _String{"Proof"}
)
var _ ipld.Node = &_Part__Repr{}

func (_Part__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Part__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Index":
		return n.Index.Representation(), nil
	case "Bytes":
		return n.Bytes.Representation(), nil
	case "Proof":
		return n.Proof.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Part__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Part__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.LookupByIndex(0)
}
func (n _Part__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Part__Repr) MapIterator() ipld.MapIterator {
	return &_Part__ReprMapItr{n, 0}
}

type _Part__ReprMapItr struct {
	n   *_Part__Repr
	idx int
}

func (itr *_Part__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Part_Index_serial
		v = itr.n.Index.Representation()
	case 1:
		k = &fieldName__Part_Bytes_serial
		v = itr.n.Bytes.Representation()
	case 2:
		k = &fieldName__Part_Proof_serial
		v = itr.n.Proof.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Part__ReprMapItr) Done() bool {
	return itr.idx >= 3
}
func (_Part__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Part__Repr) Length() int64 {
	l := 3
	return int64(l)
}
func (_Part__Repr) IsAbsent() bool {
	return false
}
func (_Part__Repr) IsNull() bool {
	return false
}
func (_Part__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsBool()
}
func (_Part__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsInt()
}
func (_Part__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsFloat()
}
func (_Part__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsString()
}
func (_Part__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsBytes()
}
func (_Part__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Part.Repr"}.AsLink()
}
func (_Part__Repr) Prototype() ipld.NodePrototype {
	return _Part__ReprPrototype{}
}

type _Part__ReprPrototype struct{}

func (_Part__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Part__ReprBuilder
	nb.Reset()
	return &nb
}

type _Part__ReprBuilder struct {
	_Part__ReprAssembler
}

func (nb *_Part__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Part__ReprBuilder) Reset() {
	var w _Part
	var m schema.Maybe
	*nb = _Part__ReprBuilder{_Part__ReprAssembler{w: &w, m: &m}}
}

type _Part__ReprAssembler struct {
	w     *_Part
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Index _Uint__ReprAssembler
	ca_Bytes _HexBytes__ReprAssembler
	ca_Proof _Proof__ReprAssembler
}

func (na *_Part__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Index.reset()
	na.ca_Bytes.reset()
	na.ca_Proof.reset()
}
func (na *_Part__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Part{}
	}
	return na, nil
}
func (_Part__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.BeginList(0)
}
func (na *_Part__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Part.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Part__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignBool(false)
}
func (_Part__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignInt(0)
}
func (_Part__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignFloat(0)
}
func (_Part__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignString("")
}
func (_Part__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignBytes(nil)
}
func (_Part__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Part.Repr"}.AssignLink(nil)
}
func (na *_Part__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Part); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Part.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Part__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Part__ReprPrototype{}
}
func (ma *_Part__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Part__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Index":
		if ma.s&fieldBit__Part_Index != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Index_serial}
		}
		ma.s += fieldBit__Part_Index
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index, nil
	case "Bytes":
		if ma.s&fieldBit__Part_Bytes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Bytes_serial}
		}
		ma.s += fieldBit__Part_Bytes
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Bytes.w = &ma.w.Bytes
		ma.ca_Bytes.m = &ma.cm
		return &ma.ca_Bytes, nil
	case "Proof":
		if ma.s&fieldBit__Part_Proof != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Proof_serial}
		}
		ma.s += fieldBit__Part_Proof
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Proof.w = &ma.w.Proof
		ma.ca_Proof.m = &ma.cm
		return &ma.ca_Proof, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Part.Repr", Key: &_String{k}}
}
func (ma *_Part__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Part__ReprKeyAssembler)(ma)
}
func (ma *_Part__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index
	case 1:
		ma.ca_Bytes.w = &ma.w.Bytes
		ma.ca_Bytes.m = &ma.cm
		return &ma.ca_Bytes
	case 2:
		ma.ca_Proof.w = &ma.w.Proof
		ma.ca_Proof.m = &ma.cm
		return &ma.ca_Proof
	default:
		panic("unreachable")
	}
}
func (ma *_Part__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Part_sufficient != fieldBits__Part_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Part_Index == 0 {
			err.Missing = append(err.Missing, "Index")
		}
		if ma.s&fieldBit__Part_Bytes == 0 {
			err.Missing = append(err.Missing, "Bytes")
		}
		if ma.s&fieldBit__Part_Proof == 0 {
			err.Missing = append(err.Missing, "Proof")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Part__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Part__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Part__ReprKeyAssembler _Part__ReprAssembler

func (_Part__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Part__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Part__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignNull()
}
func (_Part__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Part__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Part__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Part__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Index":
		if ka.s&fieldBit__Part_Index != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Index_serial}
		}
		ka.s += fieldBit__Part_Index
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Bytes":
		if ka.s&fieldBit__Part_Bytes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Bytes_serial}
		}
		ka.s += fieldBit__Part_Bytes
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Proof":
		if ka.s&fieldBit__Part_Proof != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Part_Proof_serial}
		}
		ka.s += fieldBit__Part_Proof
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Part.Repr", Key: &_String{k}}
}
func (_Part__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Part__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Part.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Part__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Part__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_PartSet) Lookup(idx int64) Part {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_PartSet) LookupMaybe(idx int64) MaybePart {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Part__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _PartSet__valueAbsent = _Part__Maybe{m: schema.Maybe_Absent}

func (n PartSet) Iterator() *PartSet__Itr {
	return &PartSet__Itr{n, 0}
}

type PartSet__Itr struct {
	n   PartSet
	idx int
}

func (itr *PartSet__Itr) Next() (idx int64, v Part) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *PartSet__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _PartSet__Maybe struct {
	m schema.Maybe
	v PartSet
}
type MaybePartSet = *_PartSet__Maybe

func (m MaybePartSet) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePartSet) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePartSet) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePartSet) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybePartSet) Must() PartSet {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (PartSet)(&_PartSet{})
var _ schema.TypedNode = (PartSet)(&_PartSet{})

func (PartSet) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (PartSet) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.PartSet"}.LookupByString("")
}
func (n PartSet) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n PartSet) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n PartSet) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.PartSet", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (PartSet) MapIterator() ipld.MapIterator {
	return nil
}
func (n PartSet) ListIterator() ipld.ListIterator {
	return &_PartSet__ListItr{n, 0}
}

type _PartSet__ListItr struct {
	n   PartSet
	idx int
}

func (itr *_PartSet__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_PartSet__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n PartSet) Length() int64 {
	return int64(len(n.x))
}
func (PartSet) IsAbsent() bool {
	return false
}
func (PartSet) IsNull() bool {
	return false
}
func (PartSet) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsBool()
}
func (PartSet) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsInt()
}
func (PartSet) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsFloat()
}
func (PartSet) AsString() (string, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsString()
}
func (PartSet) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsBytes()
}
func (PartSet) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.PartSet"}.AsLink()
}
func (PartSet) Prototype() ipld.NodePrototype {
	return _PartSet__Prototype{}
}

type _PartSet__Prototype struct{}

func (_PartSet__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _PartSet__Builder
	nb.Reset()
	return &nb
}

type _PartSet__Builder struct {
	_PartSet__Assembler
}

func (nb *_PartSet__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PartSet__Builder) Reset() {
	var w _PartSet
	var m schema.Maybe
	*nb = _PartSet__Builder{_PartSet__Assembler{w: &w, m: &m}}
}

type _PartSet__Assembler struct {
	w     *_PartSet
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Part__Assembler
}

func (na *_PartSet__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_PartSet__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.BeginMap(0)
}
func (na *_PartSet__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_PartSet{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Part, 0, sizeHint)
	}
	return na, nil
}
func (na *_PartSet__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PartSet__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignBool(false)
}
func (_PartSet__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignInt(0)
}
func (_PartSet__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignFloat(0)
}
func (_PartSet__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignString("")
}
func (_PartSet__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignBytes(nil)
}
func (_PartSet__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.PartSet"}.AssignLink(nil)
}
func (na *_PartSet__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PartSet); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.PartSet", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PartSet__Assembler) Prototype() ipld.NodePrototype {
	return _PartSet__Prototype{}
}
func (la *_PartSet__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_PartSet__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Part{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_PartSet__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_PartSet__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Part__Prototype{}
}
func (PartSet) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n PartSet) Representation() ipld.Node {
	return (*_PartSet__Repr)(n)
}

type _PartSet__Repr _PartSet

var _ ipld.Node = &_PartSet__Repr{}

func (_PartSet__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_PartSet__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.LookupByString("")
}
func (nr *_PartSet__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (PartSet)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Part).Representation(), nil
}
func (nr *_PartSet__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (PartSet)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Part).Representation(), nil
}
func (n _PartSet__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.PartSet.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_PartSet__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_PartSet__Repr) ListIterator() ipld.ListIterator {
	return &_PartSet__ReprListItr{(PartSet)(nr), 0}
}

type _PartSet__ReprListItr _PartSet__ListItr

func (itr *_PartSet__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_PartSet__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Part).Representation(), nil
}
func (itr *_PartSet__ReprListItr) Done() bool {
	return (*_PartSet__ListItr)(itr).Done()
}

func (rn *_PartSet__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_PartSet__Repr) IsAbsent() bool {
	return false
}
func (_PartSet__Repr) IsNull() bool {
	return false
}
func (_PartSet__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsBool()
}
func (_PartSet__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsInt()
}
func (_PartSet__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsFloat()
}
func (_PartSet__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsString()
}
func (_PartSet__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsBytes()
}
func (_PartSet__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.PartSet.Repr"}.AsLink()
}
func (_PartSet__Repr) Prototype() ipld.NodePrototype {
	return _PartSet__ReprPrototype{}
}

type _PartSet__ReprPrototype struct{}

func (_PartSet__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _PartSet__ReprBuilder
	nb.Reset()
	return &nb
}

type _PartSet__ReprBuilder struct {
	_PartSet__ReprAssembler
}

func (nb *_PartSet__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PartSet__ReprBuilder) Reset() {
	var w _PartSet
	var m schema.Maybe
	*nb = _PartSet__ReprBuilder{_PartSet__ReprAssembler{w: &w, m: &m}}
}

type _PartSet__ReprAssembler struct {
	w     *_PartSet
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Part__ReprAssembler
}

func (na *_PartSet__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_PartSet__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.BeginMap(0)
}
func (na *_PartSet__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_PartSet{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Part, 0, sizeHint)
	}
	return na, nil
}
func (na *_PartSet__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.PartSet.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PartSet__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignBool(false)
}
func (_PartSet__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignInt(0)
}
func (_PartSet__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignFloat(0)
}
func (_PartSet__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignString("")
}
func (_PartSet__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignBytes(nil)
}
func (_PartSet__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.PartSet.Repr"}.AssignLink(nil)
}
func (na *_PartSet__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PartSet); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.PartSet.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PartSet__ReprAssembler) Prototype() ipld.NodePrototype {
	return _PartSet__ReprPrototype{}
}
func (la *_PartSet__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_PartSet__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Part{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_PartSet__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_PartSet__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Part__ReprPrototype{}
}

func (n _PartSetHeader) FieldTotal() Uint {
	return &n.Total
}
func (n _PartSetHeader) FieldHash() Link {
	return &n.Hash
}

type _PartSetHeader__Maybe struct {
	m schema.Maybe
	v PartSetHeader
}
type MaybePartSetHeader = *_PartSetHeader__Maybe

func (m MaybePartSetHeader) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePartSetHeader) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePartSetHeader) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePartSetHeader) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybePartSetHeader) Must() PartSetHeader {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__PartSetHeader_Total = _String{"Total"}
	fieldName__PartSetHeader_Hash  = _String{"Hash"}
)
var _ ipld.Node = (PartSetHeader)(&_PartSetHeader{})
var _ schema.TypedNode = (PartSetHeader)(&_PartSetHeader{})

func (PartSetHeader) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n PartSetHeader) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Total":
		return &n.Total, nil
	case "Hash":
		return &n.Hash, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n PartSetHeader) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (PartSetHeader) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.LookupByIndex(0)
}
func (n PartSetHeader) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n PartSetHeader) MapIterator() ipld.MapIterator {
	return &_PartSetHeader__MapItr{n, 0}
}

type _PartSetHeader__MapItr struct {
	n   PartSetHeader
	idx int
}

func (itr *_PartSetHeader__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__PartSetHeader_Total
		v = &itr.n.Total
	case 1:
		k = &fieldName__PartSetHeader_Hash
		v = &itr.n.Hash
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_PartSetHeader__MapItr) Done() bool {
	return itr.idx >= 2
}

func (PartSetHeader) ListIterator() ipld.ListIterator {
	return nil
}
func (PartSetHeader) Length() int64 {
	return 2
}
func (PartSetHeader) IsAbsent() bool {
	return false
}
func (PartSetHeader) IsNull() bool {
	return false
}
func (PartSetHeader) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsBool()
}
func (PartSetHeader) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsInt()
}
func (PartSetHeader) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsFloat()
}
func (PartSetHeader) AsString() (string, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsString()
}
func (PartSetHeader) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsBytes()
}
func (PartSetHeader) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.PartSetHeader"}.AsLink()
}
func (PartSetHeader) Prototype() ipld.NodePrototype {
	return _PartSetHeader__Prototype{}
}

type _PartSetHeader__Prototype struct{}

func (_PartSetHeader__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _PartSetHeader__Builder
	nb.Reset()
	return &nb
}

type _PartSetHeader__Builder struct {
	_PartSetHeader__Assembler
}

func (nb *_PartSetHeader__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PartSetHeader__Builder) Reset() {
	var w _PartSetHeader
	var m schema.Maybe
	*nb = _PartSetHeader__Builder{_PartSetHeader__Assembler{w: &w, m: &m}}
}

type _PartSetHeader__Assembler struct {
	w     *_PartSetHeader
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Total _Uint__Assembler
	ca_Hash  _Link__Assembler
}

func (na *_PartSetHeader__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Total.reset()
	na.ca_Hash.reset()
}

var (
	fieldBit__PartSetHeader_Total       = 1 << 0
	fieldBit__PartSetHeader_Hash        = 1 << 1
	fieldBits__PartSetHeader_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_PartSetHeader__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_PartSetHeader{}
	}
	return na, nil
}
func (_PartSetHeader__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.BeginList(0)
}
func (na *_PartSetHeader__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PartSetHeader__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignBool(false)
}
func (_PartSetHeader__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignInt(0)
}
func (_PartSetHeader__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignFloat(0)
}
func (_PartSetHeader__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignString("")
}
func (_PartSetHeader__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignBytes(nil)
}
func (_PartSetHeader__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader"}.AssignLink(nil)
}
func (na *_PartSetHeader__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PartSetHeader); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.PartSetHeader", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PartSetHeader__Assembler) Prototype() ipld.NodePrototype {
	return _PartSetHeader__Prototype{}
}
func (ma *_PartSetHeader__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Total.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Hash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_PartSetHeader__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Total":
		if ma.s&fieldBit__PartSetHeader_Total != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Total}
		}
		ma.s += fieldBit__PartSetHeader_Total
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total, nil
	case "Hash":
		if ma.s&fieldBit__PartSetHeader_Hash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Hash}
		}
		ma.s += fieldBit__PartSetHeader_Hash
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.PartSetHeader", Key: &_String{k}}
}
func (ma *_PartSetHeader__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_PartSetHeader__KeyAssembler)(ma)
}
func (ma *_PartSetHeader__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total
	case 1:
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash
	default:
		panic("unreachable")
	}
}
func (ma *_PartSetHeader__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__PartSetHeader_sufficient != fieldBits__PartSetHeader_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__PartSetHeader_Total == 0 {
			err.Missing = append(err.Missing, "Total")
		}
		if ma.s&fieldBit__PartSetHeader_Hash == 0 {
			err.Missing = append(err.Missing, "Hash")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_PartSetHeader__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_PartSetHeader__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _PartSetHeader__KeyAssembler _PartSetHeader__Assembler

func (_PartSetHeader__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.BeginMap(0)
}
func (_PartSetHeader__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.BeginList(0)
}
func (na *_PartSetHeader__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignNull()
}
func (_PartSetHeader__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignBool(false)
}
func (_PartSetHeader__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignInt(0)
}
func (_PartSetHeader__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignFloat(0)
}
func (ka *_PartSetHeader__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Total":
		if ka.s&fieldBit__PartSetHeader_Total != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Total}
		}
		ka.s += fieldBit__PartSetHeader_Total
		ka.state = maState_expectValue
		ka.f = 0
	case "Hash":
		if ka.s&fieldBit__PartSetHeader_Hash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Hash}
		}
		ka.s += fieldBit__PartSetHeader_Hash
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.PartSetHeader", Key: &_String{k}}
	}
	return nil
}
func (_PartSetHeader__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignBytes(nil)
}
func (_PartSetHeader__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.KeyAssembler"}.AssignLink(nil)
}
func (ka *_PartSetHeader__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_PartSetHeader__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (PartSetHeader) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n PartSetHeader) Representation() ipld.Node {
	return (*_PartSetHeader__Repr)(n)
}

type _PartSetHeader__Repr _PartSetHeader

var (
	fieldName__PartSetHeader_Total_serial = _String{"Total"}
	fieldName__PartSetHeader_Hash_serial  = _String{"Hash"}
)
var _ ipld.Node = &_PartSetHeader__Repr{}

func (_PartSetHeader__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_PartSetHeader__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Total":
		return n.Total.Representation(), nil
	case "Hash":
		return n.Hash.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_PartSetHeader__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_PartSetHeader__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.LookupByIndex(0)
}
func (n _PartSetHeader__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_PartSetHeader__Repr) MapIterator() ipld.MapIterator {
	return &_PartSetHeader__ReprMapItr{n, 0}
}

type _PartSetHeader__ReprMapItr struct {
	n   *_PartSetHeader__Repr
	idx int
}

func (itr *_PartSetHeader__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__PartSetHeader_Total_serial
		v = itr.n.Total.Representation()
	case 1:
		k = &fieldName__PartSetHeader_Hash_serial
		v = itr.n.Hash.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_PartSetHeader__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_PartSetHeader__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_PartSetHeader__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_PartSetHeader__Repr) IsAbsent() bool {
	return false
}
func (_PartSetHeader__Repr) IsNull() bool {
	return false
}
func (_PartSetHeader__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsBool()
}
func (_PartSetHeader__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsInt()
}
func (_PartSetHeader__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsFloat()
}
func (_PartSetHeader__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsString()
}
func (_PartSetHeader__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsBytes()
}
func (_PartSetHeader__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.PartSetHeader.Repr"}.AsLink()
}
func (_PartSetHeader__Repr) Prototype() ipld.NodePrototype {
	return _PartSetHeader__ReprPrototype{}
}

type _PartSetHeader__ReprPrototype struct{}

func (_PartSetHeader__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _PartSetHeader__ReprBuilder
	nb.Reset()
	return &nb
}

type _PartSetHeader__ReprBuilder struct {
	_PartSetHeader__ReprAssembler
}

func (nb *_PartSetHeader__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PartSetHeader__ReprBuilder) Reset() {
	var w _PartSetHeader
	var m schema.Maybe
	*nb = _PartSetHeader__ReprBuilder{_PartSetHeader__ReprAssembler{w: &w, m: &m}}
}

type _PartSetHeader__ReprAssembler struct {
	w     *_PartSetHeader
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Total _Uint__ReprAssembler
	ca_Hash  _Link__ReprAssembler
}

func (na *_PartSetHeader__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Total.reset()
	na.ca_Hash.reset()
}
func (na *_PartSetHeader__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_PartSetHeader{}
	}
	return na, nil
}
func (_PartSetHeader__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.BeginList(0)
}
func (na *_PartSetHeader__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PartSetHeader__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignBool(false)
}
func (_PartSetHeader__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignInt(0)
}
func (_PartSetHeader__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignFloat(0)
}
func (_PartSetHeader__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignString("")
}
func (_PartSetHeader__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignBytes(nil)
}
func (_PartSetHeader__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.PartSetHeader.Repr"}.AssignLink(nil)
}
func (na *_PartSetHeader__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PartSetHeader); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.PartSetHeader.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PartSetHeader__ReprAssembler) Prototype() ipld.NodePrototype {
	return _PartSetHeader__ReprPrototype{}
}
func (ma *_PartSetHeader__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_PartSetHeader__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Total":
		if ma.s&fieldBit__PartSetHeader_Total != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Total_serial}
		}
		ma.s += fieldBit__PartSetHeader_Total
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total, nil
	case "Hash":
		if ma.s&fieldBit__PartSetHeader_Hash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Hash_serial}
		}
		ma.s += fieldBit__PartSetHeader_Hash
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.PartSetHeader.Repr", Key: &_String{k}}
}
func (ma *_PartSetHeader__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_PartSetHeader__ReprKeyAssembler)(ma)
}
func (ma *_PartSetHeader__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total
	case 1:
		ma.ca_Hash.w = &ma.w.Hash
		ma.ca_Hash.m = &ma.cm
		return &ma.ca_Hash
	default:
		panic("unreachable")
	}
}
func (ma *_PartSetHeader__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__PartSetHeader_sufficient != fieldBits__PartSetHeader_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__PartSetHeader_Total == 0 {
			err.Missing = append(err.Missing, "Total")
		}
		if ma.s&fieldBit__PartSetHeader_Hash == 0 {
			err.Missing = append(err.Missing, "Hash")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_PartSetHeader__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_PartSetHeader__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _PartSetHeader__ReprKeyAssembler _PartSetHeader__ReprAssembler

func (_PartSetHeader__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.BeginMap(0)
}
func (_PartSetHeader__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_PartSetHeader__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignNull()
}
func (_PartSetHeader__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignBool(false)
}
func (_PartSetHeader__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignInt(0)
}
func (_PartSetHeader__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_PartSetHeader__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Total":
		if ka.s&fieldBit__PartSetHeader_Total != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Total_serial}
		}
		ka.s += fieldBit__PartSetHeader_Total
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Hash":
		if ka.s&fieldBit__PartSetHeader_Hash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__PartSetHeader_Hash_serial}
		}
		ka.s += fieldBit__PartSetHeader_Hash
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.PartSetHeader.Repr", Key: &_String{k}}
}
func (_PartSetHeader__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_PartSetHeader__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.PartSetHeader.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_PartSetHeader__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_PartSetHeader__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n PrivKey) Bytes() []byte {
	return n.x
}
func (_PrivKey__Prototype) FromBytes(v []byte) (PrivKey, error) {
	n := _PrivKey{v}
	return &n, nil
}

type _PrivKey__Maybe struct {
	m schema.Maybe
	v PrivKey
}
type MaybePrivKey = *_PrivKey__Maybe

func (m MaybePrivKey) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePrivKey) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePrivKey) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePrivKey) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybePrivKey) Must() PrivKey {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (PrivKey)(&_PrivKey{})
var _ schema.TypedNode = (PrivKey)(&_PrivKey{})

func (PrivKey) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (PrivKey) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.LookupByString("")
}
func (PrivKey) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.LookupByNode(nil)
}
func (PrivKey) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.LookupByIndex(0)
}
func (PrivKey) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.LookupBySegment(seg)
}
func (PrivKey) MapIterator() ipld.MapIterator {
	return nil
}
func (PrivKey) ListIterator() ipld.ListIterator {
	return nil
}
func (PrivKey) Length() int64 {
	return -1
}
func (PrivKey) IsAbsent() bool {
	return false
}
func (PrivKey) IsNull() bool {
	return false
}
func (PrivKey) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.AsBool()
}
func (PrivKey) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.AsInt()
}
func (PrivKey) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.AsFloat()
}
func (PrivKey) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.AsString()
}
func (n PrivKey) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (PrivKey) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.PrivKey"}.AsLink()
}
func (PrivKey) Prototype() ipld.NodePrototype {
	return _PrivKey__Prototype{}
}

type _PrivKey__Prototype struct{}

func (_PrivKey__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _PrivKey__Builder
	nb.Reset()
	return &nb
}

type _PrivKey__Builder struct {
	_PrivKey__Assembler
}

func (nb *_PrivKey__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PrivKey__Builder) Reset() {
	var w _PrivKey
	var m schema.Maybe
	*nb = _PrivKey__Builder{_PrivKey__Assembler{w: &w, m: &m}}
}

type _PrivKey__Assembler struct {
	w *_PrivKey
	m *schema.Maybe
}

func (na *_PrivKey__Assembler) reset() {}
func (_PrivKey__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.BeginMap(0)
}
func (_PrivKey__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.BeginList(0)
}
func (na *_PrivKey__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_PrivKey__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignBool(false)
}
func (_PrivKey__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignInt(0)
}
func (_PrivKey__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignFloat(0)
}
func (_PrivKey__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignString("")
}
func (na *_PrivKey__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_PrivKey{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_PrivKey__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.PrivKey"}.AssignLink(nil)
}
func (na *_PrivKey__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PrivKey); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_PrivKey__Assembler) Prototype() ipld.NodePrototype {
	return _PrivKey__Prototype{}
}
func (PrivKey) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n PrivKey) Representation() ipld.Node {
	return (*_PrivKey__Repr)(n)
}

type _PrivKey__Repr = _PrivKey

var _ ipld.Node = &_PrivKey__Repr{}

type _PrivKey__ReprPrototype = _PrivKey__Prototype
type _PrivKey__ReprAssembler = _PrivKey__Assembler

func (n _Proof) FieldTotal() Int {
	return &n.Total
}
func (n _Proof) FieldIndex() Int {
	return &n.Index
}
func (n _Proof) FieldLeafHash() Hash {
	return &n.LeafHash
}
func (n _Proof) FieldAunts() Aunts {
	return &n.Aunts
}

type _Proof__Maybe struct {
	m schema.Maybe
	v Proof
}
type MaybeProof = *_Proof__Maybe

func (m MaybeProof) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeProof) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeProof) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeProof) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeProof) Must() Proof {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Proof_Total    = _String{"Total"}
	fieldName__Proof_Index    = _String{"Index"}
	fieldName__Proof_LeafHash = _String{"LeafHash"}
	fieldName__Proof_Aunts    = _String{"Aunts"}
)
var _ ipld.Node = (Proof)(&_Proof{})
var _ schema.TypedNode = (Proof)(&_Proof{})

func (Proof) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Proof) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Total":
		return &n.Total, nil
	case "Index":
		return &n.Index, nil
	case "LeafHash":
		return &n.LeafHash, nil
	case "Aunts":
		return &n.Aunts, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Proof) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Proof) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Proof"}.LookupByIndex(0)
}
func (n Proof) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Proof) MapIterator() ipld.MapIterator {
	return &_Proof__MapItr{n, 0}
}

type _Proof__MapItr struct {
	n   Proof
	idx int
}

func (itr *_Proof__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Proof_Total
		v = &itr.n.Total
	case 1:
		k = &fieldName__Proof_Index
		v = &itr.n.Index
	case 2:
		k = &fieldName__Proof_LeafHash
		v = &itr.n.LeafHash
	case 3:
		k = &fieldName__Proof_Aunts
		v = &itr.n.Aunts
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Proof__MapItr) Done() bool {
	return itr.idx >= 4
}

func (Proof) ListIterator() ipld.ListIterator {
	return nil
}
func (Proof) Length() int64 {
	return 4
}
func (Proof) IsAbsent() bool {
	return false
}
func (Proof) IsNull() bool {
	return false
}
func (Proof) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsBool()
}
func (Proof) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsInt()
}
func (Proof) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsFloat()
}
func (Proof) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsString()
}
func (Proof) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsBytes()
}
func (Proof) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Proof"}.AsLink()
}
func (Proof) Prototype() ipld.NodePrototype {
	return _Proof__Prototype{}
}

type _Proof__Prototype struct{}

func (_Proof__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Proof__Builder
	nb.Reset()
	return &nb
}

type _Proof__Builder struct {
	_Proof__Assembler
}

func (nb *_Proof__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Proof__Builder) Reset() {
	var w _Proof
	var m schema.Maybe
	*nb = _Proof__Builder{_Proof__Assembler{w: &w, m: &m}}
}

type _Proof__Assembler struct {
	w     *_Proof
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm          schema.Maybe
	ca_Total    _Int__Assembler
	ca_Index    _Int__Assembler
	ca_LeafHash _Hash__Assembler
	ca_Aunts    _Aunts__Assembler
}

func (na *_Proof__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Total.reset()
	na.ca_Index.reset()
	na.ca_LeafHash.reset()
	na.ca_Aunts.reset()
}

var (
	fieldBit__Proof_Total       = 1 << 0
	fieldBit__Proof_Index       = 1 << 1
	fieldBit__Proof_LeafHash    = 1 << 2
	fieldBit__Proof_Aunts       = 1 << 3
	fieldBits__Proof_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_Proof__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Proof{}
	}
	return na, nil
}
func (_Proof__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Proof"}.BeginList(0)
}
func (na *_Proof__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Proof"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Proof__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignBool(false)
}
func (_Proof__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignInt(0)
}
func (_Proof__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignFloat(0)
}
func (_Proof__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignString("")
}
func (_Proof__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignBytes(nil)
}
func (_Proof__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Proof"}.AssignLink(nil)
}
func (na *_Proof__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Proof); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Proof", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Proof__Assembler) Prototype() ipld.NodePrototype {
	return _Proof__Prototype{}
}
func (ma *_Proof__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Total.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Index.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_LeafHash.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Aunts.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Proof__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Total":
		if ma.s&fieldBit__Proof_Total != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Total}
		}
		ma.s += fieldBit__Proof_Total
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total, nil
	case "Index":
		if ma.s&fieldBit__Proof_Index != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Index}
		}
		ma.s += fieldBit__Proof_Index
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index, nil
	case "LeafHash":
		if ma.s&fieldBit__Proof_LeafHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_LeafHash}
		}
		ma.s += fieldBit__Proof_LeafHash
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_LeafHash.w = &ma.w.LeafHash
		ma.ca_LeafHash.m = &ma.cm
		return &ma.ca_LeafHash, nil
	case "Aunts":
		if ma.s&fieldBit__Proof_Aunts != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Aunts}
		}
		ma.s += fieldBit__Proof_Aunts
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Aunts.w = &ma.w.Aunts
		ma.ca_Aunts.m = &ma.cm
		return &ma.ca_Aunts, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Proof", Key: &_String{k}}
}
func (ma *_Proof__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Proof__KeyAssembler)(ma)
}
func (ma *_Proof__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total
	case 1:
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index
	case 2:
		ma.ca_LeafHash.w = &ma.w.LeafHash
		ma.ca_LeafHash.m = &ma.cm
		return &ma.ca_LeafHash
	case 3:
		ma.ca_Aunts.w = &ma.w.Aunts
		ma.ca_Aunts.m = &ma.cm
		return &ma.ca_Aunts
	default:
		panic("unreachable")
	}
}
func (ma *_Proof__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Proof_sufficient != fieldBits__Proof_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Proof_Total == 0 {
			err.Missing = append(err.Missing, "Total")
		}
		if ma.s&fieldBit__Proof_Index == 0 {
			err.Missing = append(err.Missing, "Index")
		}
		if ma.s&fieldBit__Proof_LeafHash == 0 {
			err.Missing = append(err.Missing, "LeafHash")
		}
		if ma.s&fieldBit__Proof_Aunts == 0 {
			err.Missing = append(err.Missing, "Aunts")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Proof__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Proof__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Proof__KeyAssembler _Proof__Assembler

func (_Proof__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.BeginMap(0)
}
func (_Proof__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.BeginList(0)
}
func (na *_Proof__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignNull()
}
func (_Proof__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignBool(false)
}
func (_Proof__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignInt(0)
}
func (_Proof__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Proof__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Total":
		if ka.s&fieldBit__Proof_Total != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Total}
		}
		ka.s += fieldBit__Proof_Total
		ka.state = maState_expectValue
		ka.f = 0
	case "Index":
		if ka.s&fieldBit__Proof_Index != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Index}
		}
		ka.s += fieldBit__Proof_Index
		ka.state = maState_expectValue
		ka.f = 1
	case "LeafHash":
		if ka.s&fieldBit__Proof_LeafHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_LeafHash}
		}
		ka.s += fieldBit__Proof_LeafHash
		ka.state = maState_expectValue
		ka.f = 2
	case "Aunts":
		if ka.s&fieldBit__Proof_Aunts != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Aunts}
		}
		ka.s += fieldBit__Proof_Aunts
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Proof", Key: &_String{k}}
	}
	return nil
}
func (_Proof__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignBytes(nil)
}
func (_Proof__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Proof.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Proof__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Proof__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Proof) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Proof) Representation() ipld.Node {
	return (*_Proof__Repr)(n)
}

type _Proof__Repr _Proof

var (
	fieldName__Proof_Total_serial    = _String{"Total"}
	fieldName__Proof_Index_serial    = _String{"Index"}
	fieldName__Proof_LeafHash_serial = _String{"LeafHash"}
	fieldName__Proof_Aunts_serial    = _String{"Aunts"}
)
var _ ipld.Node = &_Proof__Repr{}

func (_Proof__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Proof__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Total":
		return n.Total.Representation(), nil
	case "Index":
		return n.Index.Representation(), nil
	case "LeafHash":
		return n.LeafHash.Representation(), nil
	case "Aunts":
		return n.Aunts.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Proof__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Proof__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.LookupByIndex(0)
}
func (n _Proof__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Proof__Repr) MapIterator() ipld.MapIterator {
	return &_Proof__ReprMapItr{n, 0}
}

type _Proof__ReprMapItr struct {
	n   *_Proof__Repr
	idx int
}

func (itr *_Proof__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Proof_Total_serial
		v = itr.n.Total.Representation()
	case 1:
		k = &fieldName__Proof_Index_serial
		v = itr.n.Index.Representation()
	case 2:
		k = &fieldName__Proof_LeafHash_serial
		v = itr.n.LeafHash.Representation()
	case 3:
		k = &fieldName__Proof_Aunts_serial
		v = itr.n.Aunts.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Proof__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_Proof__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Proof__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_Proof__Repr) IsAbsent() bool {
	return false
}
func (_Proof__Repr) IsNull() bool {
	return false
}
func (_Proof__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsBool()
}
func (_Proof__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsInt()
}
func (_Proof__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsFloat()
}
func (_Proof__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsString()
}
func (_Proof__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsBytes()
}
func (_Proof__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Proof.Repr"}.AsLink()
}
func (_Proof__Repr) Prototype() ipld.NodePrototype {
	return _Proof__ReprPrototype{}
}

type _Proof__ReprPrototype struct{}

func (_Proof__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Proof__ReprBuilder
	nb.Reset()
	return &nb
}

type _Proof__ReprBuilder struct {
	_Proof__ReprAssembler
}

func (nb *_Proof__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Proof__ReprBuilder) Reset() {
	var w _Proof
	var m schema.Maybe
	*nb = _Proof__ReprBuilder{_Proof__ReprAssembler{w: &w, m: &m}}
}

type _Proof__ReprAssembler struct {
	w     *_Proof
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm          schema.Maybe
	ca_Total    _Int__ReprAssembler
	ca_Index    _Int__ReprAssembler
	ca_LeafHash _Hash__ReprAssembler
	ca_Aunts    _Aunts__ReprAssembler
}

func (na *_Proof__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Total.reset()
	na.ca_Index.reset()
	na.ca_LeafHash.reset()
	na.ca_Aunts.reset()
}
func (na *_Proof__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Proof{}
	}
	return na, nil
}
func (_Proof__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.BeginList(0)
}
func (na *_Proof__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Proof.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Proof__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignBool(false)
}
func (_Proof__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignInt(0)
}
func (_Proof__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignFloat(0)
}
func (_Proof__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignString("")
}
func (_Proof__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignBytes(nil)
}
func (_Proof__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Proof.Repr"}.AssignLink(nil)
}
func (na *_Proof__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Proof); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Proof.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Proof__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Proof__ReprPrototype{}
}
func (ma *_Proof__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Proof__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Total":
		if ma.s&fieldBit__Proof_Total != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Total_serial}
		}
		ma.s += fieldBit__Proof_Total
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total, nil
	case "Index":
		if ma.s&fieldBit__Proof_Index != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Index_serial}
		}
		ma.s += fieldBit__Proof_Index
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index, nil
	case "LeafHash":
		if ma.s&fieldBit__Proof_LeafHash != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_LeafHash_serial}
		}
		ma.s += fieldBit__Proof_LeafHash
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_LeafHash.w = &ma.w.LeafHash
		ma.ca_LeafHash.m = &ma.cm
		return &ma.ca_LeafHash, nil
	case "Aunts":
		if ma.s&fieldBit__Proof_Aunts != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Aunts_serial}
		}
		ma.s += fieldBit__Proof_Aunts
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Aunts.w = &ma.w.Aunts
		ma.ca_Aunts.m = &ma.cm
		return &ma.ca_Aunts, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Proof.Repr", Key: &_String{k}}
}
func (ma *_Proof__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Proof__ReprKeyAssembler)(ma)
}
func (ma *_Proof__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Total.w = &ma.w.Total
		ma.ca_Total.m = &ma.cm
		return &ma.ca_Total
	case 1:
		ma.ca_Index.w = &ma.w.Index
		ma.ca_Index.m = &ma.cm
		return &ma.ca_Index
	case 2:
		ma.ca_LeafHash.w = &ma.w.LeafHash
		ma.ca_LeafHash.m = &ma.cm
		return &ma.ca_LeafHash
	case 3:
		ma.ca_Aunts.w = &ma.w.Aunts
		ma.ca_Aunts.m = &ma.cm
		return &ma.ca_Aunts
	default:
		panic("unreachable")
	}
}
func (ma *_Proof__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Proof_sufficient != fieldBits__Proof_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Proof_Total == 0 {
			err.Missing = append(err.Missing, "Total")
		}
		if ma.s&fieldBit__Proof_Index == 0 {
			err.Missing = append(err.Missing, "Index")
		}
		if ma.s&fieldBit__Proof_LeafHash == 0 {
			err.Missing = append(err.Missing, "LeafHash")
		}
		if ma.s&fieldBit__Proof_Aunts == 0 {
			err.Missing = append(err.Missing, "Aunts")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Proof__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Proof__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Proof__ReprKeyAssembler _Proof__ReprAssembler

func (_Proof__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Proof__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Proof__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignNull()
}
func (_Proof__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Proof__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Proof__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Proof__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Total":
		if ka.s&fieldBit__Proof_Total != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Total_serial}
		}
		ka.s += fieldBit__Proof_Total
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Index":
		if ka.s&fieldBit__Proof_Index != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Index_serial}
		}
		ka.s += fieldBit__Proof_Index
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "LeafHash":
		if ka.s&fieldBit__Proof_LeafHash != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_LeafHash_serial}
		}
		ka.s += fieldBit__Proof_LeafHash
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Aunts":
		if ka.s&fieldBit__Proof_Aunts != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proof_Aunts_serial}
		}
		ka.s += fieldBit__Proof_Aunts
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Proof.Repr", Key: &_String{k}}
}
func (_Proof__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Proof__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Proof.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Proof__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Proof__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _Proposal) FieldType() SignedMsgType {
	return &n.Type
}
func (n _Proposal) FieldHeight() Int {
	return &n.Height
}
func (n _Proposal) FieldRound() Int {
	return &n.Round
}
func (n _Proposal) FieldPOLRound() Int {
	return &n.POLRound
}
func (n _Proposal) FieldBlockID() BlockID {
	return &n.BlockID
}
func (n _Proposal) FieldTimestamp() Time {
	return &n.Timestamp
}
func (n _Proposal) FieldSignature() Signature {
	return &n.Signature
}

type _Proposal__Maybe struct {
	m schema.Maybe
	v Proposal
}
type MaybeProposal = *_Proposal__Maybe

func (m MaybeProposal) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeProposal) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeProposal) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeProposal) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeProposal) Must() Proposal {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Proposal_Type      = _String{"Type"}
	fieldName__Proposal_Height    = _String{"Height"}
	fieldName__Proposal_Round     = _String{"Round"}
	fieldName__Proposal_POLRound  = _String{"POLRound"}
	fieldName__Proposal_BlockID   = _String{"BlockID"}
	fieldName__Proposal_Timestamp = _String{"Timestamp"}
	fieldName__Proposal_Signature = _String{"Signature"}
)
var _ ipld.Node = (Proposal)(&_Proposal{})
var _ schema.TypedNode = (Proposal)(&_Proposal{})

func (Proposal) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Proposal) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Type":
		return &n.Type, nil
	case "Height":
		return &n.Height, nil
	case "Round":
		return &n.Round, nil
	case "POLRound":
		return &n.POLRound, nil
	case "BlockID":
		return &n.BlockID, nil
	case "Timestamp":
		return &n.Timestamp, nil
	case "Signature":
		return &n.Signature, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Proposal) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Proposal) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Proposal"}.LookupByIndex(0)
}
func (n Proposal) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Proposal) MapIterator() ipld.MapIterator {
	return &_Proposal__MapItr{n, 0}
}

type _Proposal__MapItr struct {
	n   Proposal
	idx int
}

func (itr *_Proposal__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 7 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Proposal_Type
		v = &itr.n.Type
	case 1:
		k = &fieldName__Proposal_Height
		v = &itr.n.Height
	case 2:
		k = &fieldName__Proposal_Round
		v = &itr.n.Round
	case 3:
		k = &fieldName__Proposal_POLRound
		v = &itr.n.POLRound
	case 4:
		k = &fieldName__Proposal_BlockID
		v = &itr.n.BlockID
	case 5:
		k = &fieldName__Proposal_Timestamp
		v = &itr.n.Timestamp
	case 6:
		k = &fieldName__Proposal_Signature
		v = &itr.n.Signature
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Proposal__MapItr) Done() bool {
	return itr.idx >= 7
}

func (Proposal) ListIterator() ipld.ListIterator {
	return nil
}
func (Proposal) Length() int64 {
	return 7
}
func (Proposal) IsAbsent() bool {
	return false
}
func (Proposal) IsNull() bool {
	return false
}
func (Proposal) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsBool()
}
func (Proposal) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsInt()
}
func (Proposal) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsFloat()
}
func (Proposal) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsString()
}
func (Proposal) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsBytes()
}
func (Proposal) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Proposal"}.AsLink()
}
func (Proposal) Prototype() ipld.NodePrototype {
	return _Proposal__Prototype{}
}

type _Proposal__Prototype struct{}

func (_Proposal__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Proposal__Builder
	nb.Reset()
	return &nb
}

type _Proposal__Builder struct {
	_Proposal__Assembler
}

func (nb *_Proposal__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Proposal__Builder) Reset() {
	var w _Proposal
	var m schema.Maybe
	*nb = _Proposal__Builder{_Proposal__Assembler{w: &w, m: &m}}
}

type _Proposal__Assembler struct {
	w     *_Proposal
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm           schema.Maybe
	ca_Type      _SignedMsgType__Assembler
	ca_Height    _Int__Assembler
	ca_Round     _Int__Assembler
	ca_POLRound  _Int__Assembler
	ca_BlockID   _BlockID__Assembler
	ca_Timestamp _Time__Assembler
	ca_Signature _Signature__Assembler
}

func (na *_Proposal__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Type.reset()
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_POLRound.reset()
	na.ca_BlockID.reset()
	na.ca_Timestamp.reset()
	na.ca_Signature.reset()
}

var (
	fieldBit__Proposal_Type        = 1 << 0
	fieldBit__Proposal_Height      = 1 << 1
	fieldBit__Proposal_Round       = 1 << 2
	fieldBit__Proposal_POLRound    = 1 << 3
	fieldBit__Proposal_BlockID     = 1 << 4
	fieldBit__Proposal_Timestamp   = 1 << 5
	fieldBit__Proposal_Signature   = 1 << 6
	fieldBits__Proposal_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6
)

func (na *_Proposal__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Proposal{}
	}
	return na, nil
}
func (_Proposal__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.BeginList(0)
}
func (na *_Proposal__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Proposal__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignBool(false)
}
func (_Proposal__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignInt(0)
}
func (_Proposal__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignFloat(0)
}
func (_Proposal__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignString("")
}
func (_Proposal__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignBytes(nil)
}
func (_Proposal__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Proposal"}.AssignLink(nil)
}
func (na *_Proposal__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Proposal); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Proposal", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Proposal__Assembler) Prototype() ipld.NodePrototype {
	return _Proposal__Prototype{}
}
func (ma *_Proposal__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Type.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Height.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Round.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_POLRound.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Timestamp.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Signature.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Proposal__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Type":
		if ma.s&fieldBit__Proposal_Type != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Type}
		}
		ma.s += fieldBit__Proposal_Type
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Type.w = &ma.w.Type
		ma.ca_Type.m = &ma.cm
		return &ma.ca_Type, nil
	case "Height":
		if ma.s&fieldBit__Proposal_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Height}
		}
		ma.s += fieldBit__Proposal_Height
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Proposal_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Round}
		}
		ma.s += fieldBit__Proposal_Round
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "POLRound":
		if ma.s&fieldBit__Proposal_POLRound != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_POLRound}
		}
		ma.s += fieldBit__Proposal_POLRound
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_POLRound.w = &ma.w.POLRound
		ma.ca_POLRound.m = &ma.cm
		return &ma.ca_POLRound, nil
	case "BlockID":
		if ma.s&fieldBit__Proposal_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_BlockID}
		}
		ma.s += fieldBit__Proposal_BlockID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Timestamp":
		if ma.s&fieldBit__Proposal_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Timestamp}
		}
		ma.s += fieldBit__Proposal_Timestamp
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "Signature":
		if ma.s&fieldBit__Proposal_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Signature}
		}
		ma.s += fieldBit__Proposal_Signature
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Proposal", Key: &_String{k}}
}
func (ma *_Proposal__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Proposal__KeyAssembler)(ma)
}
func (ma *_Proposal__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Type.w = &ma.w.Type
		ma.ca_Type.m = &ma.cm
		return &ma.ca_Type
	case 1:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 2:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 3:
		ma.ca_POLRound.w = &ma.w.POLRound
		ma.ca_POLRound.m = &ma.cm
		return &ma.ca_POLRound
	case 4:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 5:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 6:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_Proposal__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Proposal_sufficient != fieldBits__Proposal_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Proposal_Type == 0 {
			err.Missing = append(err.Missing, "Type")
		}
		if ma.s&fieldBit__Proposal_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Proposal_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Proposal_POLRound == 0 {
			err.Missing = append(err.Missing, "POLRound")
		}
		if ma.s&fieldBit__Proposal_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Proposal_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__Proposal_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Proposal__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Proposal__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Proposal__KeyAssembler _Proposal__Assembler

func (_Proposal__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.BeginMap(0)
}
func (_Proposal__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.BeginList(0)
}
func (na *_Proposal__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignNull()
}
func (_Proposal__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignBool(false)
}
func (_Proposal__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignInt(0)
}
func (_Proposal__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Proposal__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Type":
		if ka.s&fieldBit__Proposal_Type != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Type}
		}
		ka.s += fieldBit__Proposal_Type
		ka.state = maState_expectValue
		ka.f = 0
	case "Height":
		if ka.s&fieldBit__Proposal_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Height}
		}
		ka.s += fieldBit__Proposal_Height
		ka.state = maState_expectValue
		ka.f = 1
	case "Round":
		if ka.s&fieldBit__Proposal_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Round}
		}
		ka.s += fieldBit__Proposal_Round
		ka.state = maState_expectValue
		ka.f = 2
	case "POLRound":
		if ka.s&fieldBit__Proposal_POLRound != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_POLRound}
		}
		ka.s += fieldBit__Proposal_POLRound
		ka.state = maState_expectValue
		ka.f = 3
	case "BlockID":
		if ka.s&fieldBit__Proposal_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_BlockID}
		}
		ka.s += fieldBit__Proposal_BlockID
		ka.state = maState_expectValue
		ka.f = 4
	case "Timestamp":
		if ka.s&fieldBit__Proposal_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Timestamp}
		}
		ka.s += fieldBit__Proposal_Timestamp
		ka.state = maState_expectValue
		ka.f = 5
	case "Signature":
		if ka.s&fieldBit__Proposal_Signature != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Signature}
		}
		ka.s += fieldBit__Proposal_Signature
		ka.state = maState_expectValue
		ka.f = 6
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Proposal", Key: &_String{k}}
	}
	return nil
}
func (_Proposal__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignBytes(nil)
}
func (_Proposal__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Proposal__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Proposal__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Proposal) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Proposal) Representation() ipld.Node {
	return (*_Proposal__Repr)(n)
}

type _Proposal__Repr _Proposal

var (
	fieldName__Proposal_Type_serial      = _String{"Type"}
	fieldName__Proposal_Height_serial    = _String{"Height"}
	fieldName__Proposal_Round_serial     = _String{"Round"}
	fieldName__Proposal_POLRound_serial  = _String{"POLRound"}
	fieldName__Proposal_BlockID_serial   = _String{"BlockID"}
	fieldName__Proposal_Timestamp_serial = _String{"Timestamp"}
	fieldName__Proposal_Signature_serial = _String{"Signature"}
)
var _ ipld.Node = &_Proposal__Repr{}

func (_Proposal__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Proposal__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Type":
		return n.Type.Representation(), nil
	case "Height":
		return n.Height.Representation(), nil
	case "Round":
		return n.Round.Representation(), nil
	case "POLRound":
		return n.POLRound.Representation(), nil
	case "BlockID":
		return n.BlockID.Representation(), nil
	case "Timestamp":
		return n.Timestamp.Representation(), nil
	case "Signature":
		return n.Signature.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Proposal__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Proposal__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.LookupByIndex(0)
}
func (n _Proposal__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Proposal__Repr) MapIterator() ipld.MapIterator {
	return &_Proposal__ReprMapItr{n, 0}
}

type _Proposal__ReprMapItr struct {
	n   *_Proposal__Repr
	idx int
}

func (itr *_Proposal__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 7 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Proposal_Type_serial
		v = itr.n.Type.Representation()
	case 1:
		k = &fieldName__Proposal_Height_serial
		v = itr.n.Height.Representation()
	case 2:
		k = &fieldName__Proposal_Round_serial
		v = itr.n.Round.Representation()
	case 3:
		k = &fieldName__Proposal_POLRound_serial
		v = itr.n.POLRound.Representation()
	case 4:
		k = &fieldName__Proposal_BlockID_serial
		v = itr.n.BlockID.Representation()
	case 5:
		k = &fieldName__Proposal_Timestamp_serial
		v = itr.n.Timestamp.Representation()
	case 6:
		k = &fieldName__Proposal_Signature_serial
		v = itr.n.Signature.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Proposal__ReprMapItr) Done() bool {
	return itr.idx >= 7
}
func (_Proposal__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Proposal__Repr) Length() int64 {
	l := 7
	return int64(l)
}
func (_Proposal__Repr) IsAbsent() bool {
	return false
}
func (_Proposal__Repr) IsNull() bool {
	return false
}
func (_Proposal__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsBool()
}
func (_Proposal__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsInt()
}
func (_Proposal__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsFloat()
}
func (_Proposal__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsString()
}
func (_Proposal__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsBytes()
}
func (_Proposal__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Proposal.Repr"}.AsLink()
}
func (_Proposal__Repr) Prototype() ipld.NodePrototype {
	return _Proposal__ReprPrototype{}
}

type _Proposal__ReprPrototype struct{}

func (_Proposal__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Proposal__ReprBuilder
	nb.Reset()
	return &nb
}

type _Proposal__ReprBuilder struct {
	_Proposal__ReprAssembler
}

func (nb *_Proposal__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Proposal__ReprBuilder) Reset() {
	var w _Proposal
	var m schema.Maybe
	*nb = _Proposal__ReprBuilder{_Proposal__ReprAssembler{w: &w, m: &m}}
}

type _Proposal__ReprAssembler struct {
	w     *_Proposal
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm           schema.Maybe
	ca_Type      _SignedMsgType__ReprAssembler
	ca_Height    _Int__ReprAssembler
	ca_Round     _Int__ReprAssembler
	ca_POLRound  _Int__ReprAssembler
	ca_BlockID   _BlockID__ReprAssembler
	ca_Timestamp _Time__ReprAssembler
	ca_Signature _Signature__ReprAssembler
}

func (na *_Proposal__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Type.reset()
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_POLRound.reset()
	na.ca_BlockID.reset()
	na.ca_Timestamp.reset()
	na.ca_Signature.reset()
}
func (na *_Proposal__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Proposal{}
	}
	return na, nil
}
func (_Proposal__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.BeginList(0)
}
func (na *_Proposal__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Proposal.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Proposal__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignBool(false)
}
func (_Proposal__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignInt(0)
}
func (_Proposal__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignFloat(0)
}
func (_Proposal__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignString("")
}
func (_Proposal__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignBytes(nil)
}
func (_Proposal__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Proposal.Repr"}.AssignLink(nil)
}
func (na *_Proposal__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Proposal); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Proposal.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Proposal__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Proposal__ReprPrototype{}
}
func (ma *_Proposal__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Proposal__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Type":
		if ma.s&fieldBit__Proposal_Type != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Type_serial}
		}
		ma.s += fieldBit__Proposal_Type
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Type.w = &ma.w.Type
		ma.ca_Type.m = &ma.cm
		return &ma.ca_Type, nil
	case "Height":
		if ma.s&fieldBit__Proposal_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Height_serial}
		}
		ma.s += fieldBit__Proposal_Height
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Proposal_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Round_serial}
		}
		ma.s += fieldBit__Proposal_Round
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "POLRound":
		if ma.s&fieldBit__Proposal_POLRound != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_POLRound_serial}
		}
		ma.s += fieldBit__Proposal_POLRound
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_POLRound.w = &ma.w.POLRound
		ma.ca_POLRound.m = &ma.cm
		return &ma.ca_POLRound, nil
	case "BlockID":
		if ma.s&fieldBit__Proposal_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_BlockID_serial}
		}
		ma.s += fieldBit__Proposal_BlockID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Timestamp":
		if ma.s&fieldBit__Proposal_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Timestamp_serial}
		}
		ma.s += fieldBit__Proposal_Timestamp
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "Signature":
		if ma.s&fieldBit__Proposal_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Signature_serial}
		}
		ma.s += fieldBit__Proposal_Signature
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Proposal.Repr", Key: &_String{k}}
}
func (ma *_Proposal__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Proposal__ReprKeyAssembler)(ma)
}
func (ma *_Proposal__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Type.w = &ma.w.Type
		ma.ca_Type.m = &ma.cm
		return &ma.ca_Type
	case 1:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 2:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 3:
		ma.ca_POLRound.w = &ma.w.POLRound
		ma.ca_POLRound.m = &ma.cm
		return &ma.ca_POLRound
	case 4:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 5:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 6:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_Proposal__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Proposal_sufficient != fieldBits__Proposal_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Proposal_Type == 0 {
			err.Missing = append(err.Missing, "Type")
		}
		if ma.s&fieldBit__Proposal_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Proposal_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Proposal_POLRound == 0 {
			err.Missing = append(err.Missing, "POLRound")
		}
		if ma.s&fieldBit__Proposal_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Proposal_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__Proposal_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Proposal__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Proposal__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Proposal__ReprKeyAssembler _Proposal__ReprAssembler

func (_Proposal__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Proposal__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Proposal__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignNull()
}
func (_Proposal__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Proposal__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Proposal__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Proposal__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Type":
		if ka.s&fieldBit__Proposal_Type != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Type_serial}
		}
		ka.s += fieldBit__Proposal_Type
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Height":
		if ka.s&fieldBit__Proposal_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Height_serial}
		}
		ka.s += fieldBit__Proposal_Height
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Round":
		if ka.s&fieldBit__Proposal_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Round_serial}
		}
		ka.s += fieldBit__Proposal_Round
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "POLRound":
		if ka.s&fieldBit__Proposal_POLRound != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_POLRound_serial}
		}
		ka.s += fieldBit__Proposal_POLRound
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "BlockID":
		if ka.s&fieldBit__Proposal_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_BlockID_serial}
		}
		ka.s += fieldBit__Proposal_BlockID
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "Timestamp":
		if ka.s&fieldBit__Proposal_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Timestamp_serial}
		}
		ka.s += fieldBit__Proposal_Timestamp
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "Signature":
		if ka.s&fieldBit__Proposal_Signature != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Proposal_Signature_serial}
		}
		ka.s += fieldBit__Proposal_Signature
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Proposal.Repr", Key: &_String{k}}
}
func (_Proposal__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Proposal__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Proposal.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Proposal__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Proposal__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n PubKey) Bytes() []byte {
	return n.x
}
func (_PubKey__Prototype) FromBytes(v []byte) (PubKey, error) {
	n := _PubKey{v}
	return &n, nil
}

type _PubKey__Maybe struct {
	m schema.Maybe
	v PubKey
}
type MaybePubKey = *_PubKey__Maybe

func (m MaybePubKey) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePubKey) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePubKey) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePubKey) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybePubKey) Must() PubKey {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (PubKey)(&_PubKey{})
var _ schema.TypedNode = (PubKey)(&_PubKey{})

func (PubKey) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (PubKey) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.LookupByString("")
}
func (PubKey) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.LookupByNode(nil)
}
func (PubKey) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.LookupByIndex(0)
}
func (PubKey) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.LookupBySegment(seg)
}
func (PubKey) MapIterator() ipld.MapIterator {
	return nil
}
func (PubKey) ListIterator() ipld.ListIterator {
	return nil
}
func (PubKey) Length() int64 {
	return -1
}
func (PubKey) IsAbsent() bool {
	return false
}
func (PubKey) IsNull() bool {
	return false
}
func (PubKey) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.AsBool()
}
func (PubKey) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.AsInt()
}
func (PubKey) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.AsFloat()
}
func (PubKey) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.AsString()
}
func (n PubKey) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (PubKey) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.PubKey"}.AsLink()
}
func (PubKey) Prototype() ipld.NodePrototype {
	return _PubKey__Prototype{}
}

type _PubKey__Prototype struct{}

func (_PubKey__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _PubKey__Builder
	nb.Reset()
	return &nb
}

type _PubKey__Builder struct {
	_PubKey__Assembler
}

func (nb *_PubKey__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PubKey__Builder) Reset() {
	var w _PubKey
	var m schema.Maybe
	*nb = _PubKey__Builder{_PubKey__Assembler{w: &w, m: &m}}
}

type _PubKey__Assembler struct {
	w *_PubKey
	m *schema.Maybe
}

func (na *_PubKey__Assembler) reset() {}
func (_PubKey__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.BeginMap(0)
}
func (_PubKey__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.BeginList(0)
}
func (na *_PubKey__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_PubKey__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignBool(false)
}
func (_PubKey__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignInt(0)
}
func (_PubKey__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignFloat(0)
}
func (_PubKey__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignString("")
}
func (na *_PubKey__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_PubKey{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_PubKey__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.PubKey"}.AssignLink(nil)
}
func (na *_PubKey__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PubKey); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_PubKey__Assembler) Prototype() ipld.NodePrototype {
	return _PubKey__Prototype{}
}
func (PubKey) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n PubKey) Representation() ipld.Node {
	return (*_PubKey__Repr)(n)
}

type _PubKey__Repr = _PubKey

var _ ipld.Node = &_PubKey__Repr{}

type _PubKey__ReprPrototype = _PubKey__Prototype
type _PubKey__ReprAssembler = _PubKey__Assembler

func (n *_PubKeyTypes) Lookup(idx int64) String {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_PubKeyTypes) LookupMaybe(idx int64) MaybeString {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_String__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _PubKeyTypes__valueAbsent = _String__Maybe{m: schema.Maybe_Absent}

func (n PubKeyTypes) Iterator() *PubKeyTypes__Itr {
	return &PubKeyTypes__Itr{n, 0}
}

type PubKeyTypes__Itr struct {
	n   PubKeyTypes
	idx int
}

func (itr *PubKeyTypes__Itr) Next() (idx int64, v String) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *PubKeyTypes__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _PubKeyTypes__Maybe struct {
	m schema.Maybe
	v PubKeyTypes
}
type MaybePubKeyTypes = *_PubKeyTypes__Maybe

func (m MaybePubKeyTypes) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePubKeyTypes) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePubKeyTypes) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePubKeyTypes) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybePubKeyTypes) Must() PubKeyTypes {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (PubKeyTypes)(&_PubKeyTypes{})
var _ schema.TypedNode = (PubKeyTypes)(&_PubKeyTypes{})

func (PubKeyTypes) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (PubKeyTypes) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.PubKeyTypes"}.LookupByString("")
}
func (n PubKeyTypes) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n PubKeyTypes) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n PubKeyTypes) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.PubKeyTypes", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (PubKeyTypes) MapIterator() ipld.MapIterator {
	return nil
}
func (n PubKeyTypes) ListIterator() ipld.ListIterator {
	return &_PubKeyTypes__ListItr{n, 0}
}

type _PubKeyTypes__ListItr struct {
	n   PubKeyTypes
	idx int
}

func (itr *_PubKeyTypes__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_PubKeyTypes__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n PubKeyTypes) Length() int64 {
	return int64(len(n.x))
}
func (PubKeyTypes) IsAbsent() bool {
	return false
}
func (PubKeyTypes) IsNull() bool {
	return false
}
func (PubKeyTypes) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.PubKeyTypes"}.AsBool()
}
func (PubKeyTypes) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.PubKeyTypes"}.AsInt()
}
func (PubKeyTypes) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.PubKeyTypes"}.AsFloat()
}
func (PubKeyTypes) AsString() (string, error) {
	return mixins.List{"dagcosmos.PubKeyTypes"}.AsString()
}
func (PubKeyTypes) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.PubKeyTypes"}.AsBytes()
}
func (PubKeyTypes) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.PubKeyTypes"}.AsLink()
}
func (PubKeyTypes) Prototype() ipld.NodePrototype {
	return _PubKeyTypes__Prototype{}
}

type _PubKeyTypes__Prototype struct{}

func (_PubKeyTypes__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _PubKeyTypes__Builder
	nb.Reset()
	return &nb
}

type _PubKeyTypes__Builder struct {
	_PubKeyTypes__Assembler
}

func (nb *_PubKeyTypes__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PubKeyTypes__Builder) Reset() {
	var w _PubKeyTypes
	var m schema.Maybe
	*nb = _PubKeyTypes__Builder{_PubKeyTypes__Assembler{w: &w, m: &m}}
}

type _PubKeyTypes__Assembler struct {
	w     *_PubKeyTypes
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _String__Assembler
}

func (na *_PubKeyTypes__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_PubKeyTypes__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes"}.BeginMap(0)
}
func (na *_PubKeyTypes__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_PubKeyTypes{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_String, 0, sizeHint)
	}
	return na, nil
}
func (na *_PubKeyTypes__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.PubKeyTypes"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PubKeyTypes__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes"}.AssignBool(false)
}
func (_PubKeyTypes__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes"}.AssignInt(0)
}
func (_PubKeyTypes__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes"}.AssignFloat(0)
}
func (_PubKeyTypes__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes"}.AssignString("")
}
func (_PubKeyTypes__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes"}.AssignBytes(nil)
}
func (_PubKeyTypes__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes"}.AssignLink(nil)
}
func (na *_PubKeyTypes__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PubKeyTypes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.PubKeyTypes", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PubKeyTypes__Assembler) Prototype() ipld.NodePrototype {
	return _PubKeyTypes__Prototype{}
}
func (la *_PubKeyTypes__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_PubKeyTypes__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _String{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_PubKeyTypes__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_PubKeyTypes__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _String__Prototype{}
}
func (PubKeyTypes) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n PubKeyTypes) Representation() ipld.Node {
	return (*_PubKeyTypes__Repr)(n)
}

type _PubKeyTypes__Repr _PubKeyTypes

var _ ipld.Node = &_PubKeyTypes__Repr{}

func (_PubKeyTypes__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_PubKeyTypes__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.PubKeyTypes.Repr"}.LookupByString("")
}
func (nr *_PubKeyTypes__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (PubKeyTypes)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(String).Representation(), nil
}
func (nr *_PubKeyTypes__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (PubKeyTypes)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(String).Representation(), nil
}
func (n _PubKeyTypes__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.PubKeyTypes.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_PubKeyTypes__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_PubKeyTypes__Repr) ListIterator() ipld.ListIterator {
	return &_PubKeyTypes__ReprListItr{(PubKeyTypes)(nr), 0}
}

type _PubKeyTypes__ReprListItr _PubKeyTypes__ListItr

func (itr *_PubKeyTypes__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_PubKeyTypes__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(String).Representation(), nil
}
func (itr *_PubKeyTypes__ReprListItr) Done() bool {
	return (*_PubKeyTypes__ListItr)(itr).Done()
}

func (rn *_PubKeyTypes__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_PubKeyTypes__Repr) IsAbsent() bool {
	return false
}
func (_PubKeyTypes__Repr) IsNull() bool {
	return false
}
func (_PubKeyTypes__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.PubKeyTypes.Repr"}.AsBool()
}
func (_PubKeyTypes__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.PubKeyTypes.Repr"}.AsInt()
}
func (_PubKeyTypes__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.PubKeyTypes.Repr"}.AsFloat()
}
func (_PubKeyTypes__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.PubKeyTypes.Repr"}.AsString()
}
func (_PubKeyTypes__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.PubKeyTypes.Repr"}.AsBytes()
}
func (_PubKeyTypes__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.PubKeyTypes.Repr"}.AsLink()
}
func (_PubKeyTypes__Repr) Prototype() ipld.NodePrototype {
	return _PubKeyTypes__ReprPrototype{}
}

type _PubKeyTypes__ReprPrototype struct{}

func (_PubKeyTypes__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _PubKeyTypes__ReprBuilder
	nb.Reset()
	return &nb
}

type _PubKeyTypes__ReprBuilder struct {
	_PubKeyTypes__ReprAssembler
}

func (nb *_PubKeyTypes__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PubKeyTypes__ReprBuilder) Reset() {
	var w _PubKeyTypes
	var m schema.Maybe
	*nb = _PubKeyTypes__ReprBuilder{_PubKeyTypes__ReprAssembler{w: &w, m: &m}}
}

type _PubKeyTypes__ReprAssembler struct {
	w     *_PubKeyTypes
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _String__ReprAssembler
}

func (na *_PubKeyTypes__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_PubKeyTypes__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes.Repr"}.BeginMap(0)
}
func (na *_PubKeyTypes__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_PubKeyTypes{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_String, 0, sizeHint)
	}
	return na, nil
}
func (na *_PubKeyTypes__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.PubKeyTypes.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PubKeyTypes__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes.Repr"}.AssignBool(false)
}
func (_PubKeyTypes__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes.Repr"}.AssignInt(0)
}
func (_PubKeyTypes__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes.Repr"}.AssignFloat(0)
}
func (_PubKeyTypes__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes.Repr"}.AssignString("")
}
func (_PubKeyTypes__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes.Repr"}.AssignBytes(nil)
}
func (_PubKeyTypes__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.PubKeyTypes.Repr"}.AssignLink(nil)
}
func (na *_PubKeyTypes__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PubKeyTypes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.PubKeyTypes.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PubKeyTypes__ReprAssembler) Prototype() ipld.NodePrototype {
	return _PubKeyTypes__ReprPrototype{}
}
func (la *_PubKeyTypes__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_PubKeyTypes__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _String{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_PubKeyTypes__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_PubKeyTypes__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _String__ReprPrototype{}
}

func (n Signature) Bytes() []byte {
	return n.x
}
func (_Signature__Prototype) FromBytes(v []byte) (Signature, error) {
	n := _Signature{v}
	return &n, nil
}

type _Signature__Maybe struct {
	m schema.Maybe
	v Signature
}
type MaybeSignature = *_Signature__Maybe

func (m MaybeSignature) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSignature) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSignature) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSignature) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSignature) Must() Signature {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Signature)(&_Signature{})
var _ schema.TypedNode = (Signature)(&_Signature{})

func (Signature) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Signature) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.LookupByString("")
}
func (Signature) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.LookupByNode(nil)
}
func (Signature) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.LookupByIndex(0)
}
func (Signature) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.LookupBySegment(seg)
}
func (Signature) MapIterator() ipld.MapIterator {
	return nil
}
func (Signature) ListIterator() ipld.ListIterator {
	return nil
}
func (Signature) Length() int64 {
	return -1
}
func (Signature) IsAbsent() bool {
	return false
}
func (Signature) IsNull() bool {
	return false
}
func (Signature) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.AsBool()
}
func (Signature) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.AsInt()
}
func (Signature) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.AsFloat()
}
func (Signature) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.AsString()
}
func (n Signature) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Signature) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Signature"}.AsLink()
}
func (Signature) Prototype() ipld.NodePrototype {
	return _Signature__Prototype{}
}

type _Signature__Prototype struct{}

func (_Signature__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Signature__Builder
	nb.Reset()
	return &nb
}

type _Signature__Builder struct {
	_Signature__Assembler
}

func (nb *_Signature__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Signature__Builder) Reset() {
	var w _Signature
	var m schema.Maybe
	*nb = _Signature__Builder{_Signature__Assembler{w: &w, m: &m}}
}

type _Signature__Assembler struct {
	w *_Signature
	m *schema.Maybe
}

func (na *_Signature__Assembler) reset() {}
func (_Signature__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.BeginMap(0)
}
func (_Signature__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.BeginList(0)
}
func (na *_Signature__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Signature__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignBool(false)
}
func (_Signature__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignInt(0)
}
func (_Signature__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignFloat(0)
}
func (_Signature__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignString("")
}
func (na *_Signature__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Signature{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Signature__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Signature"}.AssignLink(nil)
}
func (na *_Signature__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Signature); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Signature__Assembler) Prototype() ipld.NodePrototype {
	return _Signature__Prototype{}
}
func (Signature) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Signature) Representation() ipld.Node {
	return (*_Signature__Repr)(n)
}

type _Signature__Repr = _Signature

var _ ipld.Node = &_Signature__Repr{}

type _Signature__ReprPrototype = _Signature__Prototype
type _Signature__ReprAssembler = _Signature__Assembler

func (n *_Signatures) Lookup(idx int64) CommitSig {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Signatures) LookupMaybe(idx int64) MaybeCommitSig {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_CommitSig__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Signatures__valueAbsent = _CommitSig__Maybe{m: schema.Maybe_Absent}

func (n Signatures) Iterator() *Signatures__Itr {
	return &Signatures__Itr{n, 0}
}

type Signatures__Itr struct {
	n   Signatures
	idx int
}

func (itr *Signatures__Itr) Next() (idx int64, v CommitSig) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Signatures__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Signatures__Maybe struct {
	m schema.Maybe
	v Signatures
}
type MaybeSignatures = *_Signatures__Maybe

func (m MaybeSignatures) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSignatures) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSignatures) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSignatures) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSignatures) Must() Signatures {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Signatures)(&_Signatures{})
var _ schema.TypedNode = (Signatures)(&_Signatures{})

func (Signatures) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Signatures) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Signatures"}.LookupByString("")
}
func (n Signatures) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Signatures) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Signatures) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Signatures", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Signatures) MapIterator() ipld.MapIterator {
	return nil
}
func (n Signatures) ListIterator() ipld.ListIterator {
	return &_Signatures__ListItr{n, 0}
}

type _Signatures__ListItr struct {
	n   Signatures
	idx int
}

func (itr *_Signatures__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Signatures__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Signatures) Length() int64 {
	return int64(len(n.x))
}
func (Signatures) IsAbsent() bool {
	return false
}
func (Signatures) IsNull() bool {
	return false
}
func (Signatures) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsBool()
}
func (Signatures) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsInt()
}
func (Signatures) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsFloat()
}
func (Signatures) AsString() (string, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsString()
}
func (Signatures) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsBytes()
}
func (Signatures) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Signatures"}.AsLink()
}
func (Signatures) Prototype() ipld.NodePrototype {
	return _Signatures__Prototype{}
}

type _Signatures__Prototype struct{}

func (_Signatures__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Signatures__Builder
	nb.Reset()
	return &nb
}

type _Signatures__Builder struct {
	_Signatures__Assembler
}

func (nb *_Signatures__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Signatures__Builder) Reset() {
	var w _Signatures
	var m schema.Maybe
	*nb = _Signatures__Builder{_Signatures__Assembler{w: &w, m: &m}}
}

type _Signatures__Assembler struct {
	w     *_Signatures
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _CommitSig__Assembler
}

func (na *_Signatures__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Signatures__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.BeginMap(0)
}
func (na *_Signatures__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Signatures{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_CommitSig, 0, sizeHint)
	}
	return na, nil
}
func (na *_Signatures__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Signatures__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignBool(false)
}
func (_Signatures__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignInt(0)
}
func (_Signatures__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignFloat(0)
}
func (_Signatures__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignString("")
}
func (_Signatures__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignBytes(nil)
}
func (_Signatures__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Signatures"}.AssignLink(nil)
}
func (na *_Signatures__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Signatures); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Signatures", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Signatures__Assembler) Prototype() ipld.NodePrototype {
	return _Signatures__Prototype{}
}
func (la *_Signatures__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Signatures__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _CommitSig{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Signatures__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Signatures__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _CommitSig__Prototype{}
}
func (Signatures) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Signatures) Representation() ipld.Node {
	return (*_Signatures__Repr)(n)
}

type _Signatures__Repr _Signatures

var _ ipld.Node = &_Signatures__Repr{}

func (_Signatures__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Signatures__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.LookupByString("")
}
func (nr *_Signatures__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Signatures)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(CommitSig).Representation(), nil
}
func (nr *_Signatures__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Signatures)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(CommitSig).Representation(), nil
}
func (n _Signatures__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Signatures.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Signatures__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Signatures__Repr) ListIterator() ipld.ListIterator {
	return &_Signatures__ReprListItr{(Signatures)(nr), 0}
}

type _Signatures__ReprListItr _Signatures__ListItr

func (itr *_Signatures__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Signatures__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(CommitSig).Representation(), nil
}
func (itr *_Signatures__ReprListItr) Done() bool {
	return (*_Signatures__ListItr)(itr).Done()
}

func (rn *_Signatures__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Signatures__Repr) IsAbsent() bool {
	return false
}
func (_Signatures__Repr) IsNull() bool {
	return false
}
func (_Signatures__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsBool()
}
func (_Signatures__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsInt()
}
func (_Signatures__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsFloat()
}
func (_Signatures__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsString()
}
func (_Signatures__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsBytes()
}
func (_Signatures__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Signatures.Repr"}.AsLink()
}
func (_Signatures__Repr) Prototype() ipld.NodePrototype {
	return _Signatures__ReprPrototype{}
}

type _Signatures__ReprPrototype struct{}

func (_Signatures__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Signatures__ReprBuilder
	nb.Reset()
	return &nb
}

type _Signatures__ReprBuilder struct {
	_Signatures__ReprAssembler
}

func (nb *_Signatures__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Signatures__ReprBuilder) Reset() {
	var w _Signatures
	var m schema.Maybe
	*nb = _Signatures__ReprBuilder{_Signatures__ReprAssembler{w: &w, m: &m}}
}

type _Signatures__ReprAssembler struct {
	w     *_Signatures
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _CommitSig__ReprAssembler
}

func (na *_Signatures__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Signatures__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.BeginMap(0)
}
func (na *_Signatures__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Signatures{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_CommitSig, 0, sizeHint)
	}
	return na, nil
}
func (na *_Signatures__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Signatures.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Signatures__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignBool(false)
}
func (_Signatures__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignInt(0)
}
func (_Signatures__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignFloat(0)
}
func (_Signatures__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignString("")
}
func (_Signatures__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignBytes(nil)
}
func (_Signatures__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Signatures.Repr"}.AssignLink(nil)
}
func (na *_Signatures__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Signatures); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Signatures.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Signatures__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Signatures__ReprPrototype{}
}
func (la *_Signatures__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Signatures__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _CommitSig{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Signatures__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Signatures__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _CommitSig__ReprPrototype{}
}

func (n _SignedHeader) FieldHeader() Header {
	return &n.Header
}
func (n _SignedHeader) FieldCommit() Commit {
	return &n.Commit
}

type _SignedHeader__Maybe struct {
	m schema.Maybe
	v SignedHeader
}
type MaybeSignedHeader = *_SignedHeader__Maybe

func (m MaybeSignedHeader) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSignedHeader) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSignedHeader) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSignedHeader) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSignedHeader) Must() SignedHeader {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__SignedHeader_Header = _String{"Header"}
	fieldName__SignedHeader_Commit = _String{"Commit"}
)
var _ ipld.Node = (SignedHeader)(&_SignedHeader{})
var _ schema.TypedNode = (SignedHeader)(&_SignedHeader{})

func (SignedHeader) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n SignedHeader) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Header":
		return &n.Header, nil
	case "Commit":
		return &n.Commit, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n SignedHeader) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (SignedHeader) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.LookupByIndex(0)
}
func (n SignedHeader) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n SignedHeader) MapIterator() ipld.MapIterator {
	return &_SignedHeader__MapItr{n, 0}
}

type _SignedHeader__MapItr struct {
	n   SignedHeader
	idx int
}

func (itr *_SignedHeader__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SignedHeader_Header
		v = &itr.n.Header
	case 1:
		k = &fieldName__SignedHeader_Commit
		v = &itr.n.Commit
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SignedHeader__MapItr) Done() bool {
	return itr.idx >= 2
}

func (SignedHeader) ListIterator() ipld.ListIterator {
	return nil
}
func (SignedHeader) Length() int64 {
	return 2
}
func (SignedHeader) IsAbsent() bool {
	return false
}
func (SignedHeader) IsNull() bool {
	return false
}
func (SignedHeader) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsBool()
}
func (SignedHeader) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsInt()
}
func (SignedHeader) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsFloat()
}
func (SignedHeader) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsString()
}
func (SignedHeader) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsBytes()
}
func (SignedHeader) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SignedHeader"}.AsLink()
}
func (SignedHeader) Prototype() ipld.NodePrototype {
	return _SignedHeader__Prototype{}
}

type _SignedHeader__Prototype struct{}

func (_SignedHeader__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _SignedHeader__Builder
	nb.Reset()
	return &nb
}

type _SignedHeader__Builder struct {
	_SignedHeader__Assembler
}

func (nb *_SignedHeader__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SignedHeader__Builder) Reset() {
	var w _SignedHeader
	var m schema.Maybe
	*nb = _SignedHeader__Builder{_SignedHeader__Assembler{w: &w, m: &m}}
}

type _SignedHeader__Assembler struct {
	w     *_SignedHeader
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm        schema.Maybe
	ca_Header _Header__Assembler
	ca_Commit _Commit__Assembler
}

func (na *_SignedHeader__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Header.reset()
	na.ca_Commit.reset()
}

var (
	fieldBit__SignedHeader_Header      = 1 << 0
	fieldBit__SignedHeader_Commit      = 1 << 1
	fieldBits__SignedHeader_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_SignedHeader__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SignedHeader{}
	}
	return na, nil
}
func (_SignedHeader__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.BeginList(0)
}
func (na *_SignedHeader__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SignedHeader__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignBool(false)
}
func (_SignedHeader__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignInt(0)
}
func (_SignedHeader__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignFloat(0)
}
func (_SignedHeader__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignString("")
}
func (_SignedHeader__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignBytes(nil)
}
func (_SignedHeader__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader"}.AssignLink(nil)
}
func (na *_SignedHeader__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SignedHeader); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SignedHeader", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SignedHeader__Assembler) Prototype() ipld.NodePrototype {
	return _SignedHeader__Prototype{}
}
func (ma *_SignedHeader__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Header.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Commit.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SignedHeader__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Header":
		if ma.s&fieldBit__SignedHeader_Header != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Header}
		}
		ma.s += fieldBit__SignedHeader_Header
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header, nil
	case "Commit":
		if ma.s&fieldBit__SignedHeader_Commit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Commit}
		}
		ma.s += fieldBit__SignedHeader_Commit
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Commit.w = &ma.w.Commit
		ma.ca_Commit.m = &ma.cm
		return &ma.ca_Commit, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SignedHeader", Key: &_String{k}}
}
func (ma *_SignedHeader__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SignedHeader__KeyAssembler)(ma)
}
func (ma *_SignedHeader__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header
	case 1:
		ma.ca_Commit.w = &ma.w.Commit
		ma.ca_Commit.m = &ma.cm
		return &ma.ca_Commit
	default:
		panic("unreachable")
	}
}
func (ma *_SignedHeader__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SignedHeader_sufficient != fieldBits__SignedHeader_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__SignedHeader_Header == 0 {
			err.Missing = append(err.Missing, "Header")
		}
		if ma.s&fieldBit__SignedHeader_Commit == 0 {
			err.Missing = append(err.Missing, "Commit")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SignedHeader__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SignedHeader__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _SignedHeader__KeyAssembler _SignedHeader__Assembler

func (_SignedHeader__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.BeginMap(0)
}
func (_SignedHeader__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.BeginList(0)
}
func (na *_SignedHeader__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignNull()
}
func (_SignedHeader__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignBool(false)
}
func (_SignedHeader__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignInt(0)
}
func (_SignedHeader__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SignedHeader__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Header":
		if ka.s&fieldBit__SignedHeader_Header != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Header}
		}
		ka.s += fieldBit__SignedHeader_Header
		ka.state = maState_expectValue
		ka.f = 0
	case "Commit":
		if ka.s&fieldBit__SignedHeader_Commit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Commit}
		}
		ka.s += fieldBit__SignedHeader_Commit
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.SignedHeader", Key: &_String{k}}
	}
	return nil
}
func (_SignedHeader__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignBytes(nil)
}
func (_SignedHeader__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SignedHeader__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SignedHeader__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (SignedHeader) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n SignedHeader) Representation() ipld.Node {
	return (*_SignedHeader__Repr)(n)
}

type _SignedHeader__Repr _SignedHeader

var (
	fieldName__SignedHeader_Header_serial = _String{"Header"}
	fieldName__SignedHeader_Commit_serial = _String{"Commit"}
)
var _ ipld.Node = &_SignedHeader__Repr{}

func (_SignedHeader__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_SignedHeader__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Header":
		return n.Header.Representation(), nil
	case "Commit":
		return n.Commit.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_SignedHeader__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_SignedHeader__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.LookupByIndex(0)
}
func (n _SignedHeader__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_SignedHeader__Repr) MapIterator() ipld.MapIterator {
	return &_SignedHeader__ReprMapItr{n, 0}
}

type _SignedHeader__ReprMapItr struct {
	n   *_SignedHeader__Repr
	idx int
}

func (itr *_SignedHeader__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SignedHeader_Header_serial
		v = itr.n.Header.Representation()
	case 1:
		k = &fieldName__SignedHeader_Commit_serial
		v = itr.n.Commit.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SignedHeader__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_SignedHeader__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_SignedHeader__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_SignedHeader__Repr) IsAbsent() bool {
	return false
}
func (_SignedHeader__Repr) IsNull() bool {
	return false
}
func (_SignedHeader__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsBool()
}
func (_SignedHeader__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsInt()
}
func (_SignedHeader__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsFloat()
}
func (_SignedHeader__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsString()
}
func (_SignedHeader__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsBytes()
}
func (_SignedHeader__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SignedHeader.Repr"}.AsLink()
}
func (_SignedHeader__Repr) Prototype() ipld.NodePrototype {
	return _SignedHeader__ReprPrototype{}
}

type _SignedHeader__ReprPrototype struct{}

func (_SignedHeader__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _SignedHeader__ReprBuilder
	nb.Reset()
	return &nb
}

type _SignedHeader__ReprBuilder struct {
	_SignedHeader__ReprAssembler
}

func (nb *_SignedHeader__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SignedHeader__ReprBuilder) Reset() {
	var w _SignedHeader
	var m schema.Maybe
	*nb = _SignedHeader__ReprBuilder{_SignedHeader__ReprAssembler{w: &w, m: &m}}
}

type _SignedHeader__ReprAssembler struct {
	w     *_SignedHeader
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm        schema.Maybe
	ca_Header _Header__ReprAssembler
	ca_Commit _Commit__ReprAssembler
}

func (na *_SignedHeader__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Header.reset()
	na.ca_Commit.reset()
}
func (na *_SignedHeader__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SignedHeader{}
	}
	return na, nil
}
func (_SignedHeader__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.BeginList(0)
}
func (na *_SignedHeader__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SignedHeader__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignBool(false)
}
func (_SignedHeader__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignInt(0)
}
func (_SignedHeader__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignFloat(0)
}
func (_SignedHeader__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignString("")
}
func (_SignedHeader__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignBytes(nil)
}
func (_SignedHeader__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SignedHeader.Repr"}.AssignLink(nil)
}
func (na *_SignedHeader__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SignedHeader); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SignedHeader.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SignedHeader__ReprAssembler) Prototype() ipld.NodePrototype {
	return _SignedHeader__ReprPrototype{}
}
func (ma *_SignedHeader__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SignedHeader__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Header":
		if ma.s&fieldBit__SignedHeader_Header != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Header_serial}
		}
		ma.s += fieldBit__SignedHeader_Header
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header, nil
	case "Commit":
		if ma.s&fieldBit__SignedHeader_Commit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Commit_serial}
		}
		ma.s += fieldBit__SignedHeader_Commit
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Commit.w = &ma.w.Commit
		ma.ca_Commit.m = &ma.cm
		return &ma.ca_Commit, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SignedHeader.Repr", Key: &_String{k}}
}
func (ma *_SignedHeader__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SignedHeader__ReprKeyAssembler)(ma)
}
func (ma *_SignedHeader__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header
	case 1:
		ma.ca_Commit.w = &ma.w.Commit
		ma.ca_Commit.m = &ma.cm
		return &ma.ca_Commit
	default:
		panic("unreachable")
	}
}
func (ma *_SignedHeader__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SignedHeader_sufficient != fieldBits__SignedHeader_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__SignedHeader_Header == 0 {
			err.Missing = append(err.Missing, "Header")
		}
		if ma.s&fieldBit__SignedHeader_Commit == 0 {
			err.Missing = append(err.Missing, "Commit")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SignedHeader__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SignedHeader__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _SignedHeader__ReprKeyAssembler _SignedHeader__ReprAssembler

func (_SignedHeader__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.BeginMap(0)
}
func (_SignedHeader__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_SignedHeader__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignNull()
}
func (_SignedHeader__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignBool(false)
}
func (_SignedHeader__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignInt(0)
}
func (_SignedHeader__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SignedHeader__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Header":
		if ka.s&fieldBit__SignedHeader_Header != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Header_serial}
		}
		ka.s += fieldBit__SignedHeader_Header
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Commit":
		if ka.s&fieldBit__SignedHeader_Commit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SignedHeader_Commit_serial}
		}
		ka.s += fieldBit__SignedHeader_Commit
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.SignedHeader.Repr", Key: &_String{k}}
}
func (_SignedHeader__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_SignedHeader__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SignedHeader.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SignedHeader__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SignedHeader__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n SignedMsgType) Int() int64 {
	return n.x
}
func (_SignedMsgType__Prototype) FromInt(v int64) (SignedMsgType, error) {
	n := _SignedMsgType{v}
	return &n, nil
}

type _SignedMsgType__Maybe struct {
	m schema.Maybe
	v SignedMsgType
}
type MaybeSignedMsgType = *_SignedMsgType__Maybe

func (m MaybeSignedMsgType) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSignedMsgType) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSignedMsgType) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSignedMsgType) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSignedMsgType) Must() SignedMsgType {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (SignedMsgType)(&_SignedMsgType{})
var _ schema.TypedNode = (SignedMsgType)(&_SignedMsgType{})

func (SignedMsgType) Kind() ipld.Kind {
	return ipld.Kind_Int
}
func (SignedMsgType) LookupByString(string) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.LookupByString("")
}
func (SignedMsgType) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.LookupByNode(nil)
}
func (SignedMsgType) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.LookupByIndex(0)
}
func (SignedMsgType) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.LookupBySegment(seg)
}
func (SignedMsgType) MapIterator() ipld.MapIterator {
	return nil
}
func (SignedMsgType) ListIterator() ipld.ListIterator {
	return nil
}
func (SignedMsgType) Length() int64 {
	return -1
}
func (SignedMsgType) IsAbsent() bool {
	return false
}
func (SignedMsgType) IsNull() bool {
	return false
}
func (SignedMsgType) AsBool() (bool, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.AsBool()
}
func (n SignedMsgType) AsInt() (int64, error) {
	return n.x, nil
}
func (SignedMsgType) AsFloat() (float64, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.AsFloat()
}
func (SignedMsgType) AsString() (string, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.AsString()
}
func (SignedMsgType) AsBytes() ([]byte, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.AsBytes()
}
func (SignedMsgType) AsLink() (ipld.Link, error) {
	return mixins.Int{"dagcosmos.SignedMsgType"}.AsLink()
}
func (SignedMsgType) Prototype() ipld.NodePrototype {
	return _SignedMsgType__Prototype{}
}

type _SignedMsgType__Prototype struct{}

func (_SignedMsgType__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _SignedMsgType__Builder
	nb.Reset()
	return &nb
}

type _SignedMsgType__Builder struct {
	_SignedMsgType__Assembler
}

func (nb *_SignedMsgType__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SignedMsgType__Builder) Reset() {
	var w _SignedMsgType
	var m schema.Maybe
	*nb = _SignedMsgType__Builder{_SignedMsgType__Assembler{w: &w, m: &m}}
}

type _SignedMsgType__Assembler struct {
	w *_SignedMsgType
	m *schema.Maybe
}

func (na *_SignedMsgType__Assembler) reset() {}
func (_SignedMsgType__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.BeginMap(0)
}
func (_SignedMsgType__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.BeginList(0)
}
func (na *_SignedMsgType__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_SignedMsgType__Assembler) AssignBool(bool) error {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignBool(false)
}
func (na *_SignedMsgType__Assembler) AssignInt(v int64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_SignedMsgType{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_SignedMsgType__Assembler) AssignFloat(float64) error {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignFloat(0)
}
func (_SignedMsgType__Assembler) AssignString(string) error {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignString("")
}
func (_SignedMsgType__Assembler) AssignBytes([]byte) error {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignBytes(nil)
}
func (_SignedMsgType__Assembler) AssignLink(ipld.Link) error {
	return mixins.IntAssembler{"dagcosmos.SignedMsgType"}.AssignLink(nil)
}
func (na *_SignedMsgType__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SignedMsgType); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsInt(); err != nil {
		return err
	} else {
		return na.AssignInt(v2)
	}
}
func (_SignedMsgType__Assembler) Prototype() ipld.NodePrototype {
	return _SignedMsgType__Prototype{}
}
func (SignedMsgType) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n SignedMsgType) Representation() ipld.Node {
	return (*_SignedMsgType__Repr)(n)
}

type _SignedMsgType__Repr = _SignedMsgType

var _ ipld.Node = &_SignedMsgType__Repr{}

type _SignedMsgType__ReprPrototype = _SignedMsgType__Prototype
type _SignedMsgType__ReprAssembler = _SignedMsgType__Assembler

func (n _SimpleValidator) FieldPubKey() PubKey {
	return &n.PubKey
}
func (n _SimpleValidator) FieldVotingPower() Int {
	return &n.VotingPower
}

type _SimpleValidator__Maybe struct {
	m schema.Maybe
	v SimpleValidator
}
type MaybeSimpleValidator = *_SimpleValidator__Maybe

func (m MaybeSimpleValidator) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeSimpleValidator) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeSimpleValidator) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeSimpleValidator) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeSimpleValidator) Must() SimpleValidator {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__SimpleValidator_PubKey      = _String{"PubKey"}
	fieldName__SimpleValidator_VotingPower = _String{"VotingPower"}
)
var _ ipld.Node = (SimpleValidator)(&_SimpleValidator{})
var _ schema.TypedNode = (SimpleValidator)(&_SimpleValidator{})

func (SimpleValidator) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n SimpleValidator) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PubKey":
		return &n.PubKey, nil
	case "VotingPower":
		return &n.VotingPower, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n SimpleValidator) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (SimpleValidator) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.LookupByIndex(0)
}
func (n SimpleValidator) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n SimpleValidator) MapIterator() ipld.MapIterator {
	return &_SimpleValidator__MapItr{n, 0}
}

type _SimpleValidator__MapItr struct {
	n   SimpleValidator
	idx int
}

func (itr *_SimpleValidator__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SimpleValidator_PubKey
		v = &itr.n.PubKey
	case 1:
		k = &fieldName__SimpleValidator_VotingPower
		v = &itr.n.VotingPower
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SimpleValidator__MapItr) Done() bool {
	return itr.idx >= 2
}

func (SimpleValidator) ListIterator() ipld.ListIterator {
	return nil
}
func (SimpleValidator) Length() int64 {
	return 2
}
func (SimpleValidator) IsAbsent() bool {
	return false
}
func (SimpleValidator) IsNull() bool {
	return false
}
func (SimpleValidator) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsBool()
}
func (SimpleValidator) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsInt()
}
func (SimpleValidator) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsFloat()
}
func (SimpleValidator) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsString()
}
func (SimpleValidator) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsBytes()
}
func (SimpleValidator) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SimpleValidator"}.AsLink()
}
func (SimpleValidator) Prototype() ipld.NodePrototype {
	return _SimpleValidator__Prototype{}
}

type _SimpleValidator__Prototype struct{}

func (_SimpleValidator__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _SimpleValidator__Builder
	nb.Reset()
	return &nb
}

type _SimpleValidator__Builder struct {
	_SimpleValidator__Assembler
}

func (nb *_SimpleValidator__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SimpleValidator__Builder) Reset() {
	var w _SimpleValidator
	var m schema.Maybe
	*nb = _SimpleValidator__Builder{_SimpleValidator__Assembler{w: &w, m: &m}}
}

type _SimpleValidator__Assembler struct {
	w     *_SimpleValidator
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PubKey      _PubKey__Assembler
	ca_VotingPower _Int__Assembler
}

func (na *_SimpleValidator__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PubKey.reset()
	na.ca_VotingPower.reset()
}

var (
	fieldBit__SimpleValidator_PubKey      = 1 << 0
	fieldBit__SimpleValidator_VotingPower = 1 << 1
	fieldBits__SimpleValidator_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_SimpleValidator__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SimpleValidator{}
	}
	return na, nil
}
func (_SimpleValidator__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.BeginList(0)
}
func (na *_SimpleValidator__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SimpleValidator__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignBool(false)
}
func (_SimpleValidator__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignInt(0)
}
func (_SimpleValidator__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignFloat(0)
}
func (_SimpleValidator__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignString("")
}
func (_SimpleValidator__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignBytes(nil)
}
func (_SimpleValidator__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator"}.AssignLink(nil)
}
func (na *_SimpleValidator__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SimpleValidator); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SimpleValidator", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SimpleValidator__Assembler) Prototype() ipld.NodePrototype {
	return _SimpleValidator__Prototype{}
}
func (ma *_SimpleValidator__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PubKey.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_VotingPower.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SimpleValidator__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PubKey":
		if ma.s&fieldBit__SimpleValidator_PubKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_PubKey}
		}
		ma.s += fieldBit__SimpleValidator_PubKey
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey, nil
	case "VotingPower":
		if ma.s&fieldBit__SimpleValidator_VotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_VotingPower}
		}
		ma.s += fieldBit__SimpleValidator_VotingPower
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SimpleValidator", Key: &_String{k}}
}
func (ma *_SimpleValidator__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SimpleValidator__KeyAssembler)(ma)
}
func (ma *_SimpleValidator__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey
	case 1:
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower
	default:
		panic("unreachable")
	}
}
func (ma *_SimpleValidator__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SimpleValidator_sufficient != fieldBits__SimpleValidator_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__SimpleValidator_PubKey == 0 {
			err.Missing = append(err.Missing, "PubKey")
		}
		if ma.s&fieldBit__SimpleValidator_VotingPower == 0 {
			err.Missing = append(err.Missing, "VotingPower")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SimpleValidator__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SimpleValidator__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _SimpleValidator__KeyAssembler _SimpleValidator__Assembler

func (_SimpleValidator__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.BeginMap(0)
}
func (_SimpleValidator__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.BeginList(0)
}
func (na *_SimpleValidator__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignNull()
}
func (_SimpleValidator__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignBool(false)
}
func (_SimpleValidator__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignInt(0)
}
func (_SimpleValidator__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SimpleValidator__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PubKey":
		if ka.s&fieldBit__SimpleValidator_PubKey != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_PubKey}
		}
		ka.s += fieldBit__SimpleValidator_PubKey
		ka.state = maState_expectValue
		ka.f = 0
	case "VotingPower":
		if ka.s&fieldBit__SimpleValidator_VotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_VotingPower}
		}
		ka.s += fieldBit__SimpleValidator_VotingPower
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.SimpleValidator", Key: &_String{k}}
	}
	return nil
}
func (_SimpleValidator__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignBytes(nil)
}
func (_SimpleValidator__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SimpleValidator__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SimpleValidator__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (SimpleValidator) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n SimpleValidator) Representation() ipld.Node {
	return (*_SimpleValidator__Repr)(n)
}

type _SimpleValidator__Repr _SimpleValidator

var (
	fieldName__SimpleValidator_PubKey_serial      = _String{"PubKey"}
	fieldName__SimpleValidator_VotingPower_serial = _String{"VotingPower"}
)
var _ ipld.Node = &_SimpleValidator__Repr{}

func (_SimpleValidator__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_SimpleValidator__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PubKey":
		return n.PubKey.Representation(), nil
	case "VotingPower":
		return n.VotingPower.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_SimpleValidator__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_SimpleValidator__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.LookupByIndex(0)
}
func (n _SimpleValidator__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_SimpleValidator__Repr) MapIterator() ipld.MapIterator {
	return &_SimpleValidator__ReprMapItr{n, 0}
}

type _SimpleValidator__ReprMapItr struct {
	n   *_SimpleValidator__Repr
	idx int
}

func (itr *_SimpleValidator__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__SimpleValidator_PubKey_serial
		v = itr.n.PubKey.Representation()
	case 1:
		k = &fieldName__SimpleValidator_VotingPower_serial
		v = itr.n.VotingPower.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_SimpleValidator__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_SimpleValidator__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_SimpleValidator__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_SimpleValidator__Repr) IsAbsent() bool {
	return false
}
func (_SimpleValidator__Repr) IsNull() bool {
	return false
}
func (_SimpleValidator__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsBool()
}
func (_SimpleValidator__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsInt()
}
func (_SimpleValidator__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsFloat()
}
func (_SimpleValidator__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsString()
}
func (_SimpleValidator__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsBytes()
}
func (_SimpleValidator__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.SimpleValidator.Repr"}.AsLink()
}
func (_SimpleValidator__Repr) Prototype() ipld.NodePrototype {
	return _SimpleValidator__ReprPrototype{}
}

type _SimpleValidator__ReprPrototype struct{}

func (_SimpleValidator__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _SimpleValidator__ReprBuilder
	nb.Reset()
	return &nb
}

type _SimpleValidator__ReprBuilder struct {
	_SimpleValidator__ReprAssembler
}

func (nb *_SimpleValidator__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_SimpleValidator__ReprBuilder) Reset() {
	var w _SimpleValidator
	var m schema.Maybe
	*nb = _SimpleValidator__ReprBuilder{_SimpleValidator__ReprAssembler{w: &w, m: &m}}
}

type _SimpleValidator__ReprAssembler struct {
	w     *_SimpleValidator
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PubKey      _PubKey__ReprAssembler
	ca_VotingPower _Int__ReprAssembler
}

func (na *_SimpleValidator__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PubKey.reset()
	na.ca_VotingPower.reset()
}
func (na *_SimpleValidator__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_SimpleValidator{}
	}
	return na, nil
}
func (_SimpleValidator__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.BeginList(0)
}
func (na *_SimpleValidator__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_SimpleValidator__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignBool(false)
}
func (_SimpleValidator__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignInt(0)
}
func (_SimpleValidator__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignFloat(0)
}
func (_SimpleValidator__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignString("")
}
func (_SimpleValidator__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignBytes(nil)
}
func (_SimpleValidator__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.SimpleValidator.Repr"}.AssignLink(nil)
}
func (na *_SimpleValidator__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_SimpleValidator); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.SimpleValidator.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_SimpleValidator__ReprAssembler) Prototype() ipld.NodePrototype {
	return _SimpleValidator__ReprPrototype{}
}
func (ma *_SimpleValidator__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_SimpleValidator__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PubKey":
		if ma.s&fieldBit__SimpleValidator_PubKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_PubKey_serial}
		}
		ma.s += fieldBit__SimpleValidator_PubKey
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey, nil
	case "VotingPower":
		if ma.s&fieldBit__SimpleValidator_VotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_VotingPower_serial}
		}
		ma.s += fieldBit__SimpleValidator_VotingPower
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.SimpleValidator.Repr", Key: &_String{k}}
}
func (ma *_SimpleValidator__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_SimpleValidator__ReprKeyAssembler)(ma)
}
func (ma *_SimpleValidator__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey
	case 1:
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower
	default:
		panic("unreachable")
	}
}
func (ma *_SimpleValidator__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__SimpleValidator_sufficient != fieldBits__SimpleValidator_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__SimpleValidator_PubKey == 0 {
			err.Missing = append(err.Missing, "PubKey")
		}
		if ma.s&fieldBit__SimpleValidator_VotingPower == 0 {
			err.Missing = append(err.Missing, "VotingPower")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_SimpleValidator__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_SimpleValidator__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _SimpleValidator__ReprKeyAssembler _SimpleValidator__ReprAssembler

func (_SimpleValidator__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.BeginMap(0)
}
func (_SimpleValidator__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_SimpleValidator__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignNull()
}
func (_SimpleValidator__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignBool(false)
}
func (_SimpleValidator__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignInt(0)
}
func (_SimpleValidator__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_SimpleValidator__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PubKey":
		if ka.s&fieldBit__SimpleValidator_PubKey != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_PubKey_serial}
		}
		ka.s += fieldBit__SimpleValidator_PubKey
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "VotingPower":
		if ka.s&fieldBit__SimpleValidator_VotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__SimpleValidator_VotingPower_serial}
		}
		ka.s += fieldBit__SimpleValidator_VotingPower
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.SimpleValidator.Repr", Key: &_String{k}}
}
func (_SimpleValidator__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_SimpleValidator__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.SimpleValidator.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_SimpleValidator__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_SimpleValidator__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n String) String() string {
	return n.x
}
func (_String__Prototype) fromString(w *_String, v string) error {
	*w = _String{v}
	return nil
}
func (_String__Prototype) FromString(v string) (String, error) {
	n := _String{v}
	return &n, nil
}

type _String__Maybe struct {
	m schema.Maybe
	v String
}
type MaybeString = *_String__Maybe

func (m MaybeString) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeString) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeString) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeString) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeString) Must() String {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (String)(&_String{})
var _ schema.TypedNode = (String)(&_String{})

func (String) Kind() ipld.Kind {
	return ipld.Kind_String
}
func (String) LookupByString(string) (ipld.Node, error) {
	return mixins.String{"dagcosmos.String"}.LookupByString("")
}
func (String) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.String{"dagcosmos.String"}.LookupByNode(nil)
}
func (String) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.String{"dagcosmos.String"}.LookupByIndex(0)
}
func (String) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.String{"dagcosmos.String"}.LookupBySegment(seg)
}
func (String) MapIterator() ipld.MapIterator {
	return nil
}
func (String) ListIterator() ipld.ListIterator {
	return nil
}
func (String) Length() int64 {
	return -1
}
func (String) IsAbsent() bool {
	return false
}
func (String) IsNull() bool {
	return false
}
func (String) AsBool() (bool, error) {
	return mixins.String{"dagcosmos.String"}.AsBool()
}
func (String) AsInt() (int64, error) {
	return mixins.String{"dagcosmos.String"}.AsInt()
}
func (String) AsFloat() (float64, error) {
	return mixins.String{"dagcosmos.String"}.AsFloat()
}
func (n String) AsString() (string, error) {
	return n.x, nil
}
func (String) AsBytes() ([]byte, error) {
	return mixins.String{"dagcosmos.String"}.AsBytes()
}
func (String) AsLink() (ipld.Link, error) {
	return mixins.String{"dagcosmos.String"}.AsLink()
}
func (String) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

type _String__Prototype struct{}

func (_String__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _String__Builder
	nb.Reset()
	return &nb
}

type _String__Builder struct {
	_String__Assembler
}

func (nb *_String__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_String__Builder) Reset() {
	var w _String
	var m schema.Maybe
	*nb = _String__Builder{_String__Assembler{w: &w, m: &m}}
}

type _String__Assembler struct {
	w *_String
	m *schema.Maybe
}

func (na *_String__Assembler) reset() {}
func (_String__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.String"}.BeginMap(0)
}
func (_String__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.String"}.BeginList(0)
}
func (na *_String__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.StringAssembler{"dagcosmos.String"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_String__Assembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.String"}.AssignBool(false)
}
func (_String__Assembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.String"}.AssignInt(0)
}
func (_String__Assembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.String"}.AssignFloat(0)
}
func (na *_String__Assembler) AssignString(v string) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_String{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_String__Assembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.String"}.AssignBytes(nil)
}
func (_String__Assembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.String"}.AssignLink(nil)
}
func (na *_String__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_String); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return na.AssignString(v2)
	}
}
func (_String__Assembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (String) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n String) Representation() ipld.Node {
	return (*_String__Repr)(n)
}

type _String__Repr = _String

var _ ipld.Node = &_String__Repr{}

type _String__ReprPrototype = _String__Prototype
type _String__ReprAssembler = _String__Assembler

func (n _Time) FieldSeconds() Uint {
	return &n.Seconds
}
func (n _Time) FieldNanoseconds() Uint {
	return &n.Nanoseconds
}

type _Time__Maybe struct {
	m schema.Maybe
	v Time
}
type MaybeTime = *_Time__Maybe

func (m MaybeTime) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTime) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTime) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTime) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTime) Must() Time {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Time_Seconds     = _String{"Seconds"}
	fieldName__Time_Nanoseconds = _String{"Nanoseconds"}
)
var _ ipld.Node = (Time)(&_Time{})
var _ schema.TypedNode = (Time)(&_Time{})

func (Time) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Time) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Seconds":
		return &n.Seconds, nil
	case "Nanoseconds":
		return &n.Nanoseconds, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Time) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Time) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Time"}.LookupByIndex(0)
}
func (n Time) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Time) MapIterator() ipld.MapIterator {
	return &_Time__MapItr{n, 0}
}

type _Time__MapItr struct {
	n   Time
	idx int
}

func (itr *_Time__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Time_Seconds
		v = &itr.n.Seconds
	case 1:
		k = &fieldName__Time_Nanoseconds
		v = &itr.n.Nanoseconds
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Time__MapItr) Done() bool {
	return itr.idx >= 2
}

func (Time) ListIterator() ipld.ListIterator {
	return nil
}
func (Time) Length() int64 {
	return 2
}
func (Time) IsAbsent() bool {
	return false
}
func (Time) IsNull() bool {
	return false
}
func (Time) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Time"}.AsBool()
}
func (Time) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Time"}.AsInt()
}
func (Time) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Time"}.AsFloat()
}
func (Time) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Time"}.AsString()
}
func (Time) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Time"}.AsBytes()
}
func (Time) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Time"}.AsLink()
}
func (Time) Prototype() ipld.NodePrototype {
	return _Time__Prototype{}
}

type _Time__Prototype struct{}

func (_Time__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Time__Builder
	nb.Reset()
	return &nb
}

type _Time__Builder struct {
	_Time__Assembler
}

func (nb *_Time__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Time__Builder) Reset() {
	var w _Time
	var m schema.Maybe
	*nb = _Time__Builder{_Time__Assembler{w: &w, m: &m}}
}

type _Time__Assembler struct {
	w     *_Time
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_Seconds     _Uint__Assembler
	ca_Nanoseconds _Uint__Assembler
}

func (na *_Time__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Seconds.reset()
	na.ca_Nanoseconds.reset()
}

var (
	fieldBit__Time_Seconds     = 1 << 0
	fieldBit__Time_Nanoseconds = 1 << 1
	fieldBits__Time_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_Time__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Time{}
	}
	return na, nil
}
func (_Time__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Time"}.BeginList(0)
}
func (na *_Time__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Time"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Time__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignBool(false)
}
func (_Time__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignInt(0)
}
func (_Time__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignFloat(0)
}
func (_Time__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignString("")
}
func (_Time__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignBytes(nil)
}
func (_Time__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Time"}.AssignLink(nil)
}
func (na *_Time__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Time); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Time", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Time__Assembler) Prototype() ipld.NodePrototype {
	return _Time__Prototype{}
}
func (ma *_Time__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Seconds.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Nanoseconds.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Time__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Seconds":
		if ma.s&fieldBit__Time_Seconds != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Seconds}
		}
		ma.s += fieldBit__Time_Seconds
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Seconds.w = &ma.w.Seconds
		ma.ca_Seconds.m = &ma.cm
		return &ma.ca_Seconds, nil
	case "Nanoseconds":
		if ma.s&fieldBit__Time_Nanoseconds != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Nanoseconds}
		}
		ma.s += fieldBit__Time_Nanoseconds
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Nanoseconds.w = &ma.w.Nanoseconds
		ma.ca_Nanoseconds.m = &ma.cm
		return &ma.ca_Nanoseconds, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Time", Key: &_String{k}}
}
func (ma *_Time__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Time__KeyAssembler)(ma)
}
func (ma *_Time__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Seconds.w = &ma.w.Seconds
		ma.ca_Seconds.m = &ma.cm
		return &ma.ca_Seconds
	case 1:
		ma.ca_Nanoseconds.w = &ma.w.Nanoseconds
		ma.ca_Nanoseconds.m = &ma.cm
		return &ma.ca_Nanoseconds
	default:
		panic("unreachable")
	}
}
func (ma *_Time__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Time_sufficient != fieldBits__Time_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Time_Seconds == 0 {
			err.Missing = append(err.Missing, "Seconds")
		}
		if ma.s&fieldBit__Time_Nanoseconds == 0 {
			err.Missing = append(err.Missing, "Nanoseconds")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Time__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Time__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Time__KeyAssembler _Time__Assembler

func (_Time__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.BeginMap(0)
}
func (_Time__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.BeginList(0)
}
func (na *_Time__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignNull()
}
func (_Time__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignBool(false)
}
func (_Time__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignInt(0)
}
func (_Time__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Time__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Seconds":
		if ka.s&fieldBit__Time_Seconds != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Seconds}
		}
		ka.s += fieldBit__Time_Seconds
		ka.state = maState_expectValue
		ka.f = 0
	case "Nanoseconds":
		if ka.s&fieldBit__Time_Nanoseconds != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Nanoseconds}
		}
		ka.s += fieldBit__Time_Nanoseconds
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Time", Key: &_String{k}}
	}
	return nil
}
func (_Time__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignBytes(nil)
}
func (_Time__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Time.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Time__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Time__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Time) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Time) Representation() ipld.Node {
	return (*_Time__Repr)(n)
}

type _Time__Repr _Time

var (
	fieldName__Time_Seconds_serial     = _String{"Seconds"}
	fieldName__Time_Nanoseconds_serial = _String{"Nanoseconds"}
)
var _ ipld.Node = &_Time__Repr{}

func (_Time__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Time__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Seconds":
		return n.Seconds.Representation(), nil
	case "Nanoseconds":
		return n.Nanoseconds.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Time__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Time__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.LookupByIndex(0)
}
func (n _Time__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Time__Repr) MapIterator() ipld.MapIterator {
	return &_Time__ReprMapItr{n, 0}
}

type _Time__ReprMapItr struct {
	n   *_Time__Repr
	idx int
}

func (itr *_Time__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Time_Seconds_serial
		v = itr.n.Seconds.Representation()
	case 1:
		k = &fieldName__Time_Nanoseconds_serial
		v = itr.n.Nanoseconds.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Time__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_Time__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Time__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_Time__Repr) IsAbsent() bool {
	return false
}
func (_Time__Repr) IsNull() bool {
	return false
}
func (_Time__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsBool()
}
func (_Time__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsInt()
}
func (_Time__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsFloat()
}
func (_Time__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsString()
}
func (_Time__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsBytes()
}
func (_Time__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Time.Repr"}.AsLink()
}
func (_Time__Repr) Prototype() ipld.NodePrototype {
	return _Time__ReprPrototype{}
}

type _Time__ReprPrototype struct{}

func (_Time__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Time__ReprBuilder
	nb.Reset()
	return &nb
}

type _Time__ReprBuilder struct {
	_Time__ReprAssembler
}

func (nb *_Time__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Time__ReprBuilder) Reset() {
	var w _Time
	var m schema.Maybe
	*nb = _Time__ReprBuilder{_Time__ReprAssembler{w: &w, m: &m}}
}

type _Time__ReprAssembler struct {
	w     *_Time
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_Seconds     _Uint__ReprAssembler
	ca_Nanoseconds _Uint__ReprAssembler
}

func (na *_Time__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Seconds.reset()
	na.ca_Nanoseconds.reset()
}
func (na *_Time__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Time{}
	}
	return na, nil
}
func (_Time__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.BeginList(0)
}
func (na *_Time__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Time.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Time__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignBool(false)
}
func (_Time__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignInt(0)
}
func (_Time__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignFloat(0)
}
func (_Time__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignString("")
}
func (_Time__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignBytes(nil)
}
func (_Time__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Time.Repr"}.AssignLink(nil)
}
func (na *_Time__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Time); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Time.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Time__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Time__ReprPrototype{}
}
func (ma *_Time__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Time__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Seconds":
		if ma.s&fieldBit__Time_Seconds != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Seconds_serial}
		}
		ma.s += fieldBit__Time_Seconds
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Seconds.w = &ma.w.Seconds
		ma.ca_Seconds.m = &ma.cm
		return &ma.ca_Seconds, nil
	case "Nanoseconds":
		if ma.s&fieldBit__Time_Nanoseconds != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Nanoseconds_serial}
		}
		ma.s += fieldBit__Time_Nanoseconds
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Nanoseconds.w = &ma.w.Nanoseconds
		ma.ca_Nanoseconds.m = &ma.cm
		return &ma.ca_Nanoseconds, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Time.Repr", Key: &_String{k}}
}
func (ma *_Time__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Time__ReprKeyAssembler)(ma)
}
func (ma *_Time__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Seconds.w = &ma.w.Seconds
		ma.ca_Seconds.m = &ma.cm
		return &ma.ca_Seconds
	case 1:
		ma.ca_Nanoseconds.w = &ma.w.Nanoseconds
		ma.ca_Nanoseconds.m = &ma.cm
		return &ma.ca_Nanoseconds
	default:
		panic("unreachable")
	}
}
func (ma *_Time__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Time_sufficient != fieldBits__Time_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Time_Seconds == 0 {
			err.Missing = append(err.Missing, "Seconds")
		}
		if ma.s&fieldBit__Time_Nanoseconds == 0 {
			err.Missing = append(err.Missing, "Nanoseconds")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Time__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Time__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Time__ReprKeyAssembler _Time__ReprAssembler

func (_Time__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Time__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Time__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignNull()
}
func (_Time__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Time__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Time__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Time__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Seconds":
		if ka.s&fieldBit__Time_Seconds != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Seconds_serial}
		}
		ka.s += fieldBit__Time_Seconds
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Nanoseconds":
		if ka.s&fieldBit__Time_Nanoseconds != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Time_Nanoseconds_serial}
		}
		ka.s += fieldBit__Time_Nanoseconds
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Time.Repr", Key: &_String{k}}
}
func (_Time__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Time__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Time.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Time__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Time__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_Tx) Lookup(idx int64) Bytes {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Tx) LookupMaybe(idx int64) MaybeBytes {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Bytes__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Tx__valueAbsent = _Bytes__Maybe{m: schema.Maybe_Absent}

func (n Tx) Iterator() *Tx__Itr {
	return &Tx__Itr{n, 0}
}

type Tx__Itr struct {
	n   Tx
	idx int
}

func (itr *Tx__Itr) Next() (idx int64, v Bytes) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Tx__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Tx__Maybe struct {
	m schema.Maybe
	v Tx
}
type MaybeTx = *_Tx__Maybe

func (m MaybeTx) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTx) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTx) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTx) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTx) Must() Tx {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Tx)(&_Tx{})
var _ schema.TypedNode = (Tx)(&_Tx{})

func (Tx) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Tx) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Tx"}.LookupByString("")
}
func (n Tx) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Tx) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Tx) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Tx", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Tx) MapIterator() ipld.MapIterator {
	return nil
}
func (n Tx) ListIterator() ipld.ListIterator {
	return &_Tx__ListItr{n, 0}
}

type _Tx__ListItr struct {
	n   Tx
	idx int
}

func (itr *_Tx__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Tx__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Tx) Length() int64 {
	return int64(len(n.x))
}
func (Tx) IsAbsent() bool {
	return false
}
func (Tx) IsNull() bool {
	return false
}
func (Tx) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Tx"}.AsBool()
}
func (Tx) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Tx"}.AsInt()
}
func (Tx) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Tx"}.AsFloat()
}
func (Tx) AsString() (string, error) {
	return mixins.List{"dagcosmos.Tx"}.AsString()
}
func (Tx) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Tx"}.AsBytes()
}
func (Tx) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Tx"}.AsLink()
}
func (Tx) Prototype() ipld.NodePrototype {
	return _Tx__Prototype{}
}

type _Tx__Prototype struct{}

func (_Tx__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Tx__Builder
	nb.Reset()
	return &nb
}

type _Tx__Builder struct {
	_Tx__Assembler
}

func (nb *_Tx__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Tx__Builder) Reset() {
	var w _Tx
	var m schema.Maybe
	*nb = _Tx__Builder{_Tx__Assembler{w: &w, m: &m}}
}

type _Tx__Assembler struct {
	w     *_Tx
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Bytes__Assembler
}

func (na *_Tx__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Tx__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Tx"}.BeginMap(0)
}
func (na *_Tx__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Tx{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Bytes, 0, sizeHint)
	}
	return na, nil
}
func (na *_Tx__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Tx"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Tx__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignBool(false)
}
func (_Tx__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignInt(0)
}
func (_Tx__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignFloat(0)
}
func (_Tx__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignString("")
}
func (_Tx__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignBytes(nil)
}
func (_Tx__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Tx"}.AssignLink(nil)
}
func (na *_Tx__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Tx); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Tx", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Tx__Assembler) Prototype() ipld.NodePrototype {
	return _Tx__Prototype{}
}
func (la *_Tx__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Tx__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Bytes{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Tx__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Tx__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Bytes__Prototype{}
}
func (Tx) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Tx) Representation() ipld.Node {
	return (*_Tx__Repr)(n)
}

type _Tx__Repr _Tx

var _ ipld.Node = &_Tx__Repr{}

func (_Tx__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Tx__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.LookupByString("")
}
func (nr *_Tx__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Tx)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Bytes).Representation(), nil
}
func (nr *_Tx__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Tx)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Bytes).Representation(), nil
}
func (n _Tx__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Tx.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Tx__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Tx__Repr) ListIterator() ipld.ListIterator {
	return &_Tx__ReprListItr{(Tx)(nr), 0}
}

type _Tx__ReprListItr _Tx__ListItr

func (itr *_Tx__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Tx__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Bytes).Representation(), nil
}
func (itr *_Tx__ReprListItr) Done() bool {
	return (*_Tx__ListItr)(itr).Done()
}

func (rn *_Tx__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Tx__Repr) IsAbsent() bool {
	return false
}
func (_Tx__Repr) IsNull() bool {
	return false
}
func (_Tx__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsBool()
}
func (_Tx__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsInt()
}
func (_Tx__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsFloat()
}
func (_Tx__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsString()
}
func (_Tx__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsBytes()
}
func (_Tx__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Tx.Repr"}.AsLink()
}
func (_Tx__Repr) Prototype() ipld.NodePrototype {
	return _Tx__ReprPrototype{}
}

type _Tx__ReprPrototype struct{}

func (_Tx__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Tx__ReprBuilder
	nb.Reset()
	return &nb
}

type _Tx__ReprBuilder struct {
	_Tx__ReprAssembler
}

func (nb *_Tx__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Tx__ReprBuilder) Reset() {
	var w _Tx
	var m schema.Maybe
	*nb = _Tx__ReprBuilder{_Tx__ReprAssembler{w: &w, m: &m}}
}

type _Tx__ReprAssembler struct {
	w     *_Tx
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Bytes__ReprAssembler
}

func (na *_Tx__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Tx__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.BeginMap(0)
}
func (na *_Tx__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Tx{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Bytes, 0, sizeHint)
	}
	return na, nil
}
func (na *_Tx__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Tx.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Tx__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignBool(false)
}
func (_Tx__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignInt(0)
}
func (_Tx__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignFloat(0)
}
func (_Tx__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignString("")
}
func (_Tx__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignBytes(nil)
}
func (_Tx__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Tx.Repr"}.AssignLink(nil)
}
func (na *_Tx__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Tx); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Tx.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Tx__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Tx__ReprPrototype{}
}
func (la *_Tx__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Tx__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Bytes{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Tx__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Tx__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Bytes__ReprPrototype{}
}

func (n *_Txs) Lookup(idx int64) Tx {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Txs) LookupMaybe(idx int64) MaybeTx {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Tx__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Txs__valueAbsent = _Tx__Maybe{m: schema.Maybe_Absent}

func (n Txs) Iterator() *Txs__Itr {
	return &Txs__Itr{n, 0}
}

type Txs__Itr struct {
	n   Txs
	idx int
}

func (itr *Txs__Itr) Next() (idx int64, v Tx) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Txs__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Txs__Maybe struct {
	m schema.Maybe
	v Txs
}
type MaybeTxs = *_Txs__Maybe

func (m MaybeTxs) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTxs) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTxs) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTxs) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTxs) Must() Txs {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Txs)(&_Txs{})
var _ schema.TypedNode = (Txs)(&_Txs{})

func (Txs) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Txs) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Txs"}.LookupByString("")
}
func (n Txs) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Txs) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Txs) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Txs", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Txs) MapIterator() ipld.MapIterator {
	return nil
}
func (n Txs) ListIterator() ipld.ListIterator {
	return &_Txs__ListItr{n, 0}
}

type _Txs__ListItr struct {
	n   Txs
	idx int
}

func (itr *_Txs__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Txs__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Txs) Length() int64 {
	return int64(len(n.x))
}
func (Txs) IsAbsent() bool {
	return false
}
func (Txs) IsNull() bool {
	return false
}
func (Txs) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Txs"}.AsBool()
}
func (Txs) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Txs"}.AsInt()
}
func (Txs) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Txs"}.AsFloat()
}
func (Txs) AsString() (string, error) {
	return mixins.List{"dagcosmos.Txs"}.AsString()
}
func (Txs) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Txs"}.AsBytes()
}
func (Txs) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Txs"}.AsLink()
}
func (Txs) Prototype() ipld.NodePrototype {
	return _Txs__Prototype{}
}

type _Txs__Prototype struct{}

func (_Txs__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Txs__Builder
	nb.Reset()
	return &nb
}

type _Txs__Builder struct {
	_Txs__Assembler
}

func (nb *_Txs__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Txs__Builder) Reset() {
	var w _Txs
	var m schema.Maybe
	*nb = _Txs__Builder{_Txs__Assembler{w: &w, m: &m}}
}

type _Txs__Assembler struct {
	w     *_Txs
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Tx__Assembler
}

func (na *_Txs__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Txs__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Txs"}.BeginMap(0)
}
func (na *_Txs__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Txs{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Tx, 0, sizeHint)
	}
	return na, nil
}
func (na *_Txs__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Txs"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Txs__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignBool(false)
}
func (_Txs__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignInt(0)
}
func (_Txs__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignFloat(0)
}
func (_Txs__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignString("")
}
func (_Txs__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignBytes(nil)
}
func (_Txs__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Txs"}.AssignLink(nil)
}
func (na *_Txs__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Txs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Txs", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Txs__Assembler) Prototype() ipld.NodePrototype {
	return _Txs__Prototype{}
}
func (la *_Txs__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Txs__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Tx{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Txs__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Txs__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Tx__Prototype{}
}
func (Txs) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Txs) Representation() ipld.Node {
	return (*_Txs__Repr)(n)
}

type _Txs__Repr _Txs

var _ ipld.Node = &_Txs__Repr{}

func (_Txs__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Txs__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.LookupByString("")
}
func (nr *_Txs__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Txs)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Tx).Representation(), nil
}
func (nr *_Txs__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Txs)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Tx).Representation(), nil
}
func (n _Txs__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Txs.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Txs__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Txs__Repr) ListIterator() ipld.ListIterator {
	return &_Txs__ReprListItr{(Txs)(nr), 0}
}

type _Txs__ReprListItr _Txs__ListItr

func (itr *_Txs__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Txs__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Tx).Representation(), nil
}
func (itr *_Txs__ReprListItr) Done() bool {
	return (*_Txs__ListItr)(itr).Done()
}

func (rn *_Txs__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Txs__Repr) IsAbsent() bool {
	return false
}
func (_Txs__Repr) IsNull() bool {
	return false
}
func (_Txs__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsBool()
}
func (_Txs__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsInt()
}
func (_Txs__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsFloat()
}
func (_Txs__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsString()
}
func (_Txs__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsBytes()
}
func (_Txs__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Txs.Repr"}.AsLink()
}
func (_Txs__Repr) Prototype() ipld.NodePrototype {
	return _Txs__ReprPrototype{}
}

type _Txs__ReprPrototype struct{}

func (_Txs__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Txs__ReprBuilder
	nb.Reset()
	return &nb
}

type _Txs__ReprBuilder struct {
	_Txs__ReprAssembler
}

func (nb *_Txs__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Txs__ReprBuilder) Reset() {
	var w _Txs
	var m schema.Maybe
	*nb = _Txs__ReprBuilder{_Txs__ReprAssembler{w: &w, m: &m}}
}

type _Txs__ReprAssembler struct {
	w     *_Txs
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Tx__ReprAssembler
}

func (na *_Txs__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Txs__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.BeginMap(0)
}
func (na *_Txs__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Txs{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Tx, 0, sizeHint)
	}
	return na, nil
}
func (na *_Txs__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Txs.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Txs__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignBool(false)
}
func (_Txs__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignInt(0)
}
func (_Txs__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignFloat(0)
}
func (_Txs__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignString("")
}
func (_Txs__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignBytes(nil)
}
func (_Txs__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Txs.Repr"}.AssignLink(nil)
}
func (na *_Txs__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Txs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Txs.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Txs__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Txs__ReprPrototype{}
}
func (la *_Txs__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Txs__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Tx{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Txs__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Txs__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Tx__ReprPrototype{}
}

func (n Uint) Bytes() []byte {
	return n.x
}
func (_Uint__Prototype) FromBytes(v []byte) (Uint, error) {
	n := _Uint{v}
	return &n, nil
}

type _Uint__Maybe struct {
	m schema.Maybe
	v Uint
}
type MaybeUint = *_Uint__Maybe

func (m MaybeUint) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUint) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUint) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUint) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeUint) Must() Uint {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Uint)(&_Uint{})
var _ schema.TypedNode = (Uint)(&_Uint{})

func (Uint) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Uint) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.LookupByString("")
}
func (Uint) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.LookupByNode(nil)
}
func (Uint) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.LookupByIndex(0)
}
func (Uint) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.LookupBySegment(seg)
}
func (Uint) MapIterator() ipld.MapIterator {
	return nil
}
func (Uint) ListIterator() ipld.ListIterator {
	return nil
}
func (Uint) Length() int64 {
	return -1
}
func (Uint) IsAbsent() bool {
	return false
}
func (Uint) IsNull() bool {
	return false
}
func (Uint) AsBool() (bool, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.AsBool()
}
func (Uint) AsInt() (int64, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.AsInt()
}
func (Uint) AsFloat() (float64, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.AsFloat()
}
func (Uint) AsString() (string, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.AsString()
}
func (n Uint) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Uint) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dagcosmos.Uint"}.AsLink()
}
func (Uint) Prototype() ipld.NodePrototype {
	return _Uint__Prototype{}
}

type _Uint__Prototype struct{}

func (_Uint__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Uint__Builder
	nb.Reset()
	return &nb
}

type _Uint__Builder struct {
	_Uint__Assembler
}

func (nb *_Uint__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Uint__Builder) Reset() {
	var w _Uint
	var m schema.Maybe
	*nb = _Uint__Builder{_Uint__Assembler{w: &w, m: &m}}
}

type _Uint__Assembler struct {
	w *_Uint
	m *schema.Maybe
}

func (na *_Uint__Assembler) reset() {}
func (_Uint__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.BeginMap(0)
}
func (_Uint__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.BeginList(0)
}
func (na *_Uint__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Uint__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignBool(false)
}
func (_Uint__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignInt(0)
}
func (_Uint__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignFloat(0)
}
func (_Uint__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignString("")
}
func (na *_Uint__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Uint{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Uint__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dagcosmos.Uint"}.AssignLink(nil)
}
func (na *_Uint__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Uint); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Uint__Assembler) Prototype() ipld.NodePrototype {
	return _Uint__Prototype{}
}
func (Uint) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Uint) Representation() ipld.Node {
	return (*_Uint__Repr)(n)
}

type _Uint__Repr = _Uint

var _ ipld.Node = &_Uint__Repr{}

type _Uint__ReprPrototype = _Uint__Prototype
type _Uint__ReprAssembler = _Uint__Assembler

func (n _Validator) FieldAddress() Address {
	return &n.Address
}
func (n _Validator) FieldPubKey() PubKey {
	return &n.PubKey
}
func (n _Validator) FieldVotingPower() Int {
	return &n.VotingPower
}
func (n _Validator) FieldProsperPriority() Int {
	return &n.ProsperPriority
}

type _Validator__Maybe struct {
	m schema.Maybe
	v Validator
}
type MaybeValidator = *_Validator__Maybe

func (m MaybeValidator) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeValidator) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeValidator) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeValidator) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeValidator) Must() Validator {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Validator_Address         = _String{"Address"}
	fieldName__Validator_PubKey          = _String{"PubKey"}
	fieldName__Validator_VotingPower     = _String{"VotingPower"}
	fieldName__Validator_ProsperPriority = _String{"ProsperPriority"}
)
var _ ipld.Node = (Validator)(&_Validator{})
var _ schema.TypedNode = (Validator)(&_Validator{})

func (Validator) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Validator) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return &n.Address, nil
	case "PubKey":
		return &n.PubKey, nil
	case "VotingPower":
		return &n.VotingPower, nil
	case "ProsperPriority":
		return &n.ProsperPriority, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Validator) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Validator) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Validator"}.LookupByIndex(0)
}
func (n Validator) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Validator) MapIterator() ipld.MapIterator {
	return &_Validator__MapItr{n, 0}
}

type _Validator__MapItr struct {
	n   Validator
	idx int
}

func (itr *_Validator__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Validator_Address
		v = &itr.n.Address
	case 1:
		k = &fieldName__Validator_PubKey
		v = &itr.n.PubKey
	case 2:
		k = &fieldName__Validator_VotingPower
		v = &itr.n.VotingPower
	case 3:
		k = &fieldName__Validator_ProsperPriority
		v = &itr.n.ProsperPriority
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Validator__MapItr) Done() bool {
	return itr.idx >= 4
}

func (Validator) ListIterator() ipld.ListIterator {
	return nil
}
func (Validator) Length() int64 {
	return 4
}
func (Validator) IsAbsent() bool {
	return false
}
func (Validator) IsNull() bool {
	return false
}
func (Validator) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsBool()
}
func (Validator) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsInt()
}
func (Validator) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsFloat()
}
func (Validator) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsString()
}
func (Validator) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsBytes()
}
func (Validator) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Validator"}.AsLink()
}
func (Validator) Prototype() ipld.NodePrototype {
	return _Validator__Prototype{}
}

type _Validator__Prototype struct{}

func (_Validator__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Validator__Builder
	nb.Reset()
	return &nb
}

type _Validator__Builder struct {
	_Validator__Assembler
}

func (nb *_Validator__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Validator__Builder) Reset() {
	var w _Validator
	var m schema.Maybe
	*nb = _Validator__Builder{_Validator__Assembler{w: &w, m: &m}}
}

type _Validator__Assembler struct {
	w     *_Validator
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                 schema.Maybe
	ca_Address         _Address__Assembler
	ca_PubKey          _PubKey__Assembler
	ca_VotingPower     _Int__Assembler
	ca_ProsperPriority _Int__Assembler
}

func (na *_Validator__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_PubKey.reset()
	na.ca_VotingPower.reset()
	na.ca_ProsperPriority.reset()
}

var (
	fieldBit__Validator_Address         = 1 << 0
	fieldBit__Validator_PubKey          = 1 << 1
	fieldBit__Validator_VotingPower     = 1 << 2
	fieldBit__Validator_ProsperPriority = 1 << 3
	fieldBits__Validator_sufficient     = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_Validator__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Validator{}
	}
	return na, nil
}
func (_Validator__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Validator"}.BeginList(0)
}
func (na *_Validator__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Validator"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Validator__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignBool(false)
}
func (_Validator__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignInt(0)
}
func (_Validator__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignFloat(0)
}
func (_Validator__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignString("")
}
func (_Validator__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignBytes(nil)
}
func (_Validator__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Validator"}.AssignLink(nil)
}
func (na *_Validator__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Validator); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Validator", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Validator__Assembler) Prototype() ipld.NodePrototype {
	return _Validator__Prototype{}
}
func (ma *_Validator__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Address.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PubKey.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_VotingPower.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ProsperPriority.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Validator__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__Validator_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_Address}
		}
		ma.s += fieldBit__Validator_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "PubKey":
		if ma.s&fieldBit__Validator_PubKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_PubKey}
		}
		ma.s += fieldBit__Validator_PubKey
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey, nil
	case "VotingPower":
		if ma.s&fieldBit__Validator_VotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_VotingPower}
		}
		ma.s += fieldBit__Validator_VotingPower
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower, nil
	case "ProsperPriority":
		if ma.s&fieldBit__Validator_ProsperPriority != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_ProsperPriority}
		}
		ma.s += fieldBit__Validator_ProsperPriority
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_ProsperPriority.w = &ma.w.ProsperPriority
		ma.ca_ProsperPriority.m = &ma.cm
		return &ma.ca_ProsperPriority, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Validator", Key: &_String{k}}
}
func (ma *_Validator__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Validator__KeyAssembler)(ma)
}
func (ma *_Validator__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey
	case 2:
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower
	case 3:
		ma.ca_ProsperPriority.w = &ma.w.ProsperPriority
		ma.ca_ProsperPriority.m = &ma.cm
		return &ma.ca_ProsperPriority
	default:
		panic("unreachable")
	}
}
func (ma *_Validator__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Validator_sufficient != fieldBits__Validator_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Validator_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__Validator_PubKey == 0 {
			err.Missing = append(err.Missing, "PubKey")
		}
		if ma.s&fieldBit__Validator_VotingPower == 0 {
			err.Missing = append(err.Missing, "VotingPower")
		}
		if ma.s&fieldBit__Validator_ProsperPriority == 0 {
			err.Missing = append(err.Missing, "ProsperPriority")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Validator__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Validator__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Validator__KeyAssembler _Validator__Assembler

func (_Validator__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.BeginMap(0)
}
func (_Validator__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.BeginList(0)
}
func (na *_Validator__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignNull()
}
func (_Validator__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignBool(false)
}
func (_Validator__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignInt(0)
}
func (_Validator__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Validator__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__Validator_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_Address}
		}
		ka.s += fieldBit__Validator_Address
		ka.state = maState_expectValue
		ka.f = 0
	case "PubKey":
		if ka.s&fieldBit__Validator_PubKey != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_PubKey}
		}
		ka.s += fieldBit__Validator_PubKey
		ka.state = maState_expectValue
		ka.f = 1
	case "VotingPower":
		if ka.s&fieldBit__Validator_VotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_VotingPower}
		}
		ka.s += fieldBit__Validator_VotingPower
		ka.state = maState_expectValue
		ka.f = 2
	case "ProsperPriority":
		if ka.s&fieldBit__Validator_ProsperPriority != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_ProsperPriority}
		}
		ka.s += fieldBit__Validator_ProsperPriority
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Validator", Key: &_String{k}}
	}
	return nil
}
func (_Validator__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignBytes(nil)
}
func (_Validator__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Validator.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Validator__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Validator__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Validator) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Validator) Representation() ipld.Node {
	return (*_Validator__Repr)(n)
}

type _Validator__Repr _Validator

var (
	fieldName__Validator_Address_serial         = _String{"Address"}
	fieldName__Validator_PubKey_serial          = _String{"PubKey"}
	fieldName__Validator_VotingPower_serial     = _String{"VotingPower"}
	fieldName__Validator_ProsperPriority_serial = _String{"ProsperPriority"}
)
var _ ipld.Node = &_Validator__Repr{}

func (_Validator__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Validator__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return n.Address.Representation(), nil
	case "PubKey":
		return n.PubKey.Representation(), nil
	case "VotingPower":
		return n.VotingPower.Representation(), nil
	case "ProsperPriority":
		return n.ProsperPriority.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Validator__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Validator__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.LookupByIndex(0)
}
func (n _Validator__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Validator__Repr) MapIterator() ipld.MapIterator {
	return &_Validator__ReprMapItr{n, 0}
}

type _Validator__ReprMapItr struct {
	n   *_Validator__Repr
	idx int
}

func (itr *_Validator__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Validator_Address_serial
		v = itr.n.Address.Representation()
	case 1:
		k = &fieldName__Validator_PubKey_serial
		v = itr.n.PubKey.Representation()
	case 2:
		k = &fieldName__Validator_VotingPower_serial
		v = itr.n.VotingPower.Representation()
	case 3:
		k = &fieldName__Validator_ProsperPriority_serial
		v = itr.n.ProsperPriority.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Validator__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_Validator__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Validator__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_Validator__Repr) IsAbsent() bool {
	return false
}
func (_Validator__Repr) IsNull() bool {
	return false
}
func (_Validator__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsBool()
}
func (_Validator__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsInt()
}
func (_Validator__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsFloat()
}
func (_Validator__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsString()
}
func (_Validator__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsBytes()
}
func (_Validator__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Validator.Repr"}.AsLink()
}
func (_Validator__Repr) Prototype() ipld.NodePrototype {
	return _Validator__ReprPrototype{}
}

type _Validator__ReprPrototype struct{}

func (_Validator__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Validator__ReprBuilder
	nb.Reset()
	return &nb
}

type _Validator__ReprBuilder struct {
	_Validator__ReprAssembler
}

func (nb *_Validator__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Validator__ReprBuilder) Reset() {
	var w _Validator
	var m schema.Maybe
	*nb = _Validator__ReprBuilder{_Validator__ReprAssembler{w: &w, m: &m}}
}

type _Validator__ReprAssembler struct {
	w     *_Validator
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                 schema.Maybe
	ca_Address         _Address__ReprAssembler
	ca_PubKey          _PubKey__ReprAssembler
	ca_VotingPower     _Int__ReprAssembler
	ca_ProsperPriority _Int__ReprAssembler
}

func (na *_Validator__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_PubKey.reset()
	na.ca_VotingPower.reset()
	na.ca_ProsperPriority.reset()
}
func (na *_Validator__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Validator{}
	}
	return na, nil
}
func (_Validator__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.BeginList(0)
}
func (na *_Validator__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Validator.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Validator__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignBool(false)
}
func (_Validator__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignInt(0)
}
func (_Validator__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignFloat(0)
}
func (_Validator__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignString("")
}
func (_Validator__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignBytes(nil)
}
func (_Validator__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Validator.Repr"}.AssignLink(nil)
}
func (na *_Validator__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Validator); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Validator.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Validator__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Validator__ReprPrototype{}
}
func (ma *_Validator__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Validator__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__Validator_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_Address_serial}
		}
		ma.s += fieldBit__Validator_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "PubKey":
		if ma.s&fieldBit__Validator_PubKey != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_PubKey_serial}
		}
		ma.s += fieldBit__Validator_PubKey
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey, nil
	case "VotingPower":
		if ma.s&fieldBit__Validator_VotingPower != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_VotingPower_serial}
		}
		ma.s += fieldBit__Validator_VotingPower
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower, nil
	case "ProsperPriority":
		if ma.s&fieldBit__Validator_ProsperPriority != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_ProsperPriority_serial}
		}
		ma.s += fieldBit__Validator_ProsperPriority
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_ProsperPriority.w = &ma.w.ProsperPriority
		ma.ca_ProsperPriority.m = &ma.cm
		return &ma.ca_ProsperPriority, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Validator.Repr", Key: &_String{k}}
}
func (ma *_Validator__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Validator__ReprKeyAssembler)(ma)
}
func (ma *_Validator__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_PubKey.w = &ma.w.PubKey
		ma.ca_PubKey.m = &ma.cm
		return &ma.ca_PubKey
	case 2:
		ma.ca_VotingPower.w = &ma.w.VotingPower
		ma.ca_VotingPower.m = &ma.cm
		return &ma.ca_VotingPower
	case 3:
		ma.ca_ProsperPriority.w = &ma.w.ProsperPriority
		ma.ca_ProsperPriority.m = &ma.cm
		return &ma.ca_ProsperPriority
	default:
		panic("unreachable")
	}
}
func (ma *_Validator__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Validator_sufficient != fieldBits__Validator_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Validator_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__Validator_PubKey == 0 {
			err.Missing = append(err.Missing, "PubKey")
		}
		if ma.s&fieldBit__Validator_VotingPower == 0 {
			err.Missing = append(err.Missing, "VotingPower")
		}
		if ma.s&fieldBit__Validator_ProsperPriority == 0 {
			err.Missing = append(err.Missing, "ProsperPriority")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Validator__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Validator__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Validator__ReprKeyAssembler _Validator__ReprAssembler

func (_Validator__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Validator__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Validator__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignNull()
}
func (_Validator__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Validator__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Validator__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Validator__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__Validator_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_Address_serial}
		}
		ka.s += fieldBit__Validator_Address
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "PubKey":
		if ka.s&fieldBit__Validator_PubKey != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_PubKey_serial}
		}
		ka.s += fieldBit__Validator_PubKey
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "VotingPower":
		if ka.s&fieldBit__Validator_VotingPower != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_VotingPower_serial}
		}
		ka.s += fieldBit__Validator_VotingPower
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "ProsperPriority":
		if ka.s&fieldBit__Validator_ProsperPriority != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Validator_ProsperPriority_serial}
		}
		ka.s += fieldBit__Validator_ProsperPriority
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Validator.Repr", Key: &_String{k}}
}
func (_Validator__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Validator__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Validator.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Validator__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Validator__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _ValidatorParams) FieldPubKeyTypes() PubKeyTypes {
	return &n.PubKeyTypes
}

type _ValidatorParams__Maybe struct {
	m schema.Maybe
	v ValidatorParams
}
type MaybeValidatorParams = *_ValidatorParams__Maybe

func (m MaybeValidatorParams) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeValidatorParams) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeValidatorParams) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeValidatorParams) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeValidatorParams) Must() ValidatorParams {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__ValidatorParams_PubKeyTypes = _String{"PubKeyTypes"}
)
var _ ipld.Node = (ValidatorParams)(&_ValidatorParams{})
var _ schema.TypedNode = (ValidatorParams)(&_ValidatorParams{})

func (ValidatorParams) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n ValidatorParams) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PubKeyTypes":
		return &n.PubKeyTypes, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n ValidatorParams) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (ValidatorParams) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.ValidatorParams"}.LookupByIndex(0)
}
func (n ValidatorParams) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n ValidatorParams) MapIterator() ipld.MapIterator {
	return &_ValidatorParams__MapItr{n, 0}
}

type _ValidatorParams__MapItr struct {
	n   ValidatorParams
	idx int
}

func (itr *_ValidatorParams__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__ValidatorParams_PubKeyTypes
		v = &itr.n.PubKeyTypes
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ValidatorParams__MapItr) Done() bool {
	return itr.idx >= 1
}

func (ValidatorParams) ListIterator() ipld.ListIterator {
	return nil
}
func (ValidatorParams) Length() int64 {
	return 1
}
func (ValidatorParams) IsAbsent() bool {
	return false
}
func (ValidatorParams) IsNull() bool {
	return false
}
func (ValidatorParams) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.ValidatorParams"}.AsBool()
}
func (ValidatorParams) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.ValidatorParams"}.AsInt()
}
func (ValidatorParams) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.ValidatorParams"}.AsFloat()
}
func (ValidatorParams) AsString() (string, error) {
	return mixins.Map{"dagcosmos.ValidatorParams"}.AsString()
}
func (ValidatorParams) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.ValidatorParams"}.AsBytes()
}
func (ValidatorParams) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.ValidatorParams"}.AsLink()
}
func (ValidatorParams) Prototype() ipld.NodePrototype {
	return _ValidatorParams__Prototype{}
}

type _ValidatorParams__Prototype struct{}

func (_ValidatorParams__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _ValidatorParams__Builder
	nb.Reset()
	return &nb
}

type _ValidatorParams__Builder struct {
	_ValidatorParams__Assembler
}

func (nb *_ValidatorParams__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ValidatorParams__Builder) Reset() {
	var w _ValidatorParams
	var m schema.Maybe
	*nb = _ValidatorParams__Builder{_ValidatorParams__Assembler{w: &w, m: &m}}
}

type _ValidatorParams__Assembler struct {
	w     *_ValidatorParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PubKeyTypes _PubKeyTypes__Assembler
}

func (na *_ValidatorParams__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PubKeyTypes.reset()
}

var (
	fieldBit__ValidatorParams_PubKeyTypes = 1 << 0
	fieldBits__ValidatorParams_sufficient = 0 + 1<<0
)

func (na *_ValidatorParams__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ValidatorParams{}
	}
	return na, nil
}
func (_ValidatorParams__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams"}.BeginList(0)
}
func (na *_ValidatorParams__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.ValidatorParams"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ValidatorParams__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams"}.AssignBool(false)
}
func (_ValidatorParams__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams"}.AssignInt(0)
}
func (_ValidatorParams__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams"}.AssignFloat(0)
}
func (_ValidatorParams__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams"}.AssignString("")
}
func (_ValidatorParams__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams"}.AssignBytes(nil)
}
func (_ValidatorParams__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams"}.AssignLink(nil)
}
func (na *_ValidatorParams__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ValidatorParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.ValidatorParams", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ValidatorParams__Assembler) Prototype() ipld.NodePrototype {
	return _ValidatorParams__Prototype{}
}
func (ma *_ValidatorParams__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PubKeyTypes.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorParams__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PubKeyTypes":
		if ma.s&fieldBit__ValidatorParams_PubKeyTypes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorParams_PubKeyTypes}
		}
		ma.s += fieldBit__ValidatorParams_PubKeyTypes
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PubKeyTypes.w = &ma.w.PubKeyTypes
		ma.ca_PubKeyTypes.m = &ma.cm
		return &ma.ca_PubKeyTypes, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorParams", Key: &_String{k}}
}
func (ma *_ValidatorParams__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ValidatorParams__KeyAssembler)(ma)
}
func (ma *_ValidatorParams__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PubKeyTypes.w = &ma.w.PubKeyTypes
		ma.ca_PubKeyTypes.m = &ma.cm
		return &ma.ca_PubKeyTypes
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorParams__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__ValidatorParams_sufficient != fieldBits__ValidatorParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__ValidatorParams_PubKeyTypes == 0 {
			err.Missing = append(err.Missing, "PubKeyTypes")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ValidatorParams__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ValidatorParams__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _ValidatorParams__KeyAssembler _ValidatorParams__Assembler

func (_ValidatorParams__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.KeyAssembler"}.BeginMap(0)
}
func (_ValidatorParams__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.KeyAssembler"}.BeginList(0)
}
func (na *_ValidatorParams__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.KeyAssembler"}.AssignNull()
}
func (_ValidatorParams__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.KeyAssembler"}.AssignBool(false)
}
func (_ValidatorParams__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.KeyAssembler"}.AssignInt(0)
}
func (_ValidatorParams__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ValidatorParams__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PubKeyTypes":
		if ka.s&fieldBit__ValidatorParams_PubKeyTypes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorParams_PubKeyTypes}
		}
		ka.s += fieldBit__ValidatorParams_PubKeyTypes
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorParams", Key: &_String{k}}
	}
	return nil
}
func (_ValidatorParams__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.KeyAssembler"}.AssignBytes(nil)
}
func (_ValidatorParams__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ValidatorParams__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ValidatorParams__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ValidatorParams) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n ValidatorParams) Representation() ipld.Node {
	return (*_ValidatorParams__Repr)(n)
}

type _ValidatorParams__Repr _ValidatorParams

var (
	fieldName__ValidatorParams_PubKeyTypes_serial = _String{"PubKeyTypes"}
)
var _ ipld.Node = &_ValidatorParams__Repr{}

func (_ValidatorParams__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_ValidatorParams__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PubKeyTypes":
		return n.PubKeyTypes.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_ValidatorParams__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_ValidatorParams__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.ValidatorParams.Repr"}.LookupByIndex(0)
}
func (n _ValidatorParams__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_ValidatorParams__Repr) MapIterator() ipld.MapIterator {
	return &_ValidatorParams__ReprMapItr{n, 0}
}

type _ValidatorParams__ReprMapItr struct {
	n   *_ValidatorParams__Repr
	idx int
}

func (itr *_ValidatorParams__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__ValidatorParams_PubKeyTypes_serial
		v = itr.n.PubKeyTypes.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ValidatorParams__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_ValidatorParams__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_ValidatorParams__Repr) Length() int64 {
	l := 1
	return int64(l)
}
func (_ValidatorParams__Repr) IsAbsent() bool {
	return false
}
func (_ValidatorParams__Repr) IsNull() bool {
	return false
}
func (_ValidatorParams__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.ValidatorParams.Repr"}.AsBool()
}
func (_ValidatorParams__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.ValidatorParams.Repr"}.AsInt()
}
func (_ValidatorParams__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.ValidatorParams.Repr"}.AsFloat()
}
func (_ValidatorParams__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.ValidatorParams.Repr"}.AsString()
}
func (_ValidatorParams__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.ValidatorParams.Repr"}.AsBytes()
}
func (_ValidatorParams__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.ValidatorParams.Repr"}.AsLink()
}
func (_ValidatorParams__Repr) Prototype() ipld.NodePrototype {
	return _ValidatorParams__ReprPrototype{}
}

type _ValidatorParams__ReprPrototype struct{}

func (_ValidatorParams__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _ValidatorParams__ReprBuilder
	nb.Reset()
	return &nb
}

type _ValidatorParams__ReprBuilder struct {
	_ValidatorParams__ReprAssembler
}

func (nb *_ValidatorParams__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ValidatorParams__ReprBuilder) Reset() {
	var w _ValidatorParams
	var m schema.Maybe
	*nb = _ValidatorParams__ReprBuilder{_ValidatorParams__ReprAssembler{w: &w, m: &m}}
}

type _ValidatorParams__ReprAssembler struct {
	w     *_ValidatorParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PubKeyTypes _PubKeyTypes__ReprAssembler
}

func (na *_ValidatorParams__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PubKeyTypes.reset()
}
func (na *_ValidatorParams__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ValidatorParams{}
	}
	return na, nil
}
func (_ValidatorParams__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams.Repr"}.BeginList(0)
}
func (na *_ValidatorParams__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.ValidatorParams.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ValidatorParams__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams.Repr"}.AssignBool(false)
}
func (_ValidatorParams__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams.Repr"}.AssignInt(0)
}
func (_ValidatorParams__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams.Repr"}.AssignFloat(0)
}
func (_ValidatorParams__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams.Repr"}.AssignString("")
}
func (_ValidatorParams__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams.Repr"}.AssignBytes(nil)
}
func (_ValidatorParams__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorParams.Repr"}.AssignLink(nil)
}
func (na *_ValidatorParams__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ValidatorParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.ValidatorParams.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ValidatorParams__ReprAssembler) Prototype() ipld.NodePrototype {
	return _ValidatorParams__ReprPrototype{}
}
func (ma *_ValidatorParams__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorParams__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PubKeyTypes":
		if ma.s&fieldBit__ValidatorParams_PubKeyTypes != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorParams_PubKeyTypes_serial}
		}
		ma.s += fieldBit__ValidatorParams_PubKeyTypes
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PubKeyTypes.w = &ma.w.PubKeyTypes
		ma.ca_PubKeyTypes.m = &ma.cm
		return &ma.ca_PubKeyTypes, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorParams.Repr", Key: &_String{k}}
}
func (ma *_ValidatorParams__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ValidatorParams__ReprKeyAssembler)(ma)
}
func (ma *_ValidatorParams__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PubKeyTypes.w = &ma.w.PubKeyTypes
		ma.ca_PubKeyTypes.m = &ma.cm
		return &ma.ca_PubKeyTypes
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorParams__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__ValidatorParams_sufficient != fieldBits__ValidatorParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__ValidatorParams_PubKeyTypes == 0 {
			err.Missing = append(err.Missing, "PubKeyTypes")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ValidatorParams__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ValidatorParams__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _ValidatorParams__ReprKeyAssembler _ValidatorParams__ReprAssembler

func (_ValidatorParams__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.Repr.KeyAssembler"}.BeginMap(0)
}
func (_ValidatorParams__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_ValidatorParams__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.Repr.KeyAssembler"}.AssignNull()
}
func (_ValidatorParams__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.Repr.KeyAssembler"}.AssignBool(false)
}
func (_ValidatorParams__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.Repr.KeyAssembler"}.AssignInt(0)
}
func (_ValidatorParams__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ValidatorParams__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PubKeyTypes":
		if ka.s&fieldBit__ValidatorParams_PubKeyTypes != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorParams_PubKeyTypes_serial}
		}
		ka.s += fieldBit__ValidatorParams_PubKeyTypes
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorParams.Repr", Key: &_String{k}}
}
func (_ValidatorParams__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_ValidatorParams__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorParams.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ValidatorParams__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ValidatorParams__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _ValidatorSet) FieldValidators() Validators {
	return &n.Validators
}
func (n _ValidatorSet) FieldProposer() Validator {
	return &n.Proposer
}

type _ValidatorSet__Maybe struct {
	m schema.Maybe
	v ValidatorSet
}
type MaybeValidatorSet = *_ValidatorSet__Maybe

func (m MaybeValidatorSet) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeValidatorSet) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeValidatorSet) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeValidatorSet) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeValidatorSet) Must() ValidatorSet {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__ValidatorSet_Validators = _String{"Validators"}
	fieldName__ValidatorSet_Proposer   = _String{"Proposer"}
)
var _ ipld.Node = (ValidatorSet)(&_ValidatorSet{})
var _ schema.TypedNode = (ValidatorSet)(&_ValidatorSet{})

func (ValidatorSet) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n ValidatorSet) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Validators":
		return &n.Validators, nil
	case "Proposer":
		return &n.Proposer, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n ValidatorSet) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (ValidatorSet) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.LookupByIndex(0)
}
func (n ValidatorSet) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n ValidatorSet) MapIterator() ipld.MapIterator {
	return &_ValidatorSet__MapItr{n, 0}
}

type _ValidatorSet__MapItr struct {
	n   ValidatorSet
	idx int
}

func (itr *_ValidatorSet__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__ValidatorSet_Validators
		v = &itr.n.Validators
	case 1:
		k = &fieldName__ValidatorSet_Proposer
		v = &itr.n.Proposer
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ValidatorSet__MapItr) Done() bool {
	return itr.idx >= 2
}

func (ValidatorSet) ListIterator() ipld.ListIterator {
	return nil
}
func (ValidatorSet) Length() int64 {
	return 2
}
func (ValidatorSet) IsAbsent() bool {
	return false
}
func (ValidatorSet) IsNull() bool {
	return false
}
func (ValidatorSet) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsBool()
}
func (ValidatorSet) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsInt()
}
func (ValidatorSet) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsFloat()
}
func (ValidatorSet) AsString() (string, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsString()
}
func (ValidatorSet) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsBytes()
}
func (ValidatorSet) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.ValidatorSet"}.AsLink()
}
func (ValidatorSet) Prototype() ipld.NodePrototype {
	return _ValidatorSet__Prototype{}
}

type _ValidatorSet__Prototype struct{}

func (_ValidatorSet__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _ValidatorSet__Builder
	nb.Reset()
	return &nb
}

type _ValidatorSet__Builder struct {
	_ValidatorSet__Assembler
}

func (nb *_ValidatorSet__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ValidatorSet__Builder) Reset() {
	var w _ValidatorSet
	var m schema.Maybe
	*nb = _ValidatorSet__Builder{_ValidatorSet__Assembler{w: &w, m: &m}}
}

type _ValidatorSet__Assembler struct {
	w     *_ValidatorSet
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Validators _Validators__Assembler
	ca_Proposer   _Validator__Assembler
}

func (na *_ValidatorSet__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Validators.reset()
	na.ca_Proposer.reset()
}

var (
	fieldBit__ValidatorSet_Validators  = 1 << 0
	fieldBit__ValidatorSet_Proposer    = 1 << 1
	fieldBits__ValidatorSet_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_ValidatorSet__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ValidatorSet{}
	}
	return na, nil
}
func (_ValidatorSet__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.BeginList(0)
}
func (na *_ValidatorSet__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ValidatorSet__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignBool(false)
}
func (_ValidatorSet__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignInt(0)
}
func (_ValidatorSet__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignFloat(0)
}
func (_ValidatorSet__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignString("")
}
func (_ValidatorSet__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignBytes(nil)
}
func (_ValidatorSet__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet"}.AssignLink(nil)
}
func (na *_ValidatorSet__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ValidatorSet); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.ValidatorSet", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ValidatorSet__Assembler) Prototype() ipld.NodePrototype {
	return _ValidatorSet__Prototype{}
}
func (ma *_ValidatorSet__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Validators.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Proposer.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorSet__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Validators":
		if ma.s&fieldBit__ValidatorSet_Validators != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Validators}
		}
		ma.s += fieldBit__ValidatorSet_Validators
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Validators.w = &ma.w.Validators
		ma.ca_Validators.m = &ma.cm
		return &ma.ca_Validators, nil
	case "Proposer":
		if ma.s&fieldBit__ValidatorSet_Proposer != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Proposer}
		}
		ma.s += fieldBit__ValidatorSet_Proposer
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Proposer.w = &ma.w.Proposer
		ma.ca_Proposer.m = &ma.cm
		return &ma.ca_Proposer, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorSet", Key: &_String{k}}
}
func (ma *_ValidatorSet__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ValidatorSet__KeyAssembler)(ma)
}
func (ma *_ValidatorSet__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Validators.w = &ma.w.Validators
		ma.ca_Validators.m = &ma.cm
		return &ma.ca_Validators
	case 1:
		ma.ca_Proposer.w = &ma.w.Proposer
		ma.ca_Proposer.m = &ma.cm
		return &ma.ca_Proposer
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorSet__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__ValidatorSet_sufficient != fieldBits__ValidatorSet_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__ValidatorSet_Validators == 0 {
			err.Missing = append(err.Missing, "Validators")
		}
		if ma.s&fieldBit__ValidatorSet_Proposer == 0 {
			err.Missing = append(err.Missing, "Proposer")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ValidatorSet__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ValidatorSet__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _ValidatorSet__KeyAssembler _ValidatorSet__Assembler

func (_ValidatorSet__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.BeginMap(0)
}
func (_ValidatorSet__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.BeginList(0)
}
func (na *_ValidatorSet__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignNull()
}
func (_ValidatorSet__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignBool(false)
}
func (_ValidatorSet__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignInt(0)
}
func (_ValidatorSet__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ValidatorSet__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Validators":
		if ka.s&fieldBit__ValidatorSet_Validators != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Validators}
		}
		ka.s += fieldBit__ValidatorSet_Validators
		ka.state = maState_expectValue
		ka.f = 0
	case "Proposer":
		if ka.s&fieldBit__ValidatorSet_Proposer != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Proposer}
		}
		ka.s += fieldBit__ValidatorSet_Proposer
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorSet", Key: &_String{k}}
	}
	return nil
}
func (_ValidatorSet__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignBytes(nil)
}
func (_ValidatorSet__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ValidatorSet__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ValidatorSet__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ValidatorSet) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n ValidatorSet) Representation() ipld.Node {
	return (*_ValidatorSet__Repr)(n)
}

type _ValidatorSet__Repr _ValidatorSet

var (
	fieldName__ValidatorSet_Validators_serial = _String{"Validators"}
	fieldName__ValidatorSet_Proposer_serial   = _String{"Proposer"}
)
var _ ipld.Node = &_ValidatorSet__Repr{}

func (_ValidatorSet__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_ValidatorSet__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Validators":
		return n.Validators.Representation(), nil
	case "Proposer":
		return n.Proposer.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_ValidatorSet__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_ValidatorSet__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.LookupByIndex(0)
}
func (n _ValidatorSet__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_ValidatorSet__Repr) MapIterator() ipld.MapIterator {
	return &_ValidatorSet__ReprMapItr{n, 0}
}

type _ValidatorSet__ReprMapItr struct {
	n   *_ValidatorSet__Repr
	idx int
}

func (itr *_ValidatorSet__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__ValidatorSet_Validators_serial
		v = itr.n.Validators.Representation()
	case 1:
		k = &fieldName__ValidatorSet_Proposer_serial
		v = itr.n.Proposer.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_ValidatorSet__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_ValidatorSet__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_ValidatorSet__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_ValidatorSet__Repr) IsAbsent() bool {
	return false
}
func (_ValidatorSet__Repr) IsNull() bool {
	return false
}
func (_ValidatorSet__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsBool()
}
func (_ValidatorSet__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsInt()
}
func (_ValidatorSet__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsFloat()
}
func (_ValidatorSet__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsString()
}
func (_ValidatorSet__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsBytes()
}
func (_ValidatorSet__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.ValidatorSet.Repr"}.AsLink()
}
func (_ValidatorSet__Repr) Prototype() ipld.NodePrototype {
	return _ValidatorSet__ReprPrototype{}
}

type _ValidatorSet__ReprPrototype struct{}

func (_ValidatorSet__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _ValidatorSet__ReprBuilder
	nb.Reset()
	return &nb
}

type _ValidatorSet__ReprBuilder struct {
	_ValidatorSet__ReprAssembler
}

func (nb *_ValidatorSet__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ValidatorSet__ReprBuilder) Reset() {
	var w _ValidatorSet
	var m schema.Maybe
	*nb = _ValidatorSet__ReprBuilder{_ValidatorSet__ReprAssembler{w: &w, m: &m}}
}

type _ValidatorSet__ReprAssembler struct {
	w     *_ValidatorSet
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_Validators _Validators__ReprAssembler
	ca_Proposer   _Validator__ReprAssembler
}

func (na *_ValidatorSet__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Validators.reset()
	na.ca_Proposer.reset()
}
func (na *_ValidatorSet__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_ValidatorSet{}
	}
	return na, nil
}
func (_ValidatorSet__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.BeginList(0)
}
func (na *_ValidatorSet__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_ValidatorSet__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignBool(false)
}
func (_ValidatorSet__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignInt(0)
}
func (_ValidatorSet__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignFloat(0)
}
func (_ValidatorSet__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignString("")
}
func (_ValidatorSet__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignBytes(nil)
}
func (_ValidatorSet__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.ValidatorSet.Repr"}.AssignLink(nil)
}
func (na *_ValidatorSet__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ValidatorSet); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.ValidatorSet.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_ValidatorSet__ReprAssembler) Prototype() ipld.NodePrototype {
	return _ValidatorSet__ReprPrototype{}
}
func (ma *_ValidatorSet__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorSet__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Validators":
		if ma.s&fieldBit__ValidatorSet_Validators != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Validators_serial}
		}
		ma.s += fieldBit__ValidatorSet_Validators
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Validators.w = &ma.w.Validators
		ma.ca_Validators.m = &ma.cm
		return &ma.ca_Validators, nil
	case "Proposer":
		if ma.s&fieldBit__ValidatorSet_Proposer != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Proposer_serial}
		}
		ma.s += fieldBit__ValidatorSet_Proposer
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Proposer.w = &ma.w.Proposer
		ma.ca_Proposer.m = &ma.cm
		return &ma.ca_Proposer, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorSet.Repr", Key: &_String{k}}
}
func (ma *_ValidatorSet__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_ValidatorSet__ReprKeyAssembler)(ma)
}
func (ma *_ValidatorSet__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Validators.w = &ma.w.Validators
		ma.ca_Validators.m = &ma.cm
		return &ma.ca_Validators
	case 1:
		ma.ca_Proposer.w = &ma.w.Proposer
		ma.ca_Proposer.m = &ma.cm
		return &ma.ca_Proposer
	default:
		panic("unreachable")
	}
}
func (ma *_ValidatorSet__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__ValidatorSet_sufficient != fieldBits__ValidatorSet_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__ValidatorSet_Validators == 0 {
			err.Missing = append(err.Missing, "Validators")
		}
		if ma.s&fieldBit__ValidatorSet_Proposer == 0 {
			err.Missing = append(err.Missing, "Proposer")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_ValidatorSet__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_ValidatorSet__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _ValidatorSet__ReprKeyAssembler _ValidatorSet__ReprAssembler

func (_ValidatorSet__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.BeginMap(0)
}
func (_ValidatorSet__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_ValidatorSet__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignNull()
}
func (_ValidatorSet__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignBool(false)
}
func (_ValidatorSet__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignInt(0)
}
func (_ValidatorSet__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_ValidatorSet__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Validators":
		if ka.s&fieldBit__ValidatorSet_Validators != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Validators_serial}
		}
		ka.s += fieldBit__ValidatorSet_Validators
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Proposer":
		if ka.s&fieldBit__ValidatorSet_Proposer != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__ValidatorSet_Proposer_serial}
		}
		ka.s += fieldBit__ValidatorSet_Proposer
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.ValidatorSet.Repr", Key: &_String{k}}
}
func (_ValidatorSet__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_ValidatorSet__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.ValidatorSet.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_ValidatorSet__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_ValidatorSet__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_Validators) Lookup(idx int64) Validator {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Validators) LookupMaybe(idx int64) MaybeValidator {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Validator__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Validators__valueAbsent = _Validator__Maybe{m: schema.Maybe_Absent}

func (n Validators) Iterator() *Validators__Itr {
	return &Validators__Itr{n, 0}
}

type Validators__Itr struct {
	n   Validators
	idx int
}

func (itr *Validators__Itr) Next() (idx int64, v Validator) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Validators__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Validators__Maybe struct {
	m schema.Maybe
	v Validators
}
type MaybeValidators = *_Validators__Maybe

func (m MaybeValidators) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeValidators) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeValidators) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeValidators) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeValidators) Must() Validators {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Validators)(&_Validators{})
var _ schema.TypedNode = (Validators)(&_Validators{})

func (Validators) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Validators) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Validators"}.LookupByString("")
}
func (n Validators) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Validators) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Validators) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Validators", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Validators) MapIterator() ipld.MapIterator {
	return nil
}
func (n Validators) ListIterator() ipld.ListIterator {
	return &_Validators__ListItr{n, 0}
}

type _Validators__ListItr struct {
	n   Validators
	idx int
}

func (itr *_Validators__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Validators__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Validators) Length() int64 {
	return int64(len(n.x))
}
func (Validators) IsAbsent() bool {
	return false
}
func (Validators) IsNull() bool {
	return false
}
func (Validators) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Validators"}.AsBool()
}
func (Validators) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Validators"}.AsInt()
}
func (Validators) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Validators"}.AsFloat()
}
func (Validators) AsString() (string, error) {
	return mixins.List{"dagcosmos.Validators"}.AsString()
}
func (Validators) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Validators"}.AsBytes()
}
func (Validators) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Validators"}.AsLink()
}
func (Validators) Prototype() ipld.NodePrototype {
	return _Validators__Prototype{}
}

type _Validators__Prototype struct{}

func (_Validators__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Validators__Builder
	nb.Reset()
	return &nb
}

type _Validators__Builder struct {
	_Validators__Assembler
}

func (nb *_Validators__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Validators__Builder) Reset() {
	var w _Validators
	var m schema.Maybe
	*nb = _Validators__Builder{_Validators__Assembler{w: &w, m: &m}}
}

type _Validators__Assembler struct {
	w     *_Validators
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Validator__Assembler
}

func (na *_Validators__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Validators__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Validators"}.BeginMap(0)
}
func (na *_Validators__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Validators{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Validator, 0, sizeHint)
	}
	return na, nil
}
func (na *_Validators__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Validators"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Validators__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignBool(false)
}
func (_Validators__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignInt(0)
}
func (_Validators__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignFloat(0)
}
func (_Validators__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignString("")
}
func (_Validators__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignBytes(nil)
}
func (_Validators__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Validators"}.AssignLink(nil)
}
func (na *_Validators__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Validators); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Validators", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Validators__Assembler) Prototype() ipld.NodePrototype {
	return _Validators__Prototype{}
}
func (la *_Validators__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Validators__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Validator{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Validators__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Validators__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Validator__Prototype{}
}
func (Validators) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Validators) Representation() ipld.Node {
	return (*_Validators__Repr)(n)
}

type _Validators__Repr _Validators

var _ ipld.Node = &_Validators__Repr{}

func (_Validators__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Validators__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.LookupByString("")
}
func (nr *_Validators__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Validators)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Validator).Representation(), nil
}
func (nr *_Validators__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Validators)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Validator).Representation(), nil
}
func (n _Validators__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dagcosmos.Validators.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Validators__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Validators__Repr) ListIterator() ipld.ListIterator {
	return &_Validators__ReprListItr{(Validators)(nr), 0}
}

type _Validators__ReprListItr _Validators__ListItr

func (itr *_Validators__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Validators__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Validator).Representation(), nil
}
func (itr *_Validators__ReprListItr) Done() bool {
	return (*_Validators__ListItr)(itr).Done()
}

func (rn *_Validators__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Validators__Repr) IsAbsent() bool {
	return false
}
func (_Validators__Repr) IsNull() bool {
	return false
}
func (_Validators__Repr) AsBool() (bool, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsBool()
}
func (_Validators__Repr) AsInt() (int64, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsInt()
}
func (_Validators__Repr) AsFloat() (float64, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsFloat()
}
func (_Validators__Repr) AsString() (string, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsString()
}
func (_Validators__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsBytes()
}
func (_Validators__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dagcosmos.Validators.Repr"}.AsLink()
}
func (_Validators__Repr) Prototype() ipld.NodePrototype {
	return _Validators__ReprPrototype{}
}

type _Validators__ReprPrototype struct{}

func (_Validators__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Validators__ReprBuilder
	nb.Reset()
	return &nb
}

type _Validators__ReprBuilder struct {
	_Validators__ReprAssembler
}

func (nb *_Validators__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Validators__ReprBuilder) Reset() {
	var w _Validators
	var m schema.Maybe
	*nb = _Validators__ReprBuilder{_Validators__ReprAssembler{w: &w, m: &m}}
}

type _Validators__ReprAssembler struct {
	w     *_Validators
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Validator__ReprAssembler
}

func (na *_Validators__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Validators__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.BeginMap(0)
}
func (na *_Validators__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Validators{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Validator, 0, sizeHint)
	}
	return na, nil
}
func (na *_Validators__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dagcosmos.Validators.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Validators__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignBool(false)
}
func (_Validators__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignInt(0)
}
func (_Validators__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignFloat(0)
}
func (_Validators__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignString("")
}
func (_Validators__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignBytes(nil)
}
func (_Validators__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dagcosmos.Validators.Repr"}.AssignLink(nil)
}
func (na *_Validators__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Validators); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Validators.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Validators__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Validators__ReprPrototype{}
}
func (la *_Validators__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Validators__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Validator{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Validators__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Validators__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Validator__ReprPrototype{}
}

func (n _Version) FieldBlock() Uint {
	return &n.Block
}
func (n _Version) FieldApp() Uint {
	return &n.App
}

type _Version__Maybe struct {
	m schema.Maybe
	v Version
}
type MaybeVersion = *_Version__Maybe

func (m MaybeVersion) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeVersion) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeVersion) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeVersion) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeVersion) Must() Version {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Version_Block = _String{"Block"}
	fieldName__Version_App   = _String{"App"}
)
var _ ipld.Node = (Version)(&_Version{})
var _ schema.TypedNode = (Version)(&_Version{})

func (Version) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Version) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Block":
		return &n.Block, nil
	case "App":
		return &n.App, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Version) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Version) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Version"}.LookupByIndex(0)
}
func (n Version) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Version) MapIterator() ipld.MapIterator {
	return &_Version__MapItr{n, 0}
}

type _Version__MapItr struct {
	n   Version
	idx int
}

func (itr *_Version__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Version_Block
		v = &itr.n.Block
	case 1:
		k = &fieldName__Version_App
		v = &itr.n.App
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Version__MapItr) Done() bool {
	return itr.idx >= 2
}

func (Version) ListIterator() ipld.ListIterator {
	return nil
}
func (Version) Length() int64 {
	return 2
}
func (Version) IsAbsent() bool {
	return false
}
func (Version) IsNull() bool {
	return false
}
func (Version) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Version"}.AsBool()
}
func (Version) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Version"}.AsInt()
}
func (Version) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Version"}.AsFloat()
}
func (Version) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Version"}.AsString()
}
func (Version) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Version"}.AsBytes()
}
func (Version) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Version"}.AsLink()
}
func (Version) Prototype() ipld.NodePrototype {
	return _Version__Prototype{}
}

type _Version__Prototype struct{}

func (_Version__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Version__Builder
	nb.Reset()
	return &nb
}

type _Version__Builder struct {
	_Version__Assembler
}

func (nb *_Version__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Version__Builder) Reset() {
	var w _Version
	var m schema.Maybe
	*nb = _Version__Builder{_Version__Assembler{w: &w, m: &m}}
}

type _Version__Assembler struct {
	w     *_Version
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Block _Uint__Assembler
	ca_App   _Uint__Assembler
}

func (na *_Version__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Block.reset()
	na.ca_App.reset()
}

var (
	fieldBit__Version_Block       = 1 << 0
	fieldBit__Version_App         = 1 << 1
	fieldBits__Version_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_Version__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Version{}
	}
	return na, nil
}
func (_Version__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Version"}.BeginList(0)
}
func (na *_Version__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Version"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Version__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignBool(false)
}
func (_Version__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignInt(0)
}
func (_Version__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignFloat(0)
}
func (_Version__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignString("")
}
func (_Version__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignBytes(nil)
}
func (_Version__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Version"}.AssignLink(nil)
}
func (na *_Version__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Version); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Version", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Version__Assembler) Prototype() ipld.NodePrototype {
	return _Version__Prototype{}
}
func (ma *_Version__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Block.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_App.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Version__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Block":
		if ma.s&fieldBit__Version_Block != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Version_Block}
		}
		ma.s += fieldBit__Version_Block
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block, nil
	case "App":
		if ma.s&fieldBit__Version_App != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Version_App}
		}
		ma.s += fieldBit__Version_App
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_App.w = &ma.w.App
		ma.ca_App.m = &ma.cm
		return &ma.ca_App, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Version", Key: &_String{k}}
}
func (ma *_Version__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Version__KeyAssembler)(ma)
}
func (ma *_Version__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block
	case 1:
		ma.ca_App.w = &ma.w.App
		ma.ca_App.m = &ma.cm
		return &ma.ca_App
	default:
		panic("unreachable")
	}
}
func (ma *_Version__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Version_sufficient != fieldBits__Version_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Version_Block == 0 {
			err.Missing = append(err.Missing, "Block")
		}
		if ma.s&fieldBit__Version_App == 0 {
			err.Missing = append(err.Missing, "App")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Version__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Version__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Version__KeyAssembler _Version__Assembler

func (_Version__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.BeginMap(0)
}
func (_Version__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.BeginList(0)
}
func (na *_Version__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignNull()
}
func (_Version__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignBool(false)
}
func (_Version__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignInt(0)
}
func (_Version__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Version__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Block":
		if ka.s&fieldBit__Version_Block != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Version_Block}
		}
		ka.s += fieldBit__Version_Block
		ka.state = maState_expectValue
		ka.f = 0
	case "App":
		if ka.s&fieldBit__Version_App != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Version_App}
		}
		ka.s += fieldBit__Version_App
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Version", Key: &_String{k}}
	}
	return nil
}
func (_Version__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignBytes(nil)
}
func (_Version__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Version.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Version__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Version__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Version) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Version) Representation() ipld.Node {
	return (*_Version__Repr)(n)
}

type _Version__Repr _Version

var (
	fieldName__Version_Block_serial = _String{"Block"}
	fieldName__Version_App_serial   = _String{"App"}
)
var _ ipld.Node = &_Version__Repr{}

func (_Version__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Version__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Block":
		return n.Block.Representation(), nil
	case "App":
		return n.App.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Version__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Version__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.LookupByIndex(0)
}
func (n _Version__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Version__Repr) MapIterator() ipld.MapIterator {
	return &_Version__ReprMapItr{n, 0}
}

type _Version__ReprMapItr struct {
	n   *_Version__Repr
	idx int
}

func (itr *_Version__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Version_Block_serial
		v = itr.n.Block.Representation()
	case 1:
		k = &fieldName__Version_App_serial
		v = itr.n.App.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Version__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_Version__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Version__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_Version__Repr) IsAbsent() bool {
	return false
}
func (_Version__Repr) IsNull() bool {
	return false
}
func (_Version__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsBool()
}
func (_Version__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsInt()
}
func (_Version__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsFloat()
}
func (_Version__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsString()
}
func (_Version__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsBytes()
}
func (_Version__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Version.Repr"}.AsLink()
}
func (_Version__Repr) Prototype() ipld.NodePrototype {
	return _Version__ReprPrototype{}
}

type _Version__ReprPrototype struct{}

func (_Version__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Version__ReprBuilder
	nb.Reset()
	return &nb
}

type _Version__ReprBuilder struct {
	_Version__ReprAssembler
}

func (nb *_Version__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Version__ReprBuilder) Reset() {
	var w _Version
	var m schema.Maybe
	*nb = _Version__ReprBuilder{_Version__ReprAssembler{w: &w, m: &m}}
}

type _Version__ReprAssembler struct {
	w     *_Version
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Block _Uint__ReprAssembler
	ca_App   _Uint__ReprAssembler
}

func (na *_Version__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Block.reset()
	na.ca_App.reset()
}
func (na *_Version__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Version{}
	}
	return na, nil
}
func (_Version__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.BeginList(0)
}
func (na *_Version__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Version.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Version__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignBool(false)
}
func (_Version__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignInt(0)
}
func (_Version__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignFloat(0)
}
func (_Version__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignString("")
}
func (_Version__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignBytes(nil)
}
func (_Version__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Version.Repr"}.AssignLink(nil)
}
func (na *_Version__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Version); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Version.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Version__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Version__ReprPrototype{}
}
func (ma *_Version__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Version__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Block":
		if ma.s&fieldBit__Version_Block != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Version_Block_serial}
		}
		ma.s += fieldBit__Version_Block
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block, nil
	case "App":
		if ma.s&fieldBit__Version_App != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Version_App_serial}
		}
		ma.s += fieldBit__Version_App
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_App.w = &ma.w.App
		ma.ca_App.m = &ma.cm
		return &ma.ca_App, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Version.Repr", Key: &_String{k}}
}
func (ma *_Version__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Version__ReprKeyAssembler)(ma)
}
func (ma *_Version__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Block.w = &ma.w.Block
		ma.ca_Block.m = &ma.cm
		return &ma.ca_Block
	case 1:
		ma.ca_App.w = &ma.w.App
		ma.ca_App.m = &ma.cm
		return &ma.ca_App
	default:
		panic("unreachable")
	}
}
func (ma *_Version__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Version_sufficient != fieldBits__Version_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Version_Block == 0 {
			err.Missing = append(err.Missing, "Block")
		}
		if ma.s&fieldBit__Version_App == 0 {
			err.Missing = append(err.Missing, "App")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Version__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Version__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Version__ReprKeyAssembler _Version__ReprAssembler

func (_Version__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Version__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Version__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignNull()
}
func (_Version__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Version__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Version__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Version__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Block":
		if ka.s&fieldBit__Version_Block != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Version_Block_serial}
		}
		ka.s += fieldBit__Version_Block
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "App":
		if ka.s&fieldBit__Version_App != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Version_App_serial}
		}
		ka.s += fieldBit__Version_App
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Version.Repr", Key: &_String{k}}
}
func (_Version__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Version__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Version.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Version__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Version__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _VersionParams) FieldAppVersion() Uint {
	return &n.AppVersion
}

type _VersionParams__Maybe struct {
	m schema.Maybe
	v VersionParams
}
type MaybeVersionParams = *_VersionParams__Maybe

func (m MaybeVersionParams) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeVersionParams) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeVersionParams) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeVersionParams) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeVersionParams) Must() VersionParams {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__VersionParams_AppVersion = _String{"AppVersion"}
)
var _ ipld.Node = (VersionParams)(&_VersionParams{})
var _ schema.TypedNode = (VersionParams)(&_VersionParams{})

func (VersionParams) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n VersionParams) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "AppVersion":
		return &n.AppVersion, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n VersionParams) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (VersionParams) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.VersionParams"}.LookupByIndex(0)
}
func (n VersionParams) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n VersionParams) MapIterator() ipld.MapIterator {
	return &_VersionParams__MapItr{n, 0}
}

type _VersionParams__MapItr struct {
	n   VersionParams
	idx int
}

func (itr *_VersionParams__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__VersionParams_AppVersion
		v = &itr.n.AppVersion
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_VersionParams__MapItr) Done() bool {
	return itr.idx >= 1
}

func (VersionParams) ListIterator() ipld.ListIterator {
	return nil
}
func (VersionParams) Length() int64 {
	return 1
}
func (VersionParams) IsAbsent() bool {
	return false
}
func (VersionParams) IsNull() bool {
	return false
}
func (VersionParams) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.VersionParams"}.AsBool()
}
func (VersionParams) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.VersionParams"}.AsInt()
}
func (VersionParams) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.VersionParams"}.AsFloat()
}
func (VersionParams) AsString() (string, error) {
	return mixins.Map{"dagcosmos.VersionParams"}.AsString()
}
func (VersionParams) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.VersionParams"}.AsBytes()
}
func (VersionParams) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.VersionParams"}.AsLink()
}
func (VersionParams) Prototype() ipld.NodePrototype {
	return _VersionParams__Prototype{}
}

type _VersionParams__Prototype struct{}

func (_VersionParams__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _VersionParams__Builder
	nb.Reset()
	return &nb
}

type _VersionParams__Builder struct {
	_VersionParams__Assembler
}

func (nb *_VersionParams__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_VersionParams__Builder) Reset() {
	var w _VersionParams
	var m schema.Maybe
	*nb = _VersionParams__Builder{_VersionParams__Assembler{w: &w, m: &m}}
}

type _VersionParams__Assembler struct {
	w     *_VersionParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_AppVersion _Uint__Assembler
}

func (na *_VersionParams__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_AppVersion.reset()
}

var (
	fieldBit__VersionParams_AppVersion  = 1 << 0
	fieldBits__VersionParams_sufficient = 0 + 1<<0
)

func (na *_VersionParams__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_VersionParams{}
	}
	return na, nil
}
func (_VersionParams__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.VersionParams"}.BeginList(0)
}
func (na *_VersionParams__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.VersionParams"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_VersionParams__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams"}.AssignBool(false)
}
func (_VersionParams__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams"}.AssignInt(0)
}
func (_VersionParams__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams"}.AssignFloat(0)
}
func (_VersionParams__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams"}.AssignString("")
}
func (_VersionParams__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams"}.AssignBytes(nil)
}
func (_VersionParams__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams"}.AssignLink(nil)
}
func (na *_VersionParams__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_VersionParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.VersionParams", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_VersionParams__Assembler) Prototype() ipld.NodePrototype {
	return _VersionParams__Prototype{}
}
func (ma *_VersionParams__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_AppVersion.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_VersionParams__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "AppVersion":
		if ma.s&fieldBit__VersionParams_AppVersion != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__VersionParams_AppVersion}
		}
		ma.s += fieldBit__VersionParams_AppVersion
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_AppVersion.w = &ma.w.AppVersion
		ma.ca_AppVersion.m = &ma.cm
		return &ma.ca_AppVersion, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.VersionParams", Key: &_String{k}}
}
func (ma *_VersionParams__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_VersionParams__KeyAssembler)(ma)
}
func (ma *_VersionParams__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_AppVersion.w = &ma.w.AppVersion
		ma.ca_AppVersion.m = &ma.cm
		return &ma.ca_AppVersion
	default:
		panic("unreachable")
	}
}
func (ma *_VersionParams__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__VersionParams_sufficient != fieldBits__VersionParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__VersionParams_AppVersion == 0 {
			err.Missing = append(err.Missing, "AppVersion")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_VersionParams__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_VersionParams__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _VersionParams__KeyAssembler _VersionParams__Assembler

func (_VersionParams__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.VersionParams.KeyAssembler"}.BeginMap(0)
}
func (_VersionParams__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.VersionParams.KeyAssembler"}.BeginList(0)
}
func (na *_VersionParams__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.KeyAssembler"}.AssignNull()
}
func (_VersionParams__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.KeyAssembler"}.AssignBool(false)
}
func (_VersionParams__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.KeyAssembler"}.AssignInt(0)
}
func (_VersionParams__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.KeyAssembler"}.AssignFloat(0)
}
func (ka *_VersionParams__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "AppVersion":
		if ka.s&fieldBit__VersionParams_AppVersion != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__VersionParams_AppVersion}
		}
		ka.s += fieldBit__VersionParams_AppVersion
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.VersionParams", Key: &_String{k}}
	}
	return nil
}
func (_VersionParams__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.KeyAssembler"}.AssignBytes(nil)
}
func (_VersionParams__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.KeyAssembler"}.AssignLink(nil)
}
func (ka *_VersionParams__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_VersionParams__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (VersionParams) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n VersionParams) Representation() ipld.Node {
	return (*_VersionParams__Repr)(n)
}

type _VersionParams__Repr _VersionParams

var (
	fieldName__VersionParams_AppVersion_serial = _String{"AppVersion"}
)
var _ ipld.Node = &_VersionParams__Repr{}

func (_VersionParams__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_VersionParams__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "AppVersion":
		return n.AppVersion.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_VersionParams__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_VersionParams__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.VersionParams.Repr"}.LookupByIndex(0)
}
func (n _VersionParams__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_VersionParams__Repr) MapIterator() ipld.MapIterator {
	return &_VersionParams__ReprMapItr{n, 0}
}

type _VersionParams__ReprMapItr struct {
	n   *_VersionParams__Repr
	idx int
}

func (itr *_VersionParams__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__VersionParams_AppVersion_serial
		v = itr.n.AppVersion.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_VersionParams__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_VersionParams__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_VersionParams__Repr) Length() int64 {
	l := 1
	return int64(l)
}
func (_VersionParams__Repr) IsAbsent() bool {
	return false
}
func (_VersionParams__Repr) IsNull() bool {
	return false
}
func (_VersionParams__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.VersionParams.Repr"}.AsBool()
}
func (_VersionParams__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.VersionParams.Repr"}.AsInt()
}
func (_VersionParams__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.VersionParams.Repr"}.AsFloat()
}
func (_VersionParams__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.VersionParams.Repr"}.AsString()
}
func (_VersionParams__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.VersionParams.Repr"}.AsBytes()
}
func (_VersionParams__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.VersionParams.Repr"}.AsLink()
}
func (_VersionParams__Repr) Prototype() ipld.NodePrototype {
	return _VersionParams__ReprPrototype{}
}

type _VersionParams__ReprPrototype struct{}

func (_VersionParams__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _VersionParams__ReprBuilder
	nb.Reset()
	return &nb
}

type _VersionParams__ReprBuilder struct {
	_VersionParams__ReprAssembler
}

func (nb *_VersionParams__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_VersionParams__ReprBuilder) Reset() {
	var w _VersionParams
	var m schema.Maybe
	*nb = _VersionParams__ReprBuilder{_VersionParams__ReprAssembler{w: &w, m: &m}}
}

type _VersionParams__ReprAssembler struct {
	w     *_VersionParams
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm            schema.Maybe
	ca_AppVersion _Uint__ReprAssembler
}

func (na *_VersionParams__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_AppVersion.reset()
}
func (na *_VersionParams__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_VersionParams{}
	}
	return na, nil
}
func (_VersionParams__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.VersionParams.Repr"}.BeginList(0)
}
func (na *_VersionParams__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.VersionParams.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_VersionParams__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams.Repr"}.AssignBool(false)
}
func (_VersionParams__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams.Repr"}.AssignInt(0)
}
func (_VersionParams__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams.Repr"}.AssignFloat(0)
}
func (_VersionParams__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams.Repr"}.AssignString("")
}
func (_VersionParams__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams.Repr"}.AssignBytes(nil)
}
func (_VersionParams__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.VersionParams.Repr"}.AssignLink(nil)
}
func (na *_VersionParams__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_VersionParams); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.VersionParams.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_VersionParams__ReprAssembler) Prototype() ipld.NodePrototype {
	return _VersionParams__ReprPrototype{}
}
func (ma *_VersionParams__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_VersionParams__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "AppVersion":
		if ma.s&fieldBit__VersionParams_AppVersion != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__VersionParams_AppVersion_serial}
		}
		ma.s += fieldBit__VersionParams_AppVersion
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_AppVersion.w = &ma.w.AppVersion
		ma.ca_AppVersion.m = &ma.cm
		return &ma.ca_AppVersion, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.VersionParams.Repr", Key: &_String{k}}
}
func (ma *_VersionParams__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_VersionParams__ReprKeyAssembler)(ma)
}
func (ma *_VersionParams__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_AppVersion.w = &ma.w.AppVersion
		ma.ca_AppVersion.m = &ma.cm
		return &ma.ca_AppVersion
	default:
		panic("unreachable")
	}
}
func (ma *_VersionParams__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__VersionParams_sufficient != fieldBits__VersionParams_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__VersionParams_AppVersion == 0 {
			err.Missing = append(err.Missing, "AppVersion")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_VersionParams__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_VersionParams__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _VersionParams__ReprKeyAssembler _VersionParams__ReprAssembler

func (_VersionParams__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.VersionParams.Repr.KeyAssembler"}.BeginMap(0)
}
func (_VersionParams__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.VersionParams.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_VersionParams__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.Repr.KeyAssembler"}.AssignNull()
}
func (_VersionParams__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.Repr.KeyAssembler"}.AssignBool(false)
}
func (_VersionParams__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.Repr.KeyAssembler"}.AssignInt(0)
}
func (_VersionParams__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_VersionParams__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "AppVersion":
		if ka.s&fieldBit__VersionParams_AppVersion != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__VersionParams_AppVersion_serial}
		}
		ka.s += fieldBit__VersionParams_AppVersion
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.VersionParams.Repr", Key: &_String{k}}
}
func (_VersionParams__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_VersionParams__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.VersionParams.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_VersionParams__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_VersionParams__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _Vote) FieldType() SignedMsgType {
	return &n.Type
}
func (n _Vote) FieldHeight() Int {
	return &n.Height
}
func (n _Vote) FieldRound() Int {
	return &n.Round
}
func (n _Vote) FieldBlockID() BlockID {
	return &n.BlockID
}
func (n _Vote) FieldTimestamp() Time {
	return &n.Timestamp
}
func (n _Vote) FieldValidatorAddress() Address {
	return &n.ValidatorAddress
}
func (n _Vote) FieldValidatorIndex() Int {
	return &n.ValidatorIndex
}
func (n _Vote) FieldSignature() Signature {
	return &n.Signature
}

type _Vote__Maybe struct {
	m schema.Maybe
	v Vote
}
type MaybeVote = *_Vote__Maybe

func (m MaybeVote) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeVote) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeVote) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeVote) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeVote) Must() Vote {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Vote_Type             = _String{"Type"}
	fieldName__Vote_Height           = _String{"Height"}
	fieldName__Vote_Round            = _String{"Round"}
	fieldName__Vote_BlockID          = _String{"BlockID"}
	fieldName__Vote_Timestamp        = _String{"Timestamp"}
	fieldName__Vote_ValidatorAddress = _String{"ValidatorAddress"}
	fieldName__Vote_ValidatorIndex   = _String{"ValidatorIndex"}
	fieldName__Vote_Signature        = _String{"Signature"}
)
var _ ipld.Node = (Vote)(&_Vote{})
var _ schema.TypedNode = (Vote)(&_Vote{})

func (Vote) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Vote) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Type":
		return &n.Type, nil
	case "Height":
		return &n.Height, nil
	case "Round":
		return &n.Round, nil
	case "BlockID":
		return &n.BlockID, nil
	case "Timestamp":
		return &n.Timestamp, nil
	case "ValidatorAddress":
		return &n.ValidatorAddress, nil
	case "ValidatorIndex":
		return &n.ValidatorIndex, nil
	case "Signature":
		return &n.Signature, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Vote) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Vote) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Vote"}.LookupByIndex(0)
}
func (n Vote) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Vote) MapIterator() ipld.MapIterator {
	return &_Vote__MapItr{n, 0}
}

type _Vote__MapItr struct {
	n   Vote
	idx int
}

func (itr *_Vote__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 8 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Vote_Type
		v = &itr.n.Type
	case 1:
		k = &fieldName__Vote_Height
		v = &itr.n.Height
	case 2:
		k = &fieldName__Vote_Round
		v = &itr.n.Round
	case 3:
		k = &fieldName__Vote_BlockID
		v = &itr.n.BlockID
	case 4:
		k = &fieldName__Vote_Timestamp
		v = &itr.n.Timestamp
	case 5:
		k = &fieldName__Vote_ValidatorAddress
		v = &itr.n.ValidatorAddress
	case 6:
		k = &fieldName__Vote_ValidatorIndex
		v = &itr.n.ValidatorIndex
	case 7:
		k = &fieldName__Vote_Signature
		v = &itr.n.Signature
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Vote__MapItr) Done() bool {
	return itr.idx >= 8
}

func (Vote) ListIterator() ipld.ListIterator {
	return nil
}
func (Vote) Length() int64 {
	return 8
}
func (Vote) IsAbsent() bool {
	return false
}
func (Vote) IsNull() bool {
	return false
}
func (Vote) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsBool()
}
func (Vote) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsInt()
}
func (Vote) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsFloat()
}
func (Vote) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsString()
}
func (Vote) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsBytes()
}
func (Vote) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Vote"}.AsLink()
}
func (Vote) Prototype() ipld.NodePrototype {
	return _Vote__Prototype{}
}

type _Vote__Prototype struct{}

func (_Vote__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Vote__Builder
	nb.Reset()
	return &nb
}

type _Vote__Builder struct {
	_Vote__Assembler
}

func (nb *_Vote__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Vote__Builder) Reset() {
	var w _Vote
	var m schema.Maybe
	*nb = _Vote__Builder{_Vote__Assembler{w: &w, m: &m}}
}

type _Vote__Assembler struct {
	w     *_Vote
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_Type             _SignedMsgType__Assembler
	ca_Height           _Int__Assembler
	ca_Round            _Int__Assembler
	ca_BlockID          _BlockID__Assembler
	ca_Timestamp        _Time__Assembler
	ca_ValidatorAddress _Address__Assembler
	ca_ValidatorIndex   _Int__Assembler
	ca_Signature        _Signature__Assembler
}

func (na *_Vote__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Type.reset()
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_BlockID.reset()
	na.ca_Timestamp.reset()
	na.ca_ValidatorAddress.reset()
	na.ca_ValidatorIndex.reset()
	na.ca_Signature.reset()
}

var (
	fieldBit__Vote_Type             = 1 << 0
	fieldBit__Vote_Height           = 1 << 1
	fieldBit__Vote_Round            = 1 << 2
	fieldBit__Vote_BlockID          = 1 << 3
	fieldBit__Vote_Timestamp        = 1 << 4
	fieldBit__Vote_ValidatorAddress = 1 << 5
	fieldBit__Vote_ValidatorIndex   = 1 << 6
	fieldBit__Vote_Signature        = 1 << 7
	fieldBits__Vote_sufficient      = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6 + 1<<7
)

func (na *_Vote__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Vote{}
	}
	return na, nil
}
func (_Vote__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Vote"}.BeginList(0)
}
func (na *_Vote__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Vote"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Vote__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignBool(false)
}
func (_Vote__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignInt(0)
}
func (_Vote__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignFloat(0)
}
func (_Vote__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignString("")
}
func (_Vote__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignBytes(nil)
}
func (_Vote__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Vote"}.AssignLink(nil)
}
func (na *_Vote__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Vote); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Vote", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Vote__Assembler) Prototype() ipld.NodePrototype {
	return _Vote__Prototype{}
}
func (ma *_Vote__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Type.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Height.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Round.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_BlockID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Timestamp.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorAddress.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ValidatorIndex.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Signature.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Vote__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Type":
		if ma.s&fieldBit__Vote_Type != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Type}
		}
		ma.s += fieldBit__Vote_Type
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Type.w = &ma.w.Type
		ma.ca_Type.m = &ma.cm
		return &ma.ca_Type, nil
	case "Height":
		if ma.s&fieldBit__Vote_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Height}
		}
		ma.s += fieldBit__Vote_Height
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Vote_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Round}
		}
		ma.s += fieldBit__Vote_Round
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "BlockID":
		if ma.s&fieldBit__Vote_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_BlockID}
		}
		ma.s += fieldBit__Vote_BlockID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Timestamp":
		if ma.s&fieldBit__Vote_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Timestamp}
		}
		ma.s += fieldBit__Vote_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "ValidatorAddress":
		if ma.s&fieldBit__Vote_ValidatorAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorAddress}
		}
		ma.s += fieldBit__Vote_ValidatorAddress
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress, nil
	case "ValidatorIndex":
		if ma.s&fieldBit__Vote_ValidatorIndex != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorIndex}
		}
		ma.s += fieldBit__Vote_ValidatorIndex
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_ValidatorIndex.w = &ma.w.ValidatorIndex
		ma.ca_ValidatorIndex.m = &ma.cm
		return &ma.ca_ValidatorIndex, nil
	case "Signature":
		if ma.s&fieldBit__Vote_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Signature}
		}
		ma.s += fieldBit__Vote_Signature
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Vote", Key: &_String{k}}
}
func (ma *_Vote__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Vote__KeyAssembler)(ma)
}
func (ma *_Vote__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Type.w = &ma.w.Type
		ma.ca_Type.m = &ma.cm
		return &ma.ca_Type
	case 1:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 2:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 3:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 5:
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress
	case 6:
		ma.ca_ValidatorIndex.w = &ma.w.ValidatorIndex
		ma.ca_ValidatorIndex.m = &ma.cm
		return &ma.ca_ValidatorIndex
	case 7:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_Vote__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Vote_sufficient != fieldBits__Vote_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Vote_Type == 0 {
			err.Missing = append(err.Missing, "Type")
		}
		if ma.s&fieldBit__Vote_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Vote_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Vote_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Vote_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__Vote_ValidatorAddress == 0 {
			err.Missing = append(err.Missing, "ValidatorAddress")
		}
		if ma.s&fieldBit__Vote_ValidatorIndex == 0 {
			err.Missing = append(err.Missing, "ValidatorIndex")
		}
		if ma.s&fieldBit__Vote_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Vote__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Vote__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Vote__KeyAssembler _Vote__Assembler

func (_Vote__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.BeginMap(0)
}
func (_Vote__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.BeginList(0)
}
func (na *_Vote__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignNull()
}
func (_Vote__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignBool(false)
}
func (_Vote__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignInt(0)
}
func (_Vote__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Vote__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Type":
		if ka.s&fieldBit__Vote_Type != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Type}
		}
		ka.s += fieldBit__Vote_Type
		ka.state = maState_expectValue
		ka.f = 0
	case "Height":
		if ka.s&fieldBit__Vote_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Height}
		}
		ka.s += fieldBit__Vote_Height
		ka.state = maState_expectValue
		ka.f = 1
	case "Round":
		if ka.s&fieldBit__Vote_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Round}
		}
		ka.s += fieldBit__Vote_Round
		ka.state = maState_expectValue
		ka.f = 2
	case "BlockID":
		if ka.s&fieldBit__Vote_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_BlockID}
		}
		ka.s += fieldBit__Vote_BlockID
		ka.state = maState_expectValue
		ka.f = 3
	case "Timestamp":
		if ka.s&fieldBit__Vote_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Timestamp}
		}
		ka.s += fieldBit__Vote_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
	case "ValidatorAddress":
		if ka.s&fieldBit__Vote_ValidatorAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorAddress}
		}
		ka.s += fieldBit__Vote_ValidatorAddress
		ka.state = maState_expectValue
		ka.f = 5
	case "ValidatorIndex":
		if ka.s&fieldBit__Vote_ValidatorIndex != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorIndex}
		}
		ka.s += fieldBit__Vote_ValidatorIndex
		ka.state = maState_expectValue
		ka.f = 6
	case "Signature":
		if ka.s&fieldBit__Vote_Signature != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Signature}
		}
		ka.s += fieldBit__Vote_Signature
		ka.state = maState_expectValue
		ka.f = 7
	default:
		return ipld.ErrInvalidKey{TypeName: "dagcosmos.Vote", Key: &_String{k}}
	}
	return nil
}
func (_Vote__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignBytes(nil)
}
func (_Vote__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Vote.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Vote__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Vote__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Vote) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Vote) Representation() ipld.Node {
	return (*_Vote__Repr)(n)
}

type _Vote__Repr _Vote

var (
	fieldName__Vote_Type_serial             = _String{"Type"}
	fieldName__Vote_Height_serial           = _String{"Height"}
	fieldName__Vote_Round_serial            = _String{"Round"}
	fieldName__Vote_BlockID_serial          = _String{"BlockID"}
	fieldName__Vote_Timestamp_serial        = _String{"Timestamp"}
	fieldName__Vote_ValidatorAddress_serial = _String{"ValidatorAddress"}
	fieldName__Vote_ValidatorIndex_serial   = _String{"ValidatorIndex"}
	fieldName__Vote_Signature_serial        = _String{"Signature"}
)
var _ ipld.Node = &_Vote__Repr{}

func (_Vote__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Vote__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Type":
		return n.Type.Representation(), nil
	case "Height":
		return n.Height.Representation(), nil
	case "Round":
		return n.Round.Representation(), nil
	case "BlockID":
		return n.BlockID.Representation(), nil
	case "Timestamp":
		return n.Timestamp.Representation(), nil
	case "ValidatorAddress":
		return n.ValidatorAddress.Representation(), nil
	case "ValidatorIndex":
		return n.ValidatorIndex.Representation(), nil
	case "Signature":
		return n.Signature.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Vote__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Vote__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.LookupByIndex(0)
}
func (n _Vote__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Vote__Repr) MapIterator() ipld.MapIterator {
	return &_Vote__ReprMapItr{n, 0}
}

type _Vote__ReprMapItr struct {
	n   *_Vote__Repr
	idx int
}

func (itr *_Vote__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 8 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Vote_Type_serial
		v = itr.n.Type.Representation()
	case 1:
		k = &fieldName__Vote_Height_serial
		v = itr.n.Height.Representation()
	case 2:
		k = &fieldName__Vote_Round_serial
		v = itr.n.Round.Representation()
	case 3:
		k = &fieldName__Vote_BlockID_serial
		v = itr.n.BlockID.Representation()
	case 4:
		k = &fieldName__Vote_Timestamp_serial
		v = itr.n.Timestamp.Representation()
	case 5:
		k = &fieldName__Vote_ValidatorAddress_serial
		v = itr.n.ValidatorAddress.Representation()
	case 6:
		k = &fieldName__Vote_ValidatorIndex_serial
		v = itr.n.ValidatorIndex.Representation()
	case 7:
		k = &fieldName__Vote_Signature_serial
		v = itr.n.Signature.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Vote__ReprMapItr) Done() bool {
	return itr.idx >= 8
}
func (_Vote__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Vote__Repr) Length() int64 {
	l := 8
	return int64(l)
}
func (_Vote__Repr) IsAbsent() bool {
	return false
}
func (_Vote__Repr) IsNull() bool {
	return false
}
func (_Vote__Repr) AsBool() (bool, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsBool()
}
func (_Vote__Repr) AsInt() (int64, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsInt()
}
func (_Vote__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsFloat()
}
func (_Vote__Repr) AsString() (string, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsString()
}
func (_Vote__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsBytes()
}
func (_Vote__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dagcosmos.Vote.Repr"}.AsLink()
}
func (_Vote__Repr) Prototype() ipld.NodePrototype {
	return _Vote__ReprPrototype{}
}

type _Vote__ReprPrototype struct{}

func (_Vote__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Vote__ReprBuilder
	nb.Reset()
	return &nb
}

type _Vote__ReprBuilder struct {
	_Vote__ReprAssembler
}

func (nb *_Vote__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Vote__ReprBuilder) Reset() {
	var w _Vote
	var m schema.Maybe
	*nb = _Vote__ReprBuilder{_Vote__ReprAssembler{w: &w, m: &m}}
}

type _Vote__ReprAssembler struct {
	w     *_Vote
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                  schema.Maybe
	ca_Type             _SignedMsgType__ReprAssembler
	ca_Height           _Int__ReprAssembler
	ca_Round            _Int__ReprAssembler
	ca_BlockID          _BlockID__ReprAssembler
	ca_Timestamp        _Time__ReprAssembler
	ca_ValidatorAddress _Address__ReprAssembler
	ca_ValidatorIndex   _Int__ReprAssembler
	ca_Signature        _Signature__ReprAssembler
}

func (na *_Vote__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Type.reset()
	na.ca_Height.reset()
	na.ca_Round.reset()
	na.ca_BlockID.reset()
	na.ca_Timestamp.reset()
	na.ca_ValidatorAddress.reset()
	na.ca_ValidatorIndex.reset()
	na.ca_Signature.reset()
}
func (na *_Vote__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Vote{}
	}
	return na, nil
}
func (_Vote__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.BeginList(0)
}
func (na *_Vote__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dagcosmos.Vote.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Vote__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignBool(false)
}
func (_Vote__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignInt(0)
}
func (_Vote__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignFloat(0)
}
func (_Vote__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignString("")
}
func (_Vote__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignBytes(nil)
}
func (_Vote__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dagcosmos.Vote.Repr"}.AssignLink(nil)
}
func (na *_Vote__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Vote); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dagcosmos.Vote.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Vote__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Vote__ReprPrototype{}
}
func (ma *_Vote__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Vote__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Type":
		if ma.s&fieldBit__Vote_Type != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Type_serial}
		}
		ma.s += fieldBit__Vote_Type
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Type.w = &ma.w.Type
		ma.ca_Type.m = &ma.cm
		return &ma.ca_Type, nil
	case "Height":
		if ma.s&fieldBit__Vote_Height != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Height_serial}
		}
		ma.s += fieldBit__Vote_Height
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height, nil
	case "Round":
		if ma.s&fieldBit__Vote_Round != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Round_serial}
		}
		ma.s += fieldBit__Vote_Round
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round, nil
	case "BlockID":
		if ma.s&fieldBit__Vote_BlockID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_BlockID_serial}
		}
		ma.s += fieldBit__Vote_BlockID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID, nil
	case "Timestamp":
		if ma.s&fieldBit__Vote_Timestamp != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Timestamp_serial}
		}
		ma.s += fieldBit__Vote_Timestamp
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp, nil
	case "ValidatorAddress":
		if ma.s&fieldBit__Vote_ValidatorAddress != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorAddress_serial}
		}
		ma.s += fieldBit__Vote_ValidatorAddress
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress, nil
	case "ValidatorIndex":
		if ma.s&fieldBit__Vote_ValidatorIndex != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorIndex_serial}
		}
		ma.s += fieldBit__Vote_ValidatorIndex
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_ValidatorIndex.w = &ma.w.ValidatorIndex
		ma.ca_ValidatorIndex.m = &ma.cm
		return &ma.ca_ValidatorIndex, nil
	case "Signature":
		if ma.s&fieldBit__Vote_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Signature_serial}
		}
		ma.s += fieldBit__Vote_Signature
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dagcosmos.Vote.Repr", Key: &_String{k}}
}
func (ma *_Vote__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Vote__ReprKeyAssembler)(ma)
}
func (ma *_Vote__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Type.w = &ma.w.Type
		ma.ca_Type.m = &ma.cm
		return &ma.ca_Type
	case 1:
		ma.ca_Height.w = &ma.w.Height
		ma.ca_Height.m = &ma.cm
		return &ma.ca_Height
	case 2:
		ma.ca_Round.w = &ma.w.Round
		ma.ca_Round.m = &ma.cm
		return &ma.ca_Round
	case 3:
		ma.ca_BlockID.w = &ma.w.BlockID
		ma.ca_BlockID.m = &ma.cm
		return &ma.ca_BlockID
	case 4:
		ma.ca_Timestamp.w = &ma.w.Timestamp
		ma.ca_Timestamp.m = &ma.cm
		return &ma.ca_Timestamp
	case 5:
		ma.ca_ValidatorAddress.w = &ma.w.ValidatorAddress
		ma.ca_ValidatorAddress.m = &ma.cm
		return &ma.ca_ValidatorAddress
	case 6:
		ma.ca_ValidatorIndex.w = &ma.w.ValidatorIndex
		ma.ca_ValidatorIndex.m = &ma.cm
		return &ma.ca_ValidatorIndex
	case 7:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_Vote__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Vote_sufficient != fieldBits__Vote_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Vote_Type == 0 {
			err.Missing = append(err.Missing, "Type")
		}
		if ma.s&fieldBit__Vote_Height == 0 {
			err.Missing = append(err.Missing, "Height")
		}
		if ma.s&fieldBit__Vote_Round == 0 {
			err.Missing = append(err.Missing, "Round")
		}
		if ma.s&fieldBit__Vote_BlockID == 0 {
			err.Missing = append(err.Missing, "BlockID")
		}
		if ma.s&fieldBit__Vote_Timestamp == 0 {
			err.Missing = append(err.Missing, "Timestamp")
		}
		if ma.s&fieldBit__Vote_ValidatorAddress == 0 {
			err.Missing = append(err.Missing, "ValidatorAddress")
		}
		if ma.s&fieldBit__Vote_ValidatorIndex == 0 {
			err.Missing = append(err.Missing, "ValidatorIndex")
		}
		if ma.s&fieldBit__Vote_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Vote__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Vote__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Vote__ReprKeyAssembler _Vote__ReprAssembler

func (_Vote__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Vote__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Vote__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignNull()
}
func (_Vote__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Vote__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Vote__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Vote__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Type":
		if ka.s&fieldBit__Vote_Type != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Type_serial}
		}
		ka.s += fieldBit__Vote_Type
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Height":
		if ka.s&fieldBit__Vote_Height != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Height_serial}
		}
		ka.s += fieldBit__Vote_Height
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Round":
		if ka.s&fieldBit__Vote_Round != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Round_serial}
		}
		ka.s += fieldBit__Vote_Round
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "BlockID":
		if ka.s&fieldBit__Vote_BlockID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_BlockID_serial}
		}
		ka.s += fieldBit__Vote_BlockID
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Timestamp":
		if ka.s&fieldBit__Vote_Timestamp != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Timestamp_serial}
		}
		ka.s += fieldBit__Vote_Timestamp
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "ValidatorAddress":
		if ka.s&fieldBit__Vote_ValidatorAddress != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorAddress_serial}
		}
		ka.s += fieldBit__Vote_ValidatorAddress
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "ValidatorIndex":
		if ka.s&fieldBit__Vote_ValidatorIndex != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_ValidatorIndex_serial}
		}
		ka.s += fieldBit__Vote_ValidatorIndex
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	case "Signature":
		if ka.s&fieldBit__Vote_Signature != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Vote_Signature_serial}
		}
		ka.s += fieldBit__Vote_Signature
		ka.state = maState_expectValue
		ka.f = 7
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dagcosmos.Vote.Repr", Key: &_String{k}}
}
func (_Vote__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Vote__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dagcosmos.Vote.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Vote__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Vote__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
